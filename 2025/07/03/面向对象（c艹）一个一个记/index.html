<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面向对象（c艹）一个一个记 | RXCCCCCC</title><meta name="author" content="RXCCCCCC"><meta name="copyright" content="RXCCCCCC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面向过程程序设计OPP(Oriented Procedural Programming)将复杂过程简单的按功能分层从而解决问题编程是面向操作的，编程的单位是函数规范的过程化程序: 过程的功能划分 / 编写 功能与数据分离不符合人们对现实世界的认识要保持功能与数据的相容困难 自顶向下的设计方法限制了软件的可重用性，降低开发效率，软件系统难以维护。  结合在对象中，按对象组织 继承子类自动共">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象（c艹）一个一个记">
<meta property="og:url" content="http://rxcccccc.github.io/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/index.html">
<meta property="og:site_name" content="RXCCCCCC">
<meta property="og:description" content="面向过程程序设计OPP(Oriented Procedural Programming)将复杂过程简单的按功能分层从而解决问题编程是面向操作的，编程的单位是函数规范的过程化程序: 过程的功能划分 / 编写 功能与数据分离不符合人们对现实世界的认识要保持功能与数据的相容困难 自顶向下的设计方法限制了软件的可重用性，降低开发效率，软件系统难以维护。  结合在对象中，按对象组织 继承子类自动共">
<meta property="og:locale" content="zn_CN">
<meta property="og:image" content="http://rxcccccc.github.io/image/avatar.jpg">
<meta property="article:published_time" content="2025-07-03T00:35:38.000Z">
<meta property="article:modified_time" content="2025-07-08T05:56:41.375Z">
<meta property="article:author" content="RXCCCCCC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rxcccccc.github.io/image/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面向对象（c艹）一个一个记",
  "url": "http://rxcccccc.github.io/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/",
  "image": "http://rxcccccc.github.io/image/avatar.jpg",
  "datePublished": "2025-07-03T00:35:38.000Z",
  "dateModified": "2025-07-08T05:56:41.375Z",
  "author": [
    {
      "@type": "Person",
      "name": "RXCCCCCC",
      "url": "http://rxcccccc.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/avatar.jpg"><link rel="canonical" href="http://rxcccccc.github.io/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象（c艹）一个一个记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="RXCCCCCC" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/preview.gif);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 博客の时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/game/word-games"><i class="fa-fw fas fa-font"></i><span> wordle游戏</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/avatar.jpg" alt="Logo"><span class="site-name">RXCCCCCC</span></a><a class="nav-page-title" href="/"><span class="site-name">面向对象（c艹）一个一个记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 博客の时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/game/word-games"><i class="fa-fw fas fa-font"></i><span> wordle游戏</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面向对象（c艹）一个一个记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-03T00:35:38.000Z" title="Created 2025-07-03 08:35:38">2025-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-08T05:56:41.375Z" title="Updated 2025-07-08 13:56:41">2025-07-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">18.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>71mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="面向过程程序设计OPP-Oriented-Procedural-Programming"><a href="#面向过程程序设计OPP-Oriented-Procedural-Programming" class="headerlink" title="面向过程程序设计OPP(Oriented Procedural Programming)"></a>面向过程程序设计OPP(Oriented Procedural Programming)</h2><p>将复杂过程简单的按功能分层从而解决问题<br>编程是<strong>面向操作</strong>的，编程的<strong>单位是函数</strong><br>规范的过程化程序: 过程的功能划分 / 编写</p>
<h4 id="功能与数据分离"><a href="#功能与数据分离" class="headerlink" title="功能与数据分离"></a>功能与数据分离</h4><p>不符合人们对现实世界的认识<br>要保持功能与数据的相容困难</p>
<h4 id="自顶向下的设计方法"><a href="#自顶向下的设计方法" class="headerlink" title="自顶向下的设计方法"></a>自顶向下的设计方法</h4><p>限制了软件的可重用性，<br>降低开发效率，<br>软件系统难以维护。</p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/4e9f2fabd86809a8bfd9e32c2ea93a51.png" alt="4e9f2fabd86809a8bfd9e32c2ea93a51"></p>
<p>结合在对象中，按对象组织</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类自动共享父类数据和方法的机制，它由<strong>类的派生</strong>体现。一个子类直接继承父类的全部描述，同时<strong>可修改和扩充</strong>，继承是对父类的<strong>重用</strong>机制。</p>
<p>E.G</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派生类：圆锥体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cone</span> : <span class="keyword">public</span> Circle</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> height; <span class="comment">// 圆锥高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cone</span>(<span class="type">double</span> X , <span class="type">double</span> Y , <span class="type">double</span> r , <span class="type">double</span> h = <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span> </span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">……</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这段代码定义了一个名为<code>Cone</code>（圆锥体）的派生类，它继承自<code>Circle</code>（圆形）基类。这种结构体现了面向对象编程中的<strong>继承特性</strong>，下面详细解释其各部分含义：</p>
<h3 id="1-类的继承关系"><a href="#1-类的继承关系" class="headerlink" title="1. 类的继承关系"></a>1. 类的继承关系</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cone</span> : <span class="keyword">public</span> Circle</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>class Cone</code>：声明一个名为<code>Cone</code>的类（圆锥体）。</li>
<li><code>: public Circle</code>：表示<code>Cone</code>是<code>Circle</code>的<strong>公有派生类</strong>（<code>public</code>为<strong>继承方式</strong>）。<br>  这意味着：<code>Cone</code>会继承<code>Circle</code>中<strong>所有的非私有成员</strong>（包括<strong>成员变量和成员函数</strong>），可以直接使用基类的功能，同时扩展自己的特性。<br>  （例如：圆形的圆心坐标<code>X,Y</code>、半径<code>r</code>等属性，圆锥体也需要，因此无需重复定义，直接继承即可。）</li>
</ul>
<h3 id="2-私有成员变量"><a href="#2-私有成员变量" class="headerlink" title="2. 私有成员变量"></a>2. 私有成员变量</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> height; <span class="comment">// 圆锥高度</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>private</code>：访问权限修饰符，标识该部分成员<strong>仅能在<code>Cone</code>类内部</strong>使用，外部无法直接访问。</li>
<li><code>double height</code>：定义了圆锥体特有的成员变量<code>height</code>（高度），这是<code>Cone</code>在基类<code>Circle</code>基础上扩展的属性（圆形没有高度，圆锥有）。</li>
</ul>
<h3 id="3-公有成员函数（接口）"><a href="#3-公有成员函数（接口）" class="headerlink" title="3. 公有成员函数（接口）"></a>3. 公有成员函数（接口）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cone</span>(<span class="type">double</span> X , <span class="type">double</span> Y , <span class="type">double</span> r , <span class="type">double</span> h = <span class="number">1</span>); <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span></span>; <span class="comment">// 设置高度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 获取高度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 计算表面积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 计算体积</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 打印信息</span></span><br><span class="line">    ……</span><br></pre></td></tr></tbody></table></figure>

<p>这些是<code>Cone</code>类<strong>对外提供的</strong>接口，用于操作和访问类的成员，具体功能如下：</p>
<ul>
<li><p><strong>构造函数</strong> <code>Cone(...)</code>(<strong>名称与类名相同</strong>,<strong>无返回类型</strong>,<strong>可重载</strong>,)：<br>  用于初始化圆锥体对象，参数包括：<code>X,Y</code>（圆心 / 顶点坐标，继承自<code>Circle</code>）、<code>r</code>（底面半径，继承自<code>Circle</code>）、<code>h</code>（高度，默认值为 1）。<br>  构造函数会<strong>先调用基类<code>Circle</code>的构造函数初始化继承的属性</strong>（如<code>X,Y,r</code>），<strong>再初始化自己的</strong><code>height</code>。</p>
<h5 id="可初始化成员变量"><a href="#可初始化成员变量" class="headerlink" title="可初始化成员变量"></a><strong>可初始化成员变量</strong></h5>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) {} <span class="comment">// 初始化列表（推荐,最直观显式）</span></span><br><span class="line">    <span class="comment">// 或在函数体中赋值：</span></span><br><span class="line">    <span class="comment">// MyClass(int val) { value = val; }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="可调用父类构造函数（继承场景）"><a href="#可调用父类构造函数（继承场景）" class="headerlink" title="可调用父类构造函数（继承场景）"></a><strong>可调用父类构造函数（继承场景）</strong></h5><ul>
<li><p>在派生类的构造函数中，<strong>必须显式调用</strong>父类的构造函数（除非父类有<strong>默认</strong>构造函数(如果类中<strong>未定义任何构造函数</strong>，编译器会自动生成一个<strong>隐式默认构造函数</strong>（无参数）。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">Base</span>(x) {} <span class="comment">// 调用父类构造函数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="不能被声明为const、virtual或static"><a href="#不能被声明为const、virtual或static" class="headerlink" title="不能被声明为const、virtual或static"></a><strong>不能被声明为<code>const</code>、<code>virtual</code>或<code>static</code></strong></h5><ul>
<li>构造函数不能是<code>const</code>（因为它<strong>会修改对象状态</strong>）。</li>
<li>构造函数不能是<code>virtual</code>（虚函数<strong>依赖于对象</strong>的存在，而构造函数<strong>正在创建对象</strong>）。</li>
<li>构造函数不能是<code>static</code>（<strong>静态</strong>函数<strong>属于类</strong>，而<strong>构造</strong>函数<strong>属于对象</strong>）。</li>
</ul>
<h5 id="委托构造函数（C-11-）"><a href="#委托构造函数（C-11-）" class="headerlink" title="委托构造函数（C++11+）"></a><strong>委托构造函数（C++11+）</strong></h5><ul>
<li><p>构造函数可以<strong>调用同一个类的其他构造函数</strong>，避免代码重复。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">value</span>(x) {}</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) {} <span class="comment">// 委托给另一个构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>setter 和 getter 函数</strong>：</p>
<ul>
<li><code>setHeight(double h)</code>：设置圆锥的高度（修改<code>height</code>的值）。</li>
<li><code>getHeight() const</code>：返回圆锥的高度（读取<code>height</code>的值）。<br>  这是封装特性的体现：<strong>通过函数间接访问私有</strong>变量**(在内部)**，<strong>避免外部直接修改</strong>，保证数据安全性。</li>
</ul>
</li>
<li><p><strong>功能计算函数</strong>：</p>
<ul>
<li><code>calculateArea() const</code>：计算圆锥的表面积（基类<code>Circle</code>若有计算圆面积的函数，<strong>则此处重写</strong>为圆锥的表面积）。</li>
<li><code>calculateVolume() const</code>：计算圆锥的体积（圆锥特有的功能，基类<code>Circle</code>没有）。</li>
</ul>
</li>
<li><p><strong>信息打印函数</strong>：</p>
<ul>
<li><code>printInfo() const</code>：打印圆锥的所有信息（如圆心坐标、半径、高度、表面积、体积等），通常会结合继承自基类的信息和自身的信息。</li>
</ul>
</li>
</ul>
<h3 id="总结：结构的核心意义"><a href="#总结：结构的核心意义" class="headerlink" title="总结：结构的核心意义"></a>总结：结构的核心意义</h3><ul>
<li><strong>继承复用</strong>：<code>Cone</code>通过继承<code>Circle</code>，直接复用了圆形的属性（如圆心、半径），<strong>无需重复定义，减少代码冗余</strong>。</li>
<li><strong>扩展功能</strong>：在继承的基础上，<code>Cone</code><strong>增加</strong>了自身特有的属性（高度）和方法（体积计算、表面积计算等），实现了 “圆锥是一种特殊的圆形（带高度）” 的逻辑关系。</li>
<li><strong>封装接口</strong>：通过公有成员函数对外提供访问接口，<strong>隐藏内部实现细节</strong>（如<code>height</code>的存储方式），符合面向对象的封装原则。</li>
</ul>
<p>这种结构使得代码更具扩展性和维护性，例如未来若需要修改圆形的属性（如增加颜色），圆锥体也能自动继承该特性。这段代码定义了一个名为<code>Cone</code>的类，它是从<code>Circle</code>类派生而来的，这意味着<code>Cone</code>继承了<code>Circle</code>的属性和方法。这种继承关系形成了面向对象编程中的<strong>父子类结构</strong>。</p>
<h3 id="代码结构解析："><a href="#代码结构解析：" class="headerlink" title="代码结构解析："></a>代码结构解析：</h3><ol>
<li><strong>类定义</strong>：<ul>
<li><code>class Cone : public Circle</code>：<code>Cone</code>类公开继承自<code>Circle</code>类，因此<code>Cone</code>可以访问<code>Circle</code>的公有成员。</li>
</ul>
</li>
<li><strong>私有成员变量</strong>：<ul>
<li><code>double height;</code>：圆锥的高度，这是<code>Cone</code>类特有的属性。</li>
</ul>
</li>
<li><strong>构造函数</strong>：<ul>
<li><code>Cone(double X, double Y, double r, double h = 1)</code>：初始化圆锥的位置（继承自<code>Circle</code>的<code>X</code>和<code>Y</code>）、底面半径（继承自<code>Circle</code>的<code>r</code>）和高度<code>h</code>（默认值为 1）。</li>
</ul>
</li>
<li><strong>成员函数</strong>：<ul>
<li><code>setHeight(double h)</code>：设置圆锥的高度。</li>
<li><code>getHeight() const</code>：返回圆锥的高度。</li>
<li><code>calculateArea() const</code>：计算圆锥的表面积（可能包括底面积和侧面积）。</li>
<li><code>calculateVolume() const</code>：计算圆锥的体积。</li>
<li><code>printInfo() const</code>：打印圆锥的信息，可能包括位置、半径、高度、表面积和体积。</li>
</ul>
</li>
</ol>
<p><code>const</code> 关键字放在函数声明的后面，其作用是表明这个函数属于<strong>常量成员函数</strong>。如果写在<strong>前面</strong>则表示的是其<strong>返回值</strong>是常量</p>
<h3 id="1-常量成员函数的功能"><a href="#1-常量成员函数的功能" class="headerlink" title="1. 常量成员函数的功能"></a>1. 常量成员函数的功能</h3><ul>
<li><strong>保护对象状态</strong>：常量成员函数不可以对调用它的对象的非静态数据成员进行修改。</li>
<li><strong>适配常量对象</strong>：<strong>只有</strong>常量成员函数才能够被常量对象调用。</li>
</ul>
<h3 id="2-代码示例与说明"><a href="#2-代码示例与说明" class="headerlink" title="2. 代码示例与说明"></a>2. 代码示例与说明</h3><p>下面是一个包含常量成员函数的类：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) {}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量成员函数：不能修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> radius; <span class="comment">// 允许，因为没有修改成员变量</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量成员函数：计算圆的面积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="comment">// radius = 10.0; // 错误！不可以修改成员变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非常量成员函数：可以修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> r)</span> </span>{</span><br><span class="line">        radius = r; <span class="comment">// 允许，因为这不是常量成员函数</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-常量对象与函数调用规则"><a href="#3-常量对象与函数调用规则" class="headerlink" title="3. 常量对象与函数调用规则"></a>3. 常量对象与函数调用规则</h3><ul>
<li><strong>常量对象</strong>：<strong>只能调用常量成员</strong>函数。</li>
<li><strong>非常量对象</strong>：<strong>既能调用常量成员函数，也能调用非常量成员函数</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Circle <span class="title">c1</span><span class="params">(<span class="number">5.0</span>)</span></span>; <span class="comment">// 常量对象,同时进行了初始化</span></span><br><span class="line"><span class="type">double</span> area = c<span class="number">1.</span><span class="built_in">calculateArea</span>(); <span class="comment">// 正确，calculateArea是常量成员函数</span></span><br><span class="line"><span class="comment">// c1.setRadius(10.0); // 错误，常量对象不能调用非常量成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">c2</span><span class="params">(<span class="number">3.0</span>)</span></span>; <span class="comment">// 非常量对象</span></span><br><span class="line">c<span class="number">2.</span><span class="built_in">setRadius</span>(<span class="number">10.0</span>); <span class="comment">// 正确</span></span><br><span class="line">area = c<span class="number">2.</span><span class="built_in">calculateArea</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-技术原理"><a href="#4-技术原理" class="headerlink" title="4. 技术原理"></a>4. 技术原理</h3><ul>
<li><p>隐式<code>this</code>指针的类型</p>
<p>  ：</p>
<ul>
<li>在常量成员函数里，<code>this</code> 指针的类型是 <code>const ClassName*</code>。</li>
<li>在非常量成员函数中，<code>this</code> 指针的类型是 <code>ClassName*</code>。</li>
</ul>
</li>
</ul>
<h3 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h3><ul>
<li><strong>访问器（Getter）函数</strong>：通常会被声明为常量成员函数，比如 <code>getRadius()</code>。</li>
<li><strong>不修改对象的计算函数</strong>：像 <code>calculateArea()</code> 就属于这类函数。</li>
<li><strong>操作符重载</strong>：例如 <code>operator==</code> 通常也会被声明为常量成员函数。</li>
</ul>
<h3 id="6-注意要点"><a href="#6-注意要点" class="headerlink" title="6. 注意要点"></a>6. 注意要点</h3><ul>
<li><strong>函数重载</strong>：常量版本和非常量版本的同一函数可以同时存在。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> constData; } <span class="comment">// 常量版本</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">getData</span><span class="params">()</span> </span>{ <span class="keyword">return</span> data; } <span class="comment">// 非常量版本</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* constData;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>可变数据成员（mutable）</strong>：被 <code>mutable</code> 修饰的数据成员，能够在常量成员函数中被修改。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount; <span class="comment">// 可变数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        accessCount++; <span class="comment">// 允许，因为accessCount是mutable的</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承关系说明："><a href="#继承关系说明：" class="headerlink" title="继承关系说明："></a>继承关系说明：</h3><ul>
<li><strong>父类（基类）</strong>：<code>Circle</code>类（假设包含圆心坐标<code>X</code>、<code>Y</code>和半径<code>r</code>）。</li>
<li><strong>子类（派生类）</strong>：<code>Cone</code>类通过继承获得了<code>Circle</code>的属性，并添加了自己的属性<code>height</code>。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在<strong>继承体系结构</strong>中，同一消息<strong>为不同的对象接受时可产生完全不同的行动</strong></p>
<p>利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消<br>息的对象自行决定</p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template<typename t=""></typename></h2><p>template：声明这是一个模板。<br>typename T：声明一个<strong>类型参数T</strong>，T<strong>可以是任何类型</strong>（如int、double、string等）。<br>typename 也可以用 class 替代（如 template<class t="">），两者在模板中<strong>含义相同</strong>。</class></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T buffer[<span class="number">100</span>]; <span class="comment">// 假设栈大小为100</span></span><br><span class="line">    <span class="type">int</span> top;       <span class="comment">// 栈顶位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>() : <span class="built_in">top</span>(<span class="number">-1</span>) {} <span class="comment">// 初始化栈顶为-1，表示空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">99</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈满</span></span><br><span class="line">        buffer[++top] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (top &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">"Stack is empty!"</span>; <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> buffer[top--];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack;    <span class="comment">// 存储int的栈</span></span><br><span class="line">Stack&lt;<span class="type">double</span>&gt; doubleStack; <span class="comment">// 存储double的栈</span></span><br><span class="line"></span><br><span class="line">intStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">doubleStack.<span class="built_in">push</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="数据结构与数据访问"><a href="#数据结构与数据访问" class="headerlink" title="数据结构与数据访问"></a><strong>数据结构</strong>与数据访问</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * length); </span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span> [length] ;</span><br><span class="line"><span class="keyword">delete</span> [ ]p2; <span class="comment">// 释放数组用法</span></span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">// 释放单个元素</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="C-函数的新特性"><a href="#C-函数的新特性" class="headerlink" title="C++函数的新特性"></a>C++函数的新特性</h2><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h4><p>对一个数据可以使用引用(reference)的方式声明，引用的作用是<strong>为一个变量起一个别名</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a ; </span><br><span class="line">int &amp;b = a; // 声明b是int a的引用</span><br><span class="line">b = 20; // a = 20</span><br></pre></td></tr></tbody></table></figure>

<p>在一条语句中声明多个引用时<strong>应逐一声明</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; x=a, y = b，z = c ; <span class="comment">//error</span></span><br><span class="line"><span class="type">int</span> &amp;x=a, &amp;y=b, &amp;z=c; </span><br></pre></td></tr></tbody></table></figure>

<p>声明引用变量<strong>必须进行初始化</strong>，引用未定义变量称悬挂引用。<br>将前面声明的引用重新变为另一变量的别名是个<strong>逻辑错误</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y =<span class="number">5</span>, z = <span class="number">3</span>; </span><br><span class="line"><span class="type">int</span> &amp;x = z, &amp;x = y</span><br></pre></td></tr></tbody></table></figure>

<p>&amp;在此<strong>不是求地址运算</strong>，而是起<strong>标识</strong>作用。</p>
<p>引用声明完毕后，相当于目标变量名有<strong>两个名称</strong>，</p>
<p>声明一个引用，<strong>不是新定义了一个变量</strong>，引用本身<strong>不占存储单元</strong>，系统也不给引用分配存储单元。</p>
<p>引用即用别名引用这个变量,目的是为了消除指针</p>
<h4 id="引用传递的特点"><a href="#引用传递的特点" class="headerlink" title="引用传递的特点"></a>引用传递的特点</h4><p><strong>消除了复制大量数据的开销</strong>，有利提高执行效率；<br>在被调用函数中直接使用形参变量，提高可读性；<br>安全性较差，被调用函数能直接访问和修改调用者的数据。<br>fun( const T&amp; value)；<br>若要传递较大的对象，用常量引用参数模拟按值调用．<br>要指定引用常量，在参数声明的类型说明符前面加上const</p>
<h4 id="内联函数inline-以相应代码代替"><a href="#内联函数inline-以相应代码代替" class="headerlink" title="内联函数inline(以相应代码代替)"></a><strong>内联函数inline(以相应代码代替)</strong></h4><p>C++为<strong>降低小程序调用开销</strong>的一种机制。<br><strong>默认参数值 default parameter value</strong><br>函数参数的默认值使得在函数调用时<strong>可不指定参数。</strong></p>
<p><strong>建议性声明：不能含有复杂结构控制语句和递归调用</strong></p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h4><p>常用于处理<strong>不同数据类型</strong>而<strong>功能类似</strong>的<strong>同名</strong>函数;</p>
<h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><p>经常需要用<strong>相同的参数调用同一函数时</strong>，简化函数调用。<br>当函数调用时，若实参数个数少于形参数的总数时，<br>则所缺参数自动取函数参数表中设置的缺省值。：<br>当函数声明时，由<strong>右至左指定默认参数</strong>的值</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length, <span class="type">int</span> width = <span class="number">1</span>, <span class="type">int</span> highth =<span class="number">1</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="title">volumn</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">2</span>, ,<span class="number">2</span>);<span class="comment">//中间参数默认</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length, <span class="type">int</span> width = <span class="number">1</span>, <span class="type">int</span> highth =<span class="number">1</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length, <span class="type">int</span> width )</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length)</span>；</span></span><br><span class="line"><span class="function"><span class="title">volumn</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//有二义性,回出错</span></span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">2</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">1</span>,<span class="number">2</span> ,<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="初识类"><a href="#初识类" class="headerlink" title="初识类"></a>初识类</h2><h2 id="封装-encapsulate"><a href="#封装-encapsulate" class="headerlink" title="封装(encapsulate)"></a>封装(encapsulate)</h2><ul>
<li>把全部属性和全部行为封装在一起，<br>  形成一个不可分割的独立单位（即对象）。</li>
<li>信息隐蔽(information hiding)<br>  对象的外部不能直接地存取对象属性，只能通过几个允许外部使用的服务与对象发生联系。</li>
<li><strong>对象间通发送消息</strong>进行交互.</li>
</ul>
<p>类是面向对象编程的<strong>程序基本单位</strong><br>程序<strong>模块</strong>是各种<strong>由类构成的</strong><br>类是<strong>逻辑上相关</strong>数据和函数的<strong>封装</strong><br>类是对问题的<strong>抽象描述</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 {</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line"><span class="comment">//私有数据成员和成员函数；</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line"><span class="comment">//保护数据成员和成员函数；</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="comment">//公有数据成员和成员函数；</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在<strong>类的外部</strong>定义成员函数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回类型 类名::成员函数名(参数列表)</span><br><span class="line">{</span><br><span class="line">函数定义体</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">( )</span></span>{ cout &lt;&lt; m_a &lt;&lt; m_b &lt;&lt;endl;}</span><br></pre></td></tr></tbody></table></figure>

<p>在<strong>类内</strong>直接定义成员函数, <strong>默认创建为内联</strong>函数<br>如果成员函数在类体外定义,要<strong>用inline声明为内联</strong>函数</p>
<p><strong>域运算符“∷”</strong>，<strong>成员运算符“.”</strong></p>
<p>在类外定义函数时，应指明成员函数的<strong>作用域</strong></p>
<p>在成员函数引用本对象的数据成员时，只需<strong>直接写数据成员名，</strong><br>这时C++系统会把它默认为本对象的数据成员。</p>
<h4 id="保护-protected"><a href="#保护-protected" class="headerlink" title="保护 protected"></a><strong>保护</strong> protected</h4><p><strong>除了类本身的成员函数和说明为友元函数或友元类的成员函数可以访问保</strong></p>
<p><strong>护成员外，该类的派生类的成员也可以访问</strong><strong>。</strong></p>
<p><strong>private 在首次出现时可以忽略</strong></p>
<h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a><strong>对象的使用</strong></h2><p><strong>同类对象之间可以相互赋值</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time tA, tB;</span><br><span class="line">tA.<span class="built_in">set</span> (<span class="number">15</span>,<span class="number">6</span>,<span class="number">0</span>);</span><br><span class="line">tB = tA;</span><br></pre></td></tr></tbody></table></figure>

<p>成员访问运算符“.” 和**“-&gt;”(对象指针名-&gt;成员名)**</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; t.hour &lt;&lt; pTime -&gt;<span class="built_in">min</span>(相当于访问所指对象的成员min) &lt;&lt; (*pTime).sec;</span><br></pre></td></tr></tbody></table></figure>

<p>软件工程的一个最基本的原则就是<strong>将接口与实现分离</strong>，信息隐蔽是软件工程中一个非常重要的概念。</p>
<p><strong>自定义类库头文件.h</strong><br>文件中有用户自行设计的类的定义，包括类的外部接口（公有成员函数的原型）。任何需要使用这些类的源程序，只要在文件中包含这些头文件即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//point.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">distance</span><span class="params">(Point &amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> j)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//point.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"point.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::distance</span><span class="params">(Point &amp; p)</span></span>{<span class="comment">//定义要指明作用域</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((p.x-x)*(p.x-x)+(p.y-y)*(p.y-y)); }</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setX</span><span class="params">(<span class="type">double</span> i)</span></span>{x=i;}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setY</span><span class="params">(<span class="type">double</span> j)</span></span>{y=j;}</span><br></pre></td></tr></tbody></table></figure>

<p>在面向对象的程序开发中，一般做法是将<strong>类的声明</strong>放在指定的头文件中，用户如果想用该类，只要把有关的头文件包含进来即可，不必在程序中重复书写类的声明,在<strong>程序中</strong>就可以用该类来<strong>定义</strong>对象.为了实现信息隐蔽，对类成员函数的定义一般不放在头文件中，而另外放在一个文件中。</p>
<h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><p>(自定义)<strong>默认构造函数</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;默认构造函数名&gt;（）</span><br><span class="line">{ }</span><br><span class="line">Time::<span class="built_in">Time</span>( )</span><br><span class="line">{ hour=min=sec = <span class="number">0</span>; }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>析构函数</strong></p>
<p>构造函数的反函数，析构函数是用于<strong>取消对象成员</strong>函数，<br>当一个对象生命期结束时，系统自动调用析构函数。</p>
<ul>
<li>析构函数名字为**符号“~”**加类名；<ul>
<li>析构函数<strong>没有参数和返回值</strong>。<ul>
<li>一个类中只可能定义一个析构函数，<br>  析构函数<strong>不能重载</strong>。<ul>
<li>析构函数的作用<br>  进行清除对象，释放内存等；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名::</span><br><span class="line">~默认析构函数名（）</span><br><span class="line">{ }<span class="comment">//空函数</span></span><br></pre></td></tr></tbody></table></figure>

<p>自动调用<br>(1) 一个对象当其结束生命周期时 ；<br>(2) 使用<strong>new运算符创建的对象</strong>，<br>在<strong>使用delete运算符释放</strong>该对象时；<br>一般析构函数的<strong>调用顺序</strong>与构造函数<strong>相反</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Rational{</span><br><span class="line">public:</span><br><span class="line">Rational(int nn=1,int mm=1); //构造函数</span><br><span class="line">void print() ; // 输出化简的 分子/分母</span><br><span class="line">void simple(); // 约分</span><br><span class="line">double getValue(); // 返回分数值</span><br><span class="line">Rational add(Rational &amp; A); // r = r1.add(r2); </span><br><span class="line">void sub(Rational &amp; A , Rational &amp;B); // r.sub(r1,r2);</span><br><span class="line">Rational mul(Rational &amp; A);</span><br><span class="line">void _div(Rational &amp; A, Rational &amp;B); </span><br><span class="line">private:</span><br><span class="line">int m; // 分母</span><br><span class="line">int n; // 分子</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>一般情况下，如果类中的数据<strong>都在栈里</strong>，程序员不需要开发<strong>自定义的拷贝构造函数</strong></p>
<p><strong>默认拷贝构造函数</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A  b ( a )</span><br></pre></td></tr></tbody></table></figure>

<p>对象复制与对象赋值是<strong>不同的</strong></p>
<p>静态数据成员的初始化与一般数据成员不同,<strong>外部</strong>静态数据成员初始化的格式如下：	</p>
<p>&lt;类型&gt; &lt;类名&gt;::&lt;静态数据成员&gt; = &lt;值&gt;;</p>
<p>3）在引用静态数据成员时采用格式：	  </p>
<p><strong>&lt;类名&gt;::&lt;静态数据成员&gt;</strong>    &lt;对象名&gt;. &lt;静态数据成员&gt;</p>
<p>静态数据成员 vs 全局变量     </p>
<p>有了静态数据成员，<strong>各对象之间(即不依赖于对象使用)<strong>的数据有了沟通的渠道，实现数据共享 。    全局变量</strong>破坏了封装的原则</strong>，不符合面向对象程序的要求。   </p>
<p>公用静态数据成员与全局变量的作用域不同  </p>
<p>静态数据成员的作用域<strong>只限于定义该类的作用域内</strong> </p>
<p>静态成员函数<strong>只能访问静态数据成员、静态成员函数和类以外的函数和数据，不能访问类中的非静态数据成员（因为非静态数据成员只有对象存在时才有意义）</strong>。但静态数据成员和静态成员函数可由任意访问权限许可的函数访问。和一般成员函数类似，静态成员函数也有访问限制，私有静态成员函数不能由外界访问。静态成员函数<strong>没有this指针</strong>，因此，静态成员函数<strong>只能直接访问类中的静态成员</strong>，若要访问类中的非静态成员时，<strong>必须借助对象名或指向对象的指针</strong>。 </p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Counter</span></span><br><span class="line">{         <span class="type">static</span>  <span class="type">int</span>  num ;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">           <span class="built_in">Counter</span>( ){ num++; }</span><br><span class="line">            ～<span class="built_in">Counter</span>(){ num--; }</span><br><span class="line">     <span class="function"><span class="type">void</span>  <span class="title">setnum</span> <span class="params">( <span class="type">int</span> i )</span> </span>{ num = i ; }	</span><br><span class="line">     <span class="function"><span class="type">void</span>  <span class="title">shownum</span><span class="params">()</span> </span>{ cout &lt;&lt; num &lt;&lt; <span class="string">'\t'</span> ; }</span><br><span class="line">     <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>{ <span class="keyword">return</span> num ; }</span><br><span class="line">} ;</span><br><span class="line"><span class="type">int</span>  Counter :: num = <span class="number">0</span> ;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{  	Counter  a ;      a.<span class="built_in">shownum</span>() ;</span><br><span class="line">	Counter  b ;      b.<span class="built_in">shownum</span>() ;</span><br><span class="line">	cout&lt;&lt;Counter::<span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>static 数据是<strong>类共有</strong>的,static 函数可以类名调用，也可以对象调用,<strong>普通成员函数能访问static数据</strong></p>
<p>const成员变量<strong>只能由构造函数通过初始化列表对该数据成员进行初始化</strong></p>
<p>若<strong>成员函数不修改对象</strong>,则声明为const.</p>
<p>const关键词可以<strong>参与区分重载函数</strong>。</p>
<p>const 对象<strong>只能调用它的const 成员函数</strong>，而不能调用其他成员函数。</p>
<p>直接初始化</p>
<p><strong>分配空间的同时进行初始化</strong>. 一般数组成员较少.</p>
<p>Box b[3] = {Box(1),Box(1,1),Box(1,1,1)};  </p>
<p>间接初始化</p>
<p><strong>先分配空间</strong>，<strong>之后完成初始化</strong>. </p>
<p>Box a[50];//先调用默认                      </p>
<p>for( int i = 0; i&lt;50;i++){ a[i].set(i, i, i); }</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Box box [<span class="number">3</span>] ;</span><br><span class="line">Box box [<span class="number">3</span>] = {<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)};  </span><br><span class="line">Box box [<span class="number">3</span>] = {<span class="built_in">Box</span>(),<span class="built_in">Box</span>(),<span class="built_in">Box</span>()};</span><br><span class="line">Box box [<span class="number">3</span>] = {Box, Box ,Box };</span><br><span class="line">Box box [<span class="number">3</span>] = {<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">2</span>),  };</span><br><span class="line">Box box [<span class="number">3</span>] = {<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>) };</span><br><span class="line">Box box [<span class="number">3</span>] = {<span class="built_in">Box</span>(<span class="number">1</span>) };</span><br><span class="line">Box box [<span class="number">3</span>] = { };</span><br><span class="line">Box box [<span class="number">3</span>] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">Box *p =<span class="keyword">new</span> Box[<span class="number">3</span>];</span><br><span class="line">Box *p =<span class="keyword">new</span> Box[<span class="number">3</span>]{<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) };</span><br></pre></td></tr></tbody></table></figure>

<h2 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line">      Point（<span class="type">int</span>=<span class="number">0</span>,<span class="type">int</span>=<span class="number">0</span>）;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span>  </span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> x; </span><br><span class="line">     <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>                                   </span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Circle</span>(<span class="type">double</span> r, Point p);</span><br><span class="line">      <span class="built_in">Circle</span>(<span class="type">double</span> r, <span class="type">int</span> x, <span class="type">int</span> y)；</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">       <span class="function">Point <span class="title">getCenter</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> radius;</span><br><span class="line">      Point  center;<span class="comment">//类的嵌套    </span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="构造函数-必须首先初始化内嵌对象的数据"><a href="#构造函数-必须首先初始化内嵌对象的数据" class="headerlink" title="构造函数: 必须首先初始化内嵌对象的数据"></a>构造函数: 必须首先初始化内嵌对象的数据</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Circle ::<span class="built_in">Circle</span>(<span class="type">double</span> r, <span class="type">int</span> x, <span class="type">int</span> y):<span class="built_in">radius</span>(r), <span class="built_in">center</span>(x,y){ }</span><br><span class="line">Circle ::<span class="built_in">Circle</span>(<span class="type">double</span> r, Point p):<span class="built_in">radius</span>(r), <span class="built_in">center</span>(p){ }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="成员函数-可以使用内嵌对象调用其函数-注意访问权限控制！"><a href="#成员函数-可以使用内嵌对象调用其函数-注意访问权限控制！" class="headerlink" title="成员函数: 可以使用内嵌对象调用其函数. 注意访问权限控制！"></a>成员函数: 可以使用内嵌对象调用其函数. 注意访问权限控制！</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>{</span><br><span class="line">       	center.<span class="built_in">setX</span>(x);  <span class="comment">//center.x = x;   compiler error!</span></span><br><span class="line">       	center.<span class="built_in">setY</span>(y);  <span class="comment">//center.y = y;   compiler error!</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="成员对象的初始化"><a href="#成员对象的初始化" class="headerlink" title="成员对象的初始化"></a>成员对象的初始化</h4><p>一个对象如果有**“成员对象”<strong>（即它的成员数据不是普通类型，而是“类”类型的），那么在</strong>实现构造函数时应对“成员对象”进行初始化**)</p>
<p>方式是在构造函数中<strong>增加构造参数，指明“成员对象”构造的方式</strong></p>
<p>若没有“成员对象”构造方式的声明，系统<strong>默认调用“成员对象”的无参的构造函数。</strong></p>
<h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>一个类包含另一个类的对象</p>
<p>描述<strong>整体拥有部分</strong>的关系，即<strong>has-a关系</strong></p>
<p>该类不与其他类共享对象的引用。即**“整体”端重数只能是1**</p>
<p>如果这种类的对象生命周期结束，<strong>被包含的对象的生命周期也会结束。</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Textfield</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Botton</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DialogueWindow</span>{</span><br><span class="line">	Textfield textfield;   <span class="comment">//data member</span></span><br><span class="line">	Botton botton;        <span class="comment">//data member</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DialogueWindow</span>{</span><br><span class="line">	Textfield textfield1;  <span class="comment">//data member</span></span><br><span class="line">          Textfield textfield2;  <span class="comment">//data member</span></span><br><span class="line">	Botton botton1;          <span class="comment">//data member</span></span><br><span class="line">          Botton botton2;          <span class="comment">//data member</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>描述两个类对象之间<strong>短暂的相互作用</strong></p>
<p>依赖关系表示一个类的对象<strong>短暂使用了另一个类对象</strong>，代表类之间**“uses-a”关系**</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>{</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> hour;</span><br><span class="line">		<span class="type">int</span> minute;</span><br><span class="line">		<span class="type">int</span> second;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>{  cout&lt;&lt;hour&lt;&lt;“ ”&lt;&lt;minute&lt;&lt;“ ”&lt;&lt;second&lt;&lt;endl;}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> {         <span class="comment">// 打印机类</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>{...} <span class="comment">// 打印</span></span><br><span class="line">}; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>   <span class="comment">// 学生类</span></span><br><span class="line">{  <span class="comment">// 使用打印机</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">usePrinter</span><span class="params">(Printer &amp;p)</span></span>{  p.<span class="built_in">print</span>();  }	</span><br><span class="line">     ……</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	Printer printer;   Student studnet;</span><br><span class="line">	student.<span class="built_in">usePrinter</span>(printer);                </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Student类的成员<strong>不包含打印机Printer的对象或者指针</strong>，即二者<strong>不具有“拥有has-a’关系</strong>。<strong>只有学生对象调用usePrinter( )函数时，学生对象与打印机对象才建立关系</strong>，并且在该<strong>函数执行完毕后，二者关系就结束了</strong>。一种<strong>短暂的”使用关系”</strong>，即“use-a”关系。依赖关系除了<strong>被依赖方作为依赖方的函数参数，还可能作为依赖方的函数中的临时对象</strong>。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">private</span>:   <span class="type">int</span> x;</span><br><span class="line">Public:  <span class="built_in">A</span>(){x=<span class="number">1</span>;}</span><br><span class="line">&nbsp; &nbsp; &nbsp;<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>{</span><br><span class="line">Private:  <span class="type">char</span> c;</span><br><span class="line">Public:  <span class="built_in">B</span>() {c=<span class="string">'c'</span>;}</span><br><span class="line">              <span class="function"><span class="type">void</span> <span class="title">something</span><span class="params">()</span></span>{</span><br><span class="line">                      A instance;</span><br><span class="line">	cout&lt;&lt;instance.x&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	B b_instance;</span><br><span class="line">	b_instance.<span class="built_in">something</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="友元-函数-与友元类"><a href="#友元-函数-与友元类" class="headerlink" title="友元 函数 与友元类"></a>友元 函数 与友元类</h2><h4 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h4><p>可以访问另一个类的<strong>私有和保护（稍后更多）成员(区别于组合)</strong></p>
<p>友元函数不是类的成员函数</p>
<p>友元函数<strong>在类范围之外定义</strong></p>
<h4 id="友元的特性"><a href="#友元的特性" class="headerlink" title="友元的特性"></a>友元的特性</h4><p>友元是**“给予”的，而不是“索要”的**</p>
<p><strong>非对称</strong>性（如果 B 是 A 的友元，A 不一定是 B 的友元）</p>
<p><strong>非传递</strong>性（如果 A 是 B 的友元，B 是 C 的友元，A 不一定是 C 的友元） </p>
<h4 id="友元的主要用途"><a href="#友元的主要用途" class="headerlink" title="友元的主要用途"></a>友元的主要用途</h4><p>提供了一种访问类成员的更方便快捷的途径</p>
<p>为运算符重载的实现提供了更方便的途径</p>
<p>友元<strong>可以访问类的任何成员(可不通过成员函数)</strong>,这破环了类的封装性，因此要谨慎使用友元</p>
<p><strong>有权从类外部更改类的内部状态</strong>。 因此推荐使用成员函数而不是友元来改变状态 </p>
<h4 id="friend-声明"><a href="#friend-声明" class="headerlink" title="friend 声明"></a>friend 声明</h4><p><strong>friend 函数</strong> </p>
<p> Keyword friend</p>
<p>friend int myFunction( int x );</p>
<p> <strong>声明在类内</strong>，<strong>保证这个函数可以在类外访问类成员</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="built_in">Accumulator</span>() { m_value = <span class="number">0</span>; } </span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>{ m_value += value; }</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 声明reset() 函数是本类的友元函数</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// reset() 现在是 Accumulator 的友元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span>{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 可以直接访问Accumulator 对象的任何数据</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;accumulator.m_value = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="friend-类"><a href="#friend-类" class="headerlink" title="friend 类"></a>friend 类</h4><p>在类名前加 friend <strong>保证该类可以访问类成员</strong>,可以让整个类成为另一个类的友元。 这使<strong>友元类的所有成员函数都可以访问其他类的私有成员</strong>。友元类的<strong>所有函数都是友元函数</strong> </p>
<p>也可以不把整个类声明为友元, 仅仅只声明一个或多个函数为另一个类的友元函数. 这类似于声明普通函数成为友元，<strong>除了使用包含 className:: 前缀</strong></p>
<p>友元常用于<strong>定义重载运算符时</strong>。当两个或多个类需要以一种亲密的方式一起工作时，<strong>不常使用友元</strong>。使一个<strong>类</strong>成为友元<strong>只需要作为前向声明</strong>该类存在。 但是，使特定的类的<strong>成员函数</strong>成为友元则需要<strong>首先看到成员函数类的完整声明</strong>.</p>
<h2 id="继承-不允许继承循环"><a href="#继承-不允许继承循环" class="headerlink" title="继承(不允许继承循环)"></a><strong>继承</strong>(<strong>不允许继承循环</strong>)</h2><h4 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a><strong>继承的概念</strong></h4><p><strong>派生类具有基类的特性</strong></p>
<ul>
<li><p><strong>共享</strong>基类的<strong>成员函数</strong></p>
</li>
<li><p>使用基类的数据成员</p>
</li>
</ul>
<p><strong>派生类新增成员(拓展)</strong></p>
<ul>
<li><p>定义自己的数据成员</p>
</li>
<li><p>定义独特的成员函数</p>
</li>
</ul>
<p><strong>派生类改造基类</strong></p>
<ul>
<li><strong>重写基类某些成员函数</strong></li>
</ul>
<p>C++中单继承派生类的定义形式如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : [继承方式] 基类名</span><br><span class="line">{</span><br><span class="line">派生类成员声明;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>继承方式包括：</p>
<p>public（公有继承）<br>private（私有继承，<strong>默认</strong>）<br>protected（保护继承）(<strong>保护成员在本类与派生类中能直接访问</strong>)</p>
<p>C++中多重继承派生类的定义形式如下</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: [继承方式] 基类名<span class="number">1</span>, [继承方式] 基类名<span class="number">2</span>,…, </span><br><span class="line">[继承方式] 基类名n</span><br><span class="line">{</span><br><span class="line">派生类成员声明;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">protected</span> Student, Teacher<span class="comment">//对Teacher默认是私有继承</span></span><br><span class="line">{ …… };</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/fa7f516ffbe998538989d54213bb5837.png" alt="fa7f516ffbe998538989d54213bb5837"></p>
<p><strong>继承方式决定了基类成员在派生类中的访问权，</strong></p>
<p><strong>这种访问来自两个方面</strong>：</p>
<ul>
<li><strong>派生类中</strong></li>
</ul>
<p>新增函数成员访问从基类继承来的成员</p>
<ul>
<li><strong>派生类外部</strong></li>
</ul>
<p>通过派生类的对象访问从基类继承的成员</p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/94de02253d18c73529beb0753b328c5d.png" alt="94de02253d18c73529beb0753b328c5d"></p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/98f37468b772cd29ba63bb8ba5dfef81.png" alt="98f37468b772cd29ba63bb8ba5dfef81"></p>
<h4 id="访问私有继承的成员"><a href="#访问私有继承的成员" class="headerlink" title="访问私有继承的成员"></a>访问私有继承的成员</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> { <span class="type">int</span> number; <span class="type">char</span> school[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">protected</span>: <span class="type">char</span> name[<span class="number">10</span>]; <span class="type">char</span> sex; </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">input_data</span><span class="params">( )</span></span>; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>; };</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeStudent</span> : <span class="keyword">private</span> Student</span><br><span class="line">{ <span class="type">char</span> major[<span class="number">10</span>]; <span class="comment">//新增成员:专业</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input_major</span><span class="params">( )</span></span>{cin&gt;&gt;major ; } </span><br><span class="line"><span class="comment">// 输入专业</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span></span>{ Student::<span class="built_in">print</span>(); </span><br><span class="line"><span class="comment">// 输出信息</span></span><br><span class="line">cout&lt;&lt;“name:”&lt;&lt;name &lt;&lt;“ sex:”&lt;&lt;sex &lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;<span class="string">"major:"</span>&lt;&lt;major&lt;&lt;endl; } </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> { …… };</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeStudent</span> : <span class="keyword">private</span> Student{...};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">Student s; s.<span class="built_in">input_data</span>(); s.<span class="built_in">print</span>();</span><br><span class="line">CollegeStudent cs;</span><br><span class="line">cs.<span class="built_in">input_data</span>(); <span class="comment">// 错误</span></span><br><span class="line">cs.<span class="built_in">input_major</span>();</span><br><span class="line">cs.<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; }</span><br></pre></td></tr></tbody></table></figure>

<p>CollegeStudentl类访问基类,Student的能力没有变化，</p>
<p>在私有继承的情况下，通过派生类**对象(并非类内)**无法访问基类的任何成员</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{ <span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_XY</span><span class="params">( )</span> </span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put_XY</span><span class="params">( )</span> </span>; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::get_XY</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{ cin &gt;&gt; x &gt;&gt; y ; }</span><br><span class="line"><span class="type">void</span> A:: <span class="built_in">put_XY</span>( )</span><br><span class="line">{ cout &lt;&lt; <span class="string">"x = "</span>&lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span> ; }</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{ <span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_S</span><span class="params">()</span> </span>{ s = x * y ; <span class="keyword">return</span> s ; } </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">{ <span class="keyword">public</span> : </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_H</span><span class="params">()</span> </span>{ cin &gt;&gt; h ; } </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_V</span><span class="params">()</span> </span>{v = <span class="built_in">get_S</span>() * h ; <span class="keyword">return</span> v ; }</span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="type">int</span> h, v;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ A objA ;</span><br><span class="line">B objB ;</span><br><span class="line">C objC ;</span><br><span class="line">objA.<span class="built_in">get_XY</span>() ;</span><br><span class="line">objA.<span class="built_in">put_XY</span>() ;</span><br><span class="line">objB.<span class="built_in">get_XY</span>() ;</span><br><span class="line">cout &lt;&lt; <span class="string">"S = "</span> &lt;&lt; objB.<span class="built_in">get_S</span>() &lt;&lt; endl ;</span><br><span class="line">objC.<span class="built_in">get_XY</span>() ;</span><br><span class="line">objC.<span class="built_in">get_H</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"V = "</span> &lt;&lt; objC.<span class="built_in">get_V</span>() &lt;&lt; endl ;}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/a87a6f027be2e1b66c1c2497d61e59f3.png" alt="a87a6f027be2e1b66c1c2497d61e59f3"></p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/4d2fe503e36e73613dfe44ad25b9ed9e.png" alt="4d2fe503e36e73613dfe44ad25b9ed9e"></p>
<p><strong>三种继承方式的对比</strong></p>
<p>一般采用不会改变基类成员访问权限的<strong>公有继承</strong>。</p>
<p><strong>私有继承：</strong></p>
<p>基类的可被继承的成员都成了其直接派生类的私有成员，</p>
<p>无法再进一步派生，</p>
<p>实际上私有继承相当于终止了基类成员的继续派生。</p>
<p><strong>保护继承</strong>：</p>
<p>基类的可被继承的成员都成了直接派生类的保护成员，</p>
<p>保护继承保证了最上层基类的成员依然能被继承树中的</p>
<p>次级子类所继承。</p>
<p><strong>访问级别不能升只能降,一层一层来看即可</strong></p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/42f4358cb52c4ca97743131bb9022ee9.png" alt="42f4358cb52c4ca97743131bb9022ee9"></p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a><strong>派生类的构造函数</strong></h2><p><strong>派生类的构造与析构函数</strong></p>
<p>• <strong>创建派生类对象时调用基类的构造函数来初始化基类数据。</strong></p>
<p>• <strong>执行派生类的析构函数时，基类的析构函数也将被调用。</strong></p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/dcef7a843dbe532605e80a1b95c20b54.png" alt="dcef7a843dbe532605e80a1b95c20b54"></p>
<p><strong>派生类构造函数的定义方式：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">派生类名（参数总表）：基类名（基类构造函数参数表<span class="number">1</span>）, 对象成员(参数表<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">派生类成员初始化；</span><br><span class="line">}</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> no, <span class="type">char</span> name[],<span class="type">char</span> sex):<span class="built_in">Person</span>(name,sex)</span><br><span class="line">{ id = no; }</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> no, <span class="type">char</span> name[],<span class="type">char</span> sex):</span><br><span class="line"><span class="built_in">Person</span>(name,sex), <span class="built_in">id</span>( no ){ }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> { <span class="keyword">public</span>: <span class="built_in">Base1</span>() { cout &lt;&lt; <span class="string">"Base1"</span> &lt;&lt; endl; } };</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> { <span class="keyword">public</span>: <span class="built_in">Base2</span>() { cout &lt;&lt; <span class="string">"Base2"</span> &lt;&lt; endl; } };</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 {  <span class="comment">// 基类声明顺序：Base2 → Base1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base1</span>(), <span class="built_in">Base2</span>() {  <span class="comment">// 初始化列表顺序：Base1 → Base2（与声明顺序相反）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-初始化顺序的决定因素"><a href="#1-初始化顺序的决定因素" class="headerlink" title="1. 初始化顺序的决定因素"></a>1. <strong>初始化顺序的决定因素</strong></h3><ul>
<li><strong>基类</strong>：按照<strong>派生类定义时基类的声明顺序</strong>初始化（无论初始化列表中如何排列）。</li>
<li><strong>成员变量</strong>：按照成员在类中<strong>声明的顺序</strong>初始化（<strong>与初始化列表顺序无关</strong>）。</li>
<li><strong>派生类自身</strong>：<strong>最后执行派生类构造函数</strong>的<strong>函数体</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> { <span class="keyword">public</span>: <span class="built_in">Base1</span>() { cout &lt;&lt; <span class="string">"Base1"</span> &lt;&lt; endl; } };</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> { <span class="keyword">public</span>: <span class="built_in">Base2</span>() { cout &lt;&lt; <span class="string">"Base2"</span> &lt;&lt; endl; } };</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 {  <span class="comment">// 基类声明顺序：Base2 → Base1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base1</span>(), <span class="built_in">Base2</span>() {  <span class="comment">// 初始化列表顺序：Base1 → Base2（与声明顺序相反）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2</span><br><span class="line">Base1</span><br><span class="line">Derived</span><br></pre></td></tr></tbody></table></figure>

<h4 id="为什么初始化顺序固定？"><a href="#为什么初始化顺序固定？" class="headerlink" title="为什么初始化顺序固定？"></a><strong>为什么初始化顺序固定？</strong></h4><ul>
<li><strong>成员变量依赖</strong>：若成员变量的初始化依赖于其他成员的顺序，固定顺序可避免潜在错误。</li>
<li><strong>基类依赖</strong>：若基类的初始化顺序被用户随意调整，可能导致基类未完全初始化就被使用。</li>
</ul>
<h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h5><ul>
<li><strong>保持初始化列表顺序与声明顺序一致</strong>：提高代码可读性，避免混淆。</li>
<li><strong>避免成员间的初始化依赖</strong>：若必须依赖，通过构造函数体或成员函数处理。</li>
</ul>
<p>**构造函数执行顺序：**基类-&gt;派生类中对象成员-&gt;派生类</p>
<h4 id="派生类构造函数的几点说明"><a href="#派生类构造函数的几点说明" class="headerlink" title="派生类构造函数的几点说明"></a>派生类构造函数的几点说明</h4><p>1）派生类构造函数的定义中可<strong>省略对基类构造函数的调用</strong>其条件是<strong>在基类中必须有默认的构造函数或者根本没有定义构造函数。</strong><br>2）当基类的构造函数使用<strong>一个或多个参数</strong>时，则<strong>派生类必须定义构造函数</strong>，提供<strong>将参数传递</strong>给基类构造函数途径。</p>
<h4 id="继承中的同名成员访问"><a href="#继承中的同名成员访问" class="headerlink" title="继承中的同名成员访问"></a><strong>继承中的同名成员访问</strong></h4><p>多重继承时不同基类成员同名也可以用**类名限定符“::”**来解决。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span>: <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">cout&lt;&lt;id&lt;&lt;endl; <span class="comment">//error!访问是二义的</span></span><br><span class="line">cout&lt;&lt;Student::id&lt;&lt;endl; <span class="comment">//访问Student的id</span></span><br><span class="line">cout&lt;&lt;Teacher::id&lt;&lt;endl; <span class="comment">//访问Teacher的id</span></span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>继承时的同名成员隐藏规则</strong><br>派生类定义了与基类相同的成员，此时<strong>基类的同名成员在派生类内不可见</strong>，派生类成员隐藏了同名的基类成员.</p>
<p>基类成员与派生类成员同名，可以通过类名限定符“::”来解决。其语法为：<strong>类名</strong> <strong>: :</strong> <strong>成员</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person{ <span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">private</span>: <span class="type">int</span> id; <span class="comment">// 学号</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>{ <span class="comment">//测试函数</span></span><br><span class="line">id=<span class="number">123</span>; <span class="comment">// 访问派生类成员</span></span><br><span class="line">Person::id =<span class="number">456</span>; <span class="comment">// 访问基类成员</span></span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>继承中成员同名有两种情况：<br>1.<strong>基类</strong>成员与<strong>派生类</strong>成员同名<br>2.多重继承时<strong>不同基类</strong>成员同名</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{ <span class="keyword">protected</span>: <span class="type">int</span> id; }; <span class="comment">// 身份号码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">{ <span class="keyword">protected</span>: <span class="type">int</span> id; }; <span class="comment">// 学号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person</span><br><span class="line">{ <span class="keyword">protected</span>: <span class="type">int</span> id;}; <span class="comment">// 职工号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span>: <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher{</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>{ <span class="comment">// 测试</span></span><br><span class="line">Student::id = <span class="number">1001</span>; <span class="comment">// 正确：访问Student类的id</span></span><br><span class="line">Teacher::id = <span class="number">101</span>; <span class="comment">// 正确：访问Teacher类的id</span></span><br><span class="line">Person::id =<span class="number">230</span>×××<span class="number">0001</span>; <span class="comment">// 错误}</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/1e35cab60282a49190c05943c754245c.png" alt="1e35cab60282a49190c05943c754245c"></p>
<h3 id="类族中的赋值兼容"><a href="#类族中的赋值兼容" class="headerlink" title="类族中的赋值兼容"></a>类族中的<strong>赋值兼容</strong></h3><p><strong>公有继承</strong>时，一个<strong>派生类的对象</strong>可用于<strong>基类对象</strong>适用的地方，需要基类对象的任何地方都可以使用派生类对象<strong>替代</strong>。</p>
<p>赋值兼容规则有三种情况：<br>（1）派生类的对象可以<strong>赋值给基类的对象</strong>。<br>base <em>Obj = derived</em> Obj;<br>（2）派生类的对象可以<strong>初始化基类的引用</strong>。<br>base&amp; base_Obj = derived_obj;<br>（3）派生类的对象的<strong>地址可以赋给指向基类的指针</strong>。<br>base *pBase = &amp;derived_obj;</p>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/8b80309614a6abf7fa39b9b15d0abf52.png" alt="8b80309614a6abf7fa39b9b15d0abf52"></p>
<h2 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>指<strong>同样的消息</strong>被<strong>不同类型的对象接收</strong>时,产生不同行为的<strong>现象</strong>。(<strong>同一名字，多种语义</strong>；<strong>同个接口，多种方法</strong>)</p>
<h4 id="静态多态的概念"><a href="#静态多态的概念" class="headerlink" title="静态多态的概念"></a><strong>静态多态的概念</strong></h4><p>在程序<strong>编译时</strong>系统就能够<strong>确定要调用的是哪个函数</strong>，也被称为<strong>编译时多态</strong>。</p>
<ul>
<li><p>函数重载</p>
</li>
<li><p>运算符重载</p>
</li>
</ul>
<h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><p><strong>不能仅靠函数的返回值</strong>来区别重载函数，必须从<strong>形式参数上</strong>区别开来。</p>
<p><strong>派生类中的同名成员函数</strong></p>
<p>• <strong>使用</strong> <strong>::</strong> <strong>加以区分</strong></p>
<p>• <strong>使用对象加以区分</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MonkyKong sun; </span><br><span class="line">sun. <span class="built_in">fly</span> ( )；</span><br><span class="line">sun . Follower :: <span class="built_in">fly</span> ( );</span><br><span class="line">Pig pigsy;</span><br><span class="line">pigsy.<span class="built_in">fly</span>();</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">A::<span class="built_in">Show</span> ( )</span><br><span class="line"><span class="built_in">Show</span> ( )</span><br><span class="line">Aobj . <span class="built_in">Show</span> ( )；</span><br><span class="line">Bobj . <span class="built_in">Show</span> ( );</span><br><span class="line">Bobj . A :: <span class="built_in">Show</span> ( );</span><br></pre></td></tr></tbody></table></figure>

<h4 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a><strong>动态多态性</strong></h4><p>指程序在编译时并不能确定要调用的函数，<strong>直到运行时</strong>系统才能动态地确定操作所针对的具体对象，它又被称为<strong>运行时多态</strong></p>
<p>动态多态是通过<strong>虚函数</strong>（virtual function）实现。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ cout &lt;&lt; <span class="string">"Base"</span>&lt;&lt;endl ; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv1</span>: <span class="keyword">public</span> Base</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{ cout &lt;&lt; <span class="string">"Derv1"</span>&lt;&lt;endl ; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv2</span>: <span class="keyword">public</span> Base</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{ cout &lt;&lt; <span class="string">"Derv2"</span>&lt;&lt;endl ; }</span><br><span class="line">};</span><br><span class="line">Derv1 dv1; </span><br><span class="line">Derv2 dv2; </span><br><span class="line">dv<span class="number">1.</span><span class="built_in">show</span>() ;</span><br><span class="line">dv<span class="number">2.</span><span class="built_in">show</span>() ;</span><br><span class="line">Base* pBase; </span><br><span class="line">pBase = &amp;dv1;</span><br><span class="line">pBase-&gt;<span class="built_in">show</span>();</span><br><span class="line">pBase = <span class="keyword">new</span> <span class="built_in">Derv2</span>(); </span><br><span class="line">pBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//通过基类指针只能访问从基类继承的成员</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>C++中的虚函数的作用是<strong>允许在派生类中重新定义与基类同名的函数</strong>，并且可以<strong>通过基类指针或者基类引用来访问这个同名函数(最重要区别)</strong>。虚函数成员声明的语法为：</p>
<p>1．virtual只能使用<strong>在类定义</strong>的函数<strong>原型声明</strong>中，</p>
<p>不能在成员函数实现的时候使用，也<strong>不能用来限定类外</strong>的普通函数。</p>
<p>2．用virtual声明类的<strong>非静态</strong>的成员函数，<strong>只用于类的继承层次结构</strong>中。</p>
<p>不能将类外的普通函数(友员)和静态成员函数声明成虚函数。</p>
<p>virtual具有<strong>继承性</strong></p>
<p>在派生类中<strong>重新定义虚函数</strong>，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数<strong>完全相同</strong>。<br>否则不能实现多态性, 为<strong>函数重载</strong>.</p>
<p>虚函数是在基类中冠以关键字 virtual 的非静态成员函数。<br>继承体系：判断成员函数所在的类是否会作为基类；虚函数为类族提供了一种公共接口。<br>重写函数：该函数在类被继承后有无可能被更改功能；允许在派生类中对基类的虚函数重新定义<br>调用形式：是否通过基类指针或引用调用该虚函数；赋值兼容性原则</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Follower</span> <span class="comment">// 徒弟类</span></span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fight</span><span class="params">( Ghost&amp;)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuKong</span></span><br><span class="line">: <span class="keyword">public</span> Follower</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fight</span><span class="params">( Ghost* )</span></span>; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p><strong>构造函数不能是虚函数</strong></p>
<p>建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数</p>
<p><strong>析构函数可以是虚函数</strong></p>
<p>虚析构函数用于<strong>指引 delete 运算符正确析构动态对象</strong></p>
<p>当<strong>基类的析构函数为虚函数</strong>时，无论指针指的是<strong>同一类族的哪一个类对象</strong>，对象撤销时，系统会采用动态关联，调用<strong>相应的析构函数</strong>，完成该对象的清理工作。</p>
<p>习惯把析构函数声明为虚函数，即使基类并不需要析构函数，以<strong>确保撤销动态存储空间时能够得到正确的处理</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>( ){ cout &lt;&lt; <span class="string">"Base"</span> &lt;&lt; endl; }</span><br><span class="line">~<span class="built_in">Base</span>( ){ cout &lt;&lt; <span class="string">"Desconstruct Base"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv1</span>: <span class="keyword">public</span> Base</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv1</span>( ){ cout &lt;&lt; <span class="string">"Derv1"</span> &lt;&lt; endl; }</span><br><span class="line">~<span class="built_in">Derv1</span>( ){ cout &lt;&lt; <span class="string">"Desconstruct Derv1"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv2</span>: <span class="keyword">public</span> Derv1</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv2</span>( ){ cout &lt;&lt; <span class="string">"Derv2"</span> &lt;&lt; endl; }</span><br><span class="line">~<span class="built_in">Derv2</span>( ){ cout &lt;&lt; <span class="string">"Desconstruct Derv2"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line">Base* pBase = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"><span class="keyword">delete</span> pBase;</span><br><span class="line">Derv1* pDerv1 = <span class="keyword">new</span> <span class="built_in">Derv1</span>();</span><br><span class="line"><span class="keyword">delete</span> pDerv1;</span><br><span class="line">pBase = <span class="keyword">new</span> <span class="built_in">Derv2</span>();</span><br><span class="line"><span class="keyword">delete</span> pBase;<span class="comment">//析构由基类指针建立的派生类对象,没有调用派生类析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>( ){ cout &lt;&lt; <span class="string">"Base"</span> &lt;&lt; endl; }</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>( ){ cout &lt;&lt; <span class="string">"Desconstruct Base"</span> &lt;&lt; endl; }<span class="comment">//后面默认都虚,基类指针也可做到连删</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv1</span>: <span class="keyword">public</span> Base</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv1</span>( ){ cout &lt;&lt; <span class="string">"Derv1"</span> &lt;&lt; endl; }</span><br><span class="line">~<span class="built_in">Derv1</span>( ){ cout &lt;&lt; <span class="string">"Desconstruct Derv1"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv2</span>: <span class="keyword">public</span> Derv1</span><br><span class="line">{ <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv2</span>( ){ cout &lt;&lt; <span class="string">"Derv2"</span> &lt;&lt; endl; }</span><br><span class="line">~<span class="built_in">Derv2</span>( ){ cout &lt;&lt; <span class="string">"Desconstruct Derv2"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现动态多态</strong></p>
<p>• 基类<strong>声明</strong>虚函数</p>
<p>• 派生类重写虚函数</p>
<p>• 基类指针或引用调用</p>
<p>在许多情况下，在基类中<strong>不能给出有意义的虚函数定义</strong>，这时可把它说明成纯虚函数，把它的<strong>定义留给派生类来做</strong>。<br>定义纯虚函数的一般形式为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名{</span><br><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名(参数表) = <span class="number">0</span>；</span><br><span class="line">}；</span><br></pre></td></tr></tbody></table></figure>

<p>①纯虚函数<strong>没有函数体</strong>；<br>②最后面的“=0” 不表示函数返回值为0<br>③这是一个<strong>声明语句</strong>。</p>
<p>纯虚函数的作用<br>在基类中<strong>为其派生类保留一个函数的名字</strong>，<strong>以便派生类根据需要对它进行定义</strong>, 否则无法实现多态性。</p>
<h2 id="抽象类的概念"><a href="#抽象类的概念" class="headerlink" title="抽象类的概念"></a><strong>抽象类的概念</strong></h2><p>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类被成为<strong>抽象类</strong>（abstract class**）**。</p>
<p>抽象类必须用作派生其他类的基类,不能作为返回或参数类型，可使用指向抽象类的指针<strong>支持运行时多态性</strong>。而<strong>不能用于直接创建对象实例</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;<span class="built_in">getArea</span>(); (*p).<span class="built_in">draw</span>( );<span class="comment">//作指针做对象时的不同写法以区分</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>派</strong>生类中应<strong>重写</strong>基类中的纯虚函数，否则派生类<strong>仍将被看作</strong>一个<strong>抽象类</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test1(TwoDimensionalShape &amp; t){</span><br><span class="line">t.show( ); t.draw( ); cout&lt;&lt;t.getArea()&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">void test2(TwoDimensionalShape * p){</span><br><span class="line">p-&gt;show( ); p-&gt;draw( ); </span><br><span class="line">cout&lt;&lt; (*p).getArea()&lt;&lt;endl; //???</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果二维图形又派生出了椭圆形，用于测试的test函数需要需改吗？这有何意义？</p>
<ol>
<li><strong>test 函数是否需要修改？</strong><br> <strong>不需要修改</strong>。<br> 若<code>椭圆形（Ellipse）</code>是<code>TwoDimensionalShape</code>的派生类，且正确重写了基类中的<code>show()</code>、<code>draw()</code>、<code>getArea()</code>虚函数（假设这三个函数在<code>TwoDimensionalShape</code>中是<strong>虚函数</strong>），则<code>test1</code>和<code>test2</code>函数可以<strong>直接接收<code>Ellipse</code>对象（或指针 / 引用）<strong>并</strong>正确调用派生类</strong>的实现。</li>
<li><strong>意义：</strong><br> 这体现了<strong>面向对象的多态性</strong>，具体意义如下：<ul>
<li><strong>代码复用性</strong>：新增派生类（如椭圆形）时，无需修改已有的<code>test1</code>、<code>test2</code>等通用函数，只需<strong>保证派生类遵循基类的接口规范（重写虚函数）</strong>，即可直接使用这些函数进行测试。</li>
<li><strong>扩展性</strong>：系统可以轻松扩展新的二维图形类型（如椭圆形、三角形等），而不影响原有代码的逻辑，符合 “开闭原则”（对扩展开放，对修改关闭）。</li>
<li><strong>接口统一性</strong>：通过基类的引用或指针调用派生类的方法，屏蔽了不同派生类的实现差异，使代码更简洁、通用，降低了模块间的耦合度。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoDimensionalShape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">// 纯虚函数：显示图形信息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">// 纯虚函数：绘制图形</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数：计算面积</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TwoDimensionalShape</span>() {} <span class="comment">// 虚析构函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已有的派生类：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> TwoDimensionalShape {</span><br><span class="line">    <span class="comment">// 实现show()、draw()、getArea()...</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增派生类：椭圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span> : <span class="keyword">public</span> TwoDimensionalShape {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="comment">/* 实现 */</span> }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="comment">/* 实现 */</span> }</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="comment">/* 计算椭圆面积 */</span> }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Ellipse e;</span><br><span class="line">    <span class="built_in">test1</span>(e);       <span class="comment">// 传入Ellipse对象的引用，正确调用Ellipse的成员函数</span></span><br><span class="line">    <span class="built_in">test2</span>(&amp;e);      <span class="comment">// 传入Ellipse对象的指针，正确调用Ellipse的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>override</code>是一个<strong>关键字</strong>，用于显式声明派生类中的成员函数<strong>重写（覆盖）</strong> 了基类中的虚函数（<code>virtual</code>函数）。它的主要作用是<strong>增强代码的可读性和安全性</strong>。</p>
<p><strong>(3)</strong> <strong>在类的层次结构中，顶层或最上面的几层可以是抽象基类。</strong></p>
<p>抽象基类体现了<strong>本类族中各类的共性</strong>，把各类中共有的成员函数集中在抽象基类中<strong>声明</strong>。</p>
<p>为什么引⼊多态<br>利⽤多态性可以设计和实现⼀个易于扩展的系统。增强代码的通⽤性</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>重载（Overload）</strong></th>
<th><strong>多态（Polymorphism）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td><strong>同一作用域</strong>内，多个函数名相同但<strong>参数列表（参数类型、个数、顺序）不同</strong>的函数。</td>
<td><strong>基类与派生类中</strong>，派生类<strong>重写（<code>override</code>）基类的虚函数</strong>，通过<strong>基类指针 / 引用调用</strong>时，**根据对象实际类型执行(多种对象对应执行)**对应函数。</td>
</tr>
<tr>
<td><strong>实现阶段</strong></td>
<td><strong>编译时确定（静态多态）</strong>。编译器根据函数参数列表匹配对应的函数。</td>
<td><strong>运行时确定（动态多态）</strong>。程序运行时根据对象实际类型调用对应的函数。</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td><strong>同一类中（或全局函数）</strong>，函数名相同但参数<strong>不同(不完全等同于重写,属于新建,仅名字相同)</strong>。</td>
<td><strong>继承关系中，基类与派生类之间，函数名、参数列表、返回值完全相同（相同信息重写虚函数带来的不同处理响应）。</strong></td>
</tr>
<tr>
<td><strong>核心依赖</strong></td>
<td>函数<strong>参数列表的差异</strong>（与返回值无关）。</td>
<td><strong>基类虚函数、派生类重写、基类指针 / 引用能指向相应派生类对象并执行相应的函数。</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="二、联系"><a href="#二、联系" class="headerlink" title="二、联系"></a><strong>二、联系</strong></h3><ol>
<li><strong>都是代码复用的手段</strong><ul>
<li>重载允许<strong>同一功能（函数名）适配不同参数</strong>，避免为相似功能起不同名字（如<code>printInt</code>、<code>printDouble</code>）。</li>
<li>多态允许通过<strong>统一接口（基类函数）操作不同派生类对象</strong>，简化代码逻辑（如<strong>用<code>Shape*</code>统一管理圆形、方形</strong>等）。</li>
</ul>
</li>
<li><strong>都体现 “一个接口，多种实现” 的思想</strong><ul>
<li>重载：同一函数名对应<strong>多种参数组合</strong>的实现。</li>
<li>多态：同一虚函数接口（基类）对应派生类的<strong>多种重写实现</strong>。</li>
</ul>
</li>
<li><strong>都依赖编译器的处理</strong><ul>
<li>重载依赖编译器在编译时<strong>根据参数匹配函数（静态绑定）</strong>。</li>
<li>多态依赖编译器对<strong>虚函数表的处理</strong>，实现<strong>运行时动态绑定</strong>。</li>
</ul>
</li>
</ol>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h3><ul>
<li><strong>重载</strong>是 “横向” 的函数扩展（同一类内，同名不同参），解决同一功能的不同参数适配问题，属于<strong>静态多态</strong>。</li>
<li><strong>多态</strong>是 “纵向” 的函数扩展（继承体系中，重写虚函数），解决不同派生类对象的统一接口调用问题，属于<strong>动态多态</strong>。</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h2><p><strong>模板</strong>可以实现<strong>类型参数化(包括新类型)</strong>,C++模板包括 函数模板和类模板两种类型**。**</p>
<p><strong>函数模板</strong>就解决函数<strong>重载中</strong>多次定义函数的问题。</p>
<p><strong>类模板</strong>就是对一批<strong>仅仅成员数据类型不同</strong>的类的<strong>抽象</strong>。</p>
<p><strong>泛型编程（generic programming）</strong><br>模板用于<strong>表达逻辑结构相同</strong>，但<strong>具体数据元素类型不同</strong>的数据对象的通用行为。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span> <span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>{ <span class="keyword">return</span> x*x ; }</span><br><span class="line"><span class="function">Complex <span class="title">square</span> <span class="params">(Complex x )</span></span></span><br><span class="line"><span class="function"></span>{ <span class="keyword">return</span> x*x ; }</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="function">T <span class="title">square</span> <span class="params">(T x )</span></span></span><br><span class="line"><span class="function"></span>{ <span class="keyword">return</span> x*x; }</span><br></pre></td></tr></tbody></table></figure>

<p>通过模板可以产生类或函数的<strong>集合</strong>，使它们操作不同的数据类型，避免需要为每种数据类型产生一个单独的类或函数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> 类型参数名<span class="number">1</span> ,<span class="keyword">class</span> 类型参数 <span class="number">2</span>，…&gt;</span><br><span class="line">函数返回值类型 函数名(形式参数表)</span><br><span class="line">{ 函数体 }</span><br></pre></td></tr></tbody></table></figure>

<p>关键字class也可以使用<strong>关键字typename</strong>；</p>
<p>在template语句与函数模板定义语句&lt;返回类型&gt;之间<strong>不允许有别的语句</strong></p>
<p>函数模板允许使用多个类型参数，但在template定义部分的<strong>每个形参</strong>前必须有<strong>关键字typename或class</strong>，</p>
<p>函数形式参数表中可以使用模板类型参数，也可以使用一般类型参数.</p>
<p>模板参数说明的每个类型参数必须在函数定义形参表中至<strong>少出现一次</strong>；</p>
<p>类模板主要用于<strong>数据存储（容器）类</strong>。<strong>表示和算法</strong>不受所包含的元素类型的影响。</p>
<p>一个类模板在类层次结构中<br>既可以是基类也可以是派生类：<br>Ø 类模板可以从模板类派生<br>Ø 类模板可以从非模板类派生<br>Ø 模板类可以从类模板派生<br>Ø 非模板类可以从类模板派生</p>
<h1 id="EasyX-基础"><a href="#EasyX-基础" class="headerlink" title="EasyX 基础"></a>EasyX 基础</h1><ol>
<li>在项目中创建一个.cpp源文件（右键源文件 -&gt; 添加 -&gt; 新建项 -&gt; 设置文件名 first.cpp）</li>
</ol>
<p><img src="/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/image-20250707160940619.png" alt="image-20250707160940619"></p>
<h2 id="EasyX-基本概念"><a href="#EasyX-基本概念" class="headerlink" title="EasyX 基本概念"></a>EasyX 基本概念</h2><h3 id="绘图窗口与设备"><a href="#绘图窗口与设备" class="headerlink" title="绘图窗口与设备"></a>绘图窗口与设备</h3><p>initgraph 函数用于<strong>初始化绘图窗口</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">initgraph</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> flag = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>示例1：创建禁用最小化和关闭按钮的绘图窗口</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(800, 600, EX_NOMINIMIZE | EX_NOCLOSE);</span><br></pre></td></tr></tbody></table></figure>

<p>示例2：窗口开启 EX_SHOWCONSOLE 模式，可以进行代码调试</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(800, 600, EX_SHOWCONSOLE);			// 带控制台的图形窗口</span><br></pre></td></tr></tbody></table></figure>

<p>在 EasyX 中，<strong>设备</strong>分两种，一种是默认的<strong>绘图窗口</strong>，另一种是 <strong>IMAGE 对象</strong>。</p>
<p>通过 SetWorkingImage 函数可以设置当前用于绘图的设备。设置当前用于绘图的设备后，所有的绘图函数都会绘制在该设备上。</p>
<h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>在 EasyX 中，坐标分两种：<strong>物理坐标和逻辑坐标</strong>。</p>
<ul>
<li><strong>物理坐标</strong></li>
</ul>
<p>物理坐标是描述设备的坐标体系。</p>
<p><strong>坐标原点在设备的左上角，X 轴向右为正，Y 轴向下为正(特点)，度量单位是像素（Pixel）。</strong></p>
<p>坐标原点、坐标轴方向、缩放比例都不能改变。</p>
<ul>
<li><strong>逻辑坐标</strong></li>
</ul>
<p>逻辑坐标是在程序中<strong>用于绘图的</strong>坐标体系。</p>
<p><strong>坐标默认的原点在窗口的左上角，X 轴向右为正，Y 轴向下为正，度量单位是点。</strong></p>
<p>默认情况下，逻辑坐标<strong>与物理坐标是一一对应</strong>的，<strong>一个逻辑点等于一个物理像素</strong>。</p>
<p><strong>在 EasyX 中，凡是没有特殊注明的坐标，均指逻辑坐标。</strong></p>
<p><strong>坐标相关函数</strong></p>
<table>
<thead>
<tr>
<th>函数用法</th>
<th>函数说明</th>
</tr>
</thead>
<tbody><tr>
<td>void <strong>setorigin</strong> ( int x, int y )</td>
<td>用于设置坐标原点。</td>
</tr>
<tr>
<td>void <strong>setaspectratio</strong> ( float xasp, float yasp )</td>
<td>通过设置 x 和 y 方向上的<strong>缩放因子</strong>，从而<strong>修改绘图的缩放比例或坐标轴方向</strong>。</td>
</tr>
</tbody></table>
<p>范例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	initgraph(600, 600);</span><br><span class="line">	setorigin(300, 300);		// 将绘图窗口的中心点作为坐标原点 </span><br><span class="line">	circle(0, 0, 100);</span><br><span class="line">	setorigin(0, 0);			// 将绘图窗口的左上角作为坐标原点</span><br><span class="line">	setaspectratio(2, 1);		// x轴方向的缩放因子为2，y轴方向的缩放因子为1(默认值)</span><br><span class="line">	circle(100, 100, 100);</span><br><span class="line">	setorigin(0, 600);			// 将绘图窗口的左下角作为坐标原点</span><br><span class="line">	setaspectratio(1, -1);		// 缩放因子为负数，可以实现坐标轴的翻转，此行可使y轴向上为正</span><br><span class="line">	circle(100, 100, 100);</span><br><span class="line">	system("pause");</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>EasyX 使用 24bit 真彩色，有四种表示颜色的方法：<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/color%EF%BC%8C%E9%80%9A%E8%BF%87">https://docs.easyx.cn/zh-cn/color，通过</a> <strong>setlinecolor</strong> 函数可以设置线条颜色</p>
<ol>
<li><p>用<strong>预定义常量</strong>表示颜色（ 常量名要大写 ）</p>
</li>
<li><p>用<strong>16进制数字表示颜色（ 0xBBGGRR ）</strong>，注意<strong>颜色的顺序与RGB宏相反</strong></p>
</li>
<li><p>用 <strong>RGB 宏合成颜色（ RGB(RRGGBB) ）</strong></p>
</li>
<li><p>用 HSLtoRGB、HSVtoRGB 转换其他色彩模型到 RGB 颜色</p>
</li>
</ol>
<p>范例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	initgraph(800, 600);</span><br><span class="line">	setfillcolor(BLUE);						// 用预定义常量表示颜色</span><br><span class="line">	solidcircle(100, 200, 100);</span><br><span class="line">	setfillcolor(0xaa0000);					// 用16进制数字表示颜色</span><br><span class="line">	solidcircle(300, 200, 100);</span><br><span class="line">	setfillcolor(RGB(0, 0, 170));			// 用RGB宏合成颜色</span><br><span class="line">	solidcircle(500, 200, 100);</span><br><span class="line">	setfillcolor(HSLtoRGB(240, 1, 0.33));	// 用 HSLtoRGB、HSVtoRGB 转换其他色彩模型到 RGB 颜色</span><br><span class="line">	solidcircle(700, 200, 100);</span><br><span class="line">	system("pause");</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="EasyX-图形绘制函数（33个）"><a href="#EasyX-图形绘制函数（33个）" class="headerlink" title="EasyX 图形绘制函数（33个）"></a>EasyX 图形绘制函数（33个）</h2><p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/drawing-func">https://docs.easyx.cn/zh-cn/drawing-func</a>	</p>
<table>
<thead>
<tr>
<th align="left">函数用法</th>
<th>函数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void <strong>circle</strong> ( int x, int y, int radius )</td>
<td>画无填充的圆</td>
</tr>
<tr>
<td align="left">fillcircle</td>
<td>画有边框的填充圆</td>
</tr>
<tr>
<td align="left">solidcircle</td>
<td>画无边框的填充圆</td>
</tr>
<tr>
<td align="left">clearcircle</td>
<td>用当前背景色清空圆形区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>ellipse</strong> ( int left, int top, int right, int bottom )</td>
<td>画无填充的椭圆</td>
</tr>
<tr>
<td align="left">fillellipse</td>
<td>画有边框的填充椭圆</td>
</tr>
<tr>
<td align="left">solidellipse</td>
<td>画无边框的填充椭圆</td>
</tr>
<tr>
<td align="left">clearellipse</td>
<td>用当前背景色清空椭圆区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>pie</strong> ( int left, int top, int right, int bottom, double stangle, double endangle );</td>
<td>画无填充的扇形</td>
</tr>
<tr>
<td align="left">fillpie</td>
<td>画有边框的填充扇形</td>
</tr>
<tr>
<td align="left">solidpie</td>
<td>画无边框的填充扇形</td>
</tr>
<tr>
<td align="left">clearpie</td>
<td>用当前背景色清空扇形区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>rectangle</strong> ( int left, int top, int right, int bottom )</td>
<td>画无填充的矩形</td>
</tr>
<tr>
<td align="left">fillrectangle</td>
<td>画有边框的填充矩形</td>
</tr>
<tr>
<td align="left">solidrectangle</td>
<td>画无边框的填充矩形</td>
</tr>
<tr>
<td align="left">clearrectangle</td>
<td>用当前背景色清空矩形区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>roundrect</strong> ( int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight )</td>
<td>画无填充的圆角矩形</td>
</tr>
<tr>
<td align="left">fillroundrect</td>
<td>画有边框的填充圆角矩形</td>
</tr>
<tr>
<td align="left">solidroundrect</td>
<td>画无边框的填充圆角矩形</td>
</tr>
<tr>
<td align="left">clearroundrect</td>
<td>用当前背景色清空圆角矩形区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>polygon</strong> ( const POINT *points, int num );</td>
<td>画无填充的多边形</td>
</tr>
<tr>
<td align="left">fillpolygon</td>
<td>画有边框的填充多边形</td>
</tr>
<tr>
<td align="left">solidpolygon</td>
<td>画无边框的填充多边形</td>
</tr>
<tr>
<td align="left">clearpolygon</td>
<td>用当前背景色清空多边形区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>putpixel</strong> ( int x, int y, COLORREF color )</td>
<td>画点</td>
</tr>
<tr>
<td align="left">void <strong>line</strong> ( int x1, int y1, int x2, int y2 )</td>
<td>画直线</td>
</tr>
<tr>
<td align="left">void <strong>arc</strong> ( int left, int top, int right, int bottom, double stangle, double endangle )</td>
<td>画椭圆弧</td>
</tr>
<tr>
<td align="left">void <strong>polyline</strong> ( const POINT *points, int num )</td>
<td>画多条连续的直线</td>
</tr>
<tr>
<td align="left">void <strong>polybezier</strong> ( const POINT *points, int num )</td>
<td>画三次方贝塞尔曲线</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">void <strong>floodfill</strong> ( int x, int y, COLORREF color, int filltype = FLOODFILLBORDER )</td>
<td>填充区域</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">COLORREF <strong>getpixel</strong> ( int x, int y )</td>
<td>获取坐标点的颜色</td>
</tr>
<tr>
<td align="left">int <strong>getwidth</strong> ( )</td>
<td>获取绘图区的宽度</td>
</tr>
<tr>
<td align="left">int <strong>getheight</strong> ( )</td>
<td>获取绘图区的高度</td>
</tr>
</tbody></table>
<h2 id="双缓冲绘图"><a href="#双缓冲绘图" class="headerlink" title="双缓冲绘图"></a>双缓冲绘图</h2><p>双缓冲绘图通过在内存中创建一个与屏幕绘图区域<strong>一致的对象</strong>，先将图形绘制到<strong>内存中的这个对象上</strong>，再<strong>一次性将这个对象上的图形拷贝</strong>到屏幕上，从而<strong>减少对屏幕的直接绘图操作</strong>，<strong>提高绘图效率、消除屏幕闪烁</strong>，广泛应用于游戏开发、图形界面等领域。</p>
<table>
<thead>
<tr>
<th>函数用法</th>
<th>函数说明</th>
</tr>
</thead>
<tbody><tr>
<td>void <strong>BeginBatchDraw</strong> ()</td>
<td>开始批量绘图</td>
</tr>
<tr>
<td>void <strong>EndBatchDraw</strong> ()<br>void <strong>EndBatchDraw</strong> ( int left, int top, int right, int bottom )    // 指定区域</td>
<td>结束批量绘制，并执行（指定区域内）未完成的绘制任务</td>
</tr>
<tr>
<td>void <strong>FlushBatchDraw</strong> ()<br>void <strong>FlushBatchDraw</strong> ( int left, int top, int right, int bottom )    // 指定区域</td>
<td>执行（指定区域内）未完成的绘制任务</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/other-func">https://docs.easyx.cn/zh-cn/other-func</a></p>
<p><strong>自动移动的圆（帧数控制）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//include &lt;windows.h&gt;</span><br><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	initgraph(640, 480);</span><br><span class="line">	BeginBatchDraw();</span><br><span class="line"></span><br><span class="line">	setlinecolor(WHITE);</span><br><span class="line">	setfillcolor(RED);</span><br><span class="line">	for (int i = 50; i &lt; 600; i++)</span><br><span class="line">	{</span><br><span class="line">		DWORD beginTime = GetTickCount();			// 记录循环开始时间</span><br><span class="line"></span><br><span class="line">		cleardevice();</span><br><span class="line">		circle(i, 100, 40);</span><br><span class="line">		floodfill(i, 100, WHITE);</span><br><span class="line">		FlushBatchDraw();</span><br><span class="line"></span><br><span class="line">		DWORD endTime = GetTickCount();				// 记录循环结束时间</span><br><span class="line">		DWORD elapsedTime = endTime - beginTime;	// 计算循环耗时</span><br><span class="line">		if (elapsedTime &lt; 1000 / 60)				// 按每秒60帧进行补时</span><br><span class="line">			Sleep(1000 / 60 - elapsedTime);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	EndBatchDraw();</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>GetTickCount</strong> 是一个 Windows 系统函数，用于<strong>获取从操作系统启动以来所经过的毫秒数</strong>，通过在代码中的不同位置调用该函数，并计算两次调用之间的差值，可以得知某段代码或某个操作的执行时间。</p>
<p>注：GetTickCount 的值会在系统启动后约49.7天（(2^32-1) ms）后回绕到0，这是因为其返回值是一个32位无符号整数，<strong>可以使用 GetTickCount64 代替，需添加 windows.h 头文件。</strong></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="EasyX-进阶"><a href="#EasyX-进阶" class="headerlink" title="EasyX 进阶"></a>EasyX 进阶</h1><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/image-func">https://docs.easyx.cn/zh-cn/image-func</a></p>
<table>
<thead>
<tr>
<th>函数用法</th>
<th>函数说明</th>
</tr>
</thead>
<tbody><tr>
<td>void <strong>loadimage</strong> (<br>	IMAGE* pDstImg,	// 保存图像的 IMAGE 对象指针<br>	LPCTSTR pImgFile,   // 图片文件名<br>	int nWidth = 0,          // 图片的拉伸宽度<br>	int nHeight = 0,		 // 图片的拉伸高度<br>	bool bResize = false //是否调整IMAGE的大小以适应图片<br>)</td>
<td>从文件中读取图像。如果pDstImg为NULL，则读取到绘图窗口</td>
</tr>
<tr>
<td>void <strong>putimage</strong> (<br>    int dstX,				    // 绘制位置的 x 坐标<br>    int dstY,				    // 绘制位置的 y 坐标<br>    IMAGE *pSrcImg,	// 要绘制的 IMAGE 对象指针<br>    DWORD dwRop = SRCCOPY	// 三元光栅操作码<br>);</td>
<td>在当前设备上绘制指定图像</td>
</tr>
<tr>
<td>void <strong>putimage</strong> (<br>    int dstX,				    // 绘制位置的 x 坐标<br>    int dstY,				    // 绘制位置的 y 坐标<br>    int dstWidth,			// 绘制的宽度 <br>    int dstHeight,		   // 绘制的高度<br>    IMAGE *pSrcImg,	// 要绘制的 IMAGE 对象指针<br>    int srcX,  // 绘制内容在 IMAGE 对象中的左上角 x 坐标<br>    int srcY,  // 绘制内容在 IMAGE 对象中的左上角 y 坐标 <br>    DWORD dwRop = SRCCOPY	// 三元光栅操作码<br>)</td>
<td>在当前设备上绘制指定图像（指定宽高和起始位置）</td>
</tr>
<tr>
<td>void <strong>Resize</strong> ( IMAGE* pImg, int width, int height )</td>
<td>调整指定绘图设备的尺寸，pImg 如果为 NULL 表示默认绘图窗口</td>
</tr>
<tr>
<td>void <strong>rotateimage</strong> (<br>	IMAGE *dstimg,<br>	IMAGE *srcimg,<br>	double radian,<br>	COLORREF bkcolor = BLACK,<br>	bool autosize = false,<br>	bool highquality = true<br>)</td>
<td>旋转 IMAGE 中的绘图内容</td>
</tr>
<tr>
<td>void <strong>saveimage</strong> (<br>	LPCTSTR strFileName,<br>	IMAGE* pImg = NULL<br>)</td>
<td>保存绘图内容至图片文件，支持 bmp / gif / jpg / png / tif 格式</td>
</tr>
<tr>
<td>void <strong>SetWorkingImage</strong> ( IMAGE* pImg = NULL )</td>
<td>设定当前的绘图设备，如果参数为 NULL，表示绘图设备为默认绘图窗口</td>
</tr>
<tr>
<td>IMAGE* **GetWorkingImage **()</td>
<td>获取当前的绘图设备，如果返回值为 NULL，表示当前绘图设备为绘图窗口</td>
</tr>
<tr>
<td>void <strong>getimage</strong> (<br>	IMAGE* pDstImg,   // 保存图像的 IMAGE 对象指针<br>	int srcX,			   // 要获取图像区域左上角 x 坐标<br>	int srcY,		       // 要获取图像区域的左上角 y 坐标<br>	int srcWidth,	  // 要获取图像区域的宽度<br>	int srcHeight	 // 要获取图像区域的高度<br>)</td>
<td>从当前绘图设备中获取图像</td>
</tr>
<tr>
<td>DWORD* <strong>GetImageBuffer</strong> ( IMAGE* pImg = NULL )</td>
<td>获取绘图设备的显示缓冲区指针，pImg 如果为 NULL，表示默认的绘图窗口</td>
</tr>
<tr>
<td>HDC <strong>GetImageHDC</strong> ( IMAGE* pImg = NULL )</td>
<td>获取绘图设备句柄(HDC)</td>
</tr>
</tbody></table>
<h3 id="IMAGE-类"><a href="#IMAGE-类" class="headerlink" title="IMAGE 类"></a><strong>IMAGE 类</strong></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">IMAGE</span><span class="params">(<span class="type">int</span> width = <span class="number">0</span>, <span class="type">int</span> height = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">公有成员</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getwidth</span><span class="params">()</span></span>;</span><br><span class="line">返回 IMAGE 对象的宽度，以像素为单位。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">()</span></span>;</span><br><span class="line">返回 IMAGE 对象的高度，以像素为单位。</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> =</span><br><span class="line">实现IMAGE对象的直接赋值。该操作仅拷贝源图像的内容，不拷贝源图像的绘图环境。</span><br></pre></td></tr></tbody></table></figure>

<p>在内存中保存图像信息。</p>
<h3 id="loadimage-函数"><a href="#loadimage-函数" class="headerlink" title="loadimage 函数"></a>loadimage 函数</h3><p>范例1：loadimage <strong>直接读取图片至绘图窗口</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1400</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">loadimage</span>(<span class="literal">NULL</span>, _T(<span class="string">"image\\background.jpg"</span>));	<span class="comment">// 第一个参数为NULL时，直接读取图片至绘图窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：修改窗口大小，可以显示图片部分内容，但<strong>只能从绘图窗口的坐标原点（左上角）开始显示</strong>图片</p>
<p>范例2：loadimage 直接读取图片至绘图窗口并进行图片或窗口缩放</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">700</span>, <span class="number">300</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">loadimage</span>(<span class="literal">NULL</span>, _T(<span class="string">"image\\background.jpg"</span>), <span class="number">700</span>, <span class="number">300</span>, <span class="literal">false</span>);	<span class="comment">// 将图像缩放为700*300在绘图窗口显示</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注1：图片缩放后的尺寸<strong>小于</strong>窗口尺寸，则窗口会有<strong>黑边</strong>；若<strong>大于</strong>窗口尺寸，则图片<strong>显示不全</strong></p>
<p>注2：<strong>第五个参数若为 true，则会调整窗口以适应图片的大小</strong></p>
<p>注3：从磁盘中<strong>读取大量图片显示</strong>的情况下，使用 loadimage 直接读取图片至绘图窗口<strong>性能较差</strong></p>
<p>范例3：loadimage 读取本地图片文件，输出图片宽度和高度</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	initgraph(1000, 600, SHOWCONSOLE);		// 初始化绘图窗口并开启终端</span><br><span class="line"></span><br><span class="line">	IMAGE img;								// 定义图像对象</span><br><span class="line">	loadimage(&amp;img, _T("image\\background.jpg"));							// 读取本地图片文件，存入图像对象</span><br><span class="line">	printf("width=%d, height=%d \n", img.getwidth(), img.getheight());		// 输出图像宽度和高度</span><br><span class="line"></span><br><span class="line">	system("pause");</span><br><span class="line">	closegraph();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：本例中的图片内容<strong>不会在窗口内显示</strong></p>
<h3 id="putimage-函数"><a href="#putimage-函数" class="headerlink" title="putimage 函数"></a>putimage 函数</h3><p>范例1：putimage <strong>在绘图窗口显示图像</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">"image\\background.jpg"</span>));</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);			<span class="comment">// 将IMAGE对象显示在绘图窗口的坐标（0,0）处</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>范例2：putimage 截取图像部分内容进行显示</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">900</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">"image\\background.jpg"</span>));</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">900</span>, <span class="number">600</span>, &amp;img, <span class="number">115</span>, <span class="number">0</span>);			<span class="comment">// 从图像的(115,0)坐标处截取宽900、高600的部分内容显示在窗口(0,0)处</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>范例3：putimage 三元光栅操作码</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">"image\\background.jpg"</span>));</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img, NOTSRCCOPY);			<span class="comment">// 第四个参数是三元光栅操作码</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：putimage 第四个参数是 <strong>三元光栅操作码</strong> ，它定义了<strong>源图像与目标图像的位合并形式</strong>，默认值为 <strong>SRCCOPY</strong> 详见</p>
<p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/putimage">https://docs.easyx.cn/zh-cn/putimage</a></p>
<h4 id="透明贴图"><a href="#透明贴图" class="headerlink" title="透明贴图"></a>透明贴图</h4><p>范例1：通过PS制作<strong>原图</strong>的<strong>掩码图</strong>和<strong>前景图</strong>，再进行三元光栅操作叠加而成</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	IMAGE imgGuoqi, imgGuohui, imgGuohuiMask, imgGuohuiFg;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgGuoqi, _T(<span class="string">"image\\guoqi.jpg"</span>), <span class="number">1000</span>, <span class="number">600</span>);			<span class="comment">// 加载国旗（背景图）</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgGuohui, _T(<span class="string">"image\\guohui.jpg"</span>), <span class="number">200</span>, <span class="number">200</span>);			<span class="comment">// 加载国徽原图（白色周边）</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgGuohuiMask, _T(<span class="string">"image\\guohui_mask.jpg"</span>), <span class="number">200</span>, <span class="number">200</span>);	<span class="comment">// 加载国徽掩码图（白色周边+黑色内容）</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgGuohuiFg, _T(<span class="string">"image\\guohui_fg.jpg"</span>), <span class="number">200</span>, <span class="number">200</span>);		<span class="comment">// 加载国徽前景图（黑色周边+待显示内容）</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuoqi);							<span class="comment">// 显示国旗</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuohui);							<span class="comment">// 显示国徽原图</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">200</span>, &amp;imgGuohuiMask);					<span class="comment">// 显示国徽掩码图</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">400</span>, &amp;imgGuohuiFg);						<span class="comment">// 显示国徽前景图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 透明贴图</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">200</span>, <span class="number">0</span>, &amp;imgGuohuiMask, SRCAND);			<span class="comment">// 显示掩码图（SRCAND：按位与）</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">200</span>, <span class="number">0</span>, &amp;imgGuohuiFg, SRCPAINT);			<span class="comment">// 显示前景图（SRCPAINT：按位或）</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>范例2：TransparentBlt 函数实现</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"MSIMG32.LIB"</span>)						<span class="comment">// 链接器在链接过程中包含指定的库文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(IMAGE* dstImg, <span class="type">int</span> x, <span class="type">int</span> y, IMAGE* srcImg, UINT transparentColor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	HDC dstDC = <span class="built_in">GetImageHDC</span>(dstImg);</span><br><span class="line">	HDC srcDC = <span class="built_in">GetImageHDC</span>(srcImg);</span><br><span class="line">	<span class="type">int</span> w = srcImg-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line">	<span class="type">int</span> h = srcImg-&gt;<span class="built_in">getheight</span>();</span><br><span class="line">	<span class="built_in">TransparentBlt</span>(dstDC, x, y, w, h, srcDC, <span class="number">0</span>, <span class="number">0</span>, w, h, transparentColor);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line">	IMAGE imgGuoqi, imgBaidu;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgGuoqi, _T(<span class="string">"image\\guoqi.jpg"</span>), <span class="number">1000</span>, <span class="number">600</span>);		<span class="comment">// 加载国旗（背景图）</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgBaidu, _T(<span class="string">"image\\baidu.png"</span>));					<span class="comment">// 加载百度LOGO（PNG格式）</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuoqi);										<span class="comment">// 显示国旗</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBaidu);										<span class="comment">// 显示百度LOGO</span></span><br><span class="line">	<span class="built_in">putimage_alpha</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">300</span>, &amp;imgBaidu, BLACK);					<span class="comment">// 显示百度LOGO（透明贴图）</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>TransparentBlt 是 Windows GDI（Graphics Device Interface）中的一个函数，用于在绘制位图时支持透明效果。</p>
<p>函数说明：第1个参数为目标设备，第2、3个参数是输出目标矩形左上角坐标，第4、5个参数是目标矩形的宽和高，参数6-10与1-5类似，第11个参数是<strong>透明底色</strong>（若图片是透明图片，默认为BLACK）</p>
<p><strong>注：此方法只支持 PNG 格式的图片</strong></p>
<p>范例3：AlphaBlend 函数实现（<strong>推荐</strong>）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"MSIMG32.LIB"</span>)						<span class="comment">// 链接器在链接过程中包含指定的库文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line">	<span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line">	<span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h, <span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, { AC_SRC_OVER, <span class="number">0</span>, <span class="number">255</span>, AC_SRC_ALPHA });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	IMAGE imgGuoqi, imgBaidu;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgGuoqi, _T(<span class="string">"image\\guoqi.jpg"</span>), <span class="number">1000</span>, <span class="number">600</span>);		<span class="comment">// 加载国旗（背景图）</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgBaidu, _T(<span class="string">"image\\baidu.png"</span>));					<span class="comment">// 加载百度LOGO（PNG格式）</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuoqi);										<span class="comment">// 显示国旗</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBaidu);										<span class="comment">// 显示百度LOGO</span></span><br><span class="line">	<span class="built_in">putimage_alpha</span>(<span class="number">0</span>, <span class="number">300</span>, &amp;imgBaidu);								<span class="comment">// 显示百度LOGO（透明贴图）</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>AlphaBlend 是 Windows GDI 中用于实现 <strong>Alpha 混合（透明/半透明）</strong> 绘制的函数，比 TransparentBlt 更强大，支持 <strong>逐像素透明度（Alpha 通道）</strong> 和 <strong>整体透明度（全局 Alpha）</strong>。</p>
<p><strong>注：此方法只支持 PNG 格式的图片</strong></p>
<h4 id="图片动画"><a href="#图片动画" class="headerlink" title="图片动画"></a>图片动画</h4><p>图片动画的核心是<strong>一系列静态的图像（动画帧）</strong>。每一帧都是一张静态的图片，但它们之间略有不同，通常表现为物体的位置、形状或颜色的微小变化。这些帧按照特定的顺序排列，并以一定的速度连续播放，使得观者感受到运动的效果。</p>
<p>范例：角色动画</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"MSIMG32.LIB"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_WIDTH = <span class="number">1000</span>;			<span class="comment">//窗口宽度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_HEIGHT = <span class="number">600</span>;			<span class="comment">//窗口高度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRAME = <span class="number">60</span>;					<span class="comment">//帧数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INTERVAL_MS = <span class="number">15</span>;				<span class="comment">//动画帧间隔</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> IMAGE_NUM = <span class="number">13</span>;				<span class="comment">//动画图片数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示透明图片</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line">	<span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line">	<span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h, <span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, { AC_SRC_OVER, <span class="number">0</span>, <span class="number">255</span>, AC_SRC_ALPHA });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">bool</span> running = <span class="literal">true</span>;			<span class="comment">//主循环控制</span></span><br><span class="line">	ExMessage msg;					<span class="comment">//键鼠消息</span></span><br><span class="line">	IMAGE imgBackground;			<span class="comment">//背景图片对象</span></span><br><span class="line">	IMAGE imgPEA[<span class="number">13</span>];				<span class="comment">//玩家动画图片</span></span><br><span class="line">	TCHAR imgPath[<span class="number">256</span>];				<span class="comment">//动画图片文件路径</span></span><br><span class="line">	<span class="type">int</span> imgIndex = <span class="number">0</span>;				<span class="comment">//动画帧索引</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> timer = <span class="number">0</span>;			<span class="comment">//动画计时器</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;imgBackground, _T(<span class="string">"image\\background.jpg"</span>));		<span class="comment">//加载背景图片</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IMAGE_NUM; i++)							<span class="comment">//加载动画图片</span></span><br><span class="line">	{</span><br><span class="line">		_stprintf_s(imgPath, _T(<span class="string">"image\\pea\\%d.png"</span>), i + <span class="number">1</span>);	<span class="comment">//动画图片路径（格式转换）</span></span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;imgPEA[i], imgPath);							<span class="comment">//加载动画图片</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">initgraph</span>(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//主循环</span></span><br><span class="line">	<span class="keyword">while</span> (running)</span><br><span class="line">	{</span><br><span class="line">		DWORD beginTime = <span class="built_in">GetTickCount</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//消息处理</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">		{</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//数据处理</span></span><br><span class="line">		timer += <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span> (timer &gt; INTERVAL_MS)					<span class="comment">//定时器超过预定的时间间隔时切换下一张图片</span></span><br><span class="line">		{</span><br><span class="line">			imgIndex = (imgIndex + <span class="number">1</span>) % IMAGE_NUM;			<span class="comment">//循环切换图片：索引值0-12</span></span><br><span class="line">			timer = <span class="number">0</span>;										<span class="comment">//重置计时器</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//绘图</span></span><br><span class="line">		<span class="built_in">cleardevice</span>();</span><br><span class="line">		<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBackground);						<span class="comment">//绘制背景图片</span></span><br><span class="line">		<span class="built_in">putimage_alpha</span>(<span class="number">500</span>, <span class="number">300</span>, &amp;imgPEA[imgIndex]);		<span class="comment">//绘制豌豆图片</span></span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//帧延时处理</span></span><br><span class="line">		DWORD endTime = <span class="built_in">GetTickCount</span>();</span><br><span class="line">		DWORD elapsedTime = endTime - beginTime;</span><br><span class="line">		<span class="keyword">if</span> (elapsedTime &lt; <span class="number">1000</span> / FRAME)</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">1000</span> / FRAME - elapsedTime);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="Resize-函数"><a href="#Resize-函数" class="headerlink" title="Resize 函数"></a>Resize 函数</h3><h3 id="GetImageBuffer-函数"><a href="#GetImageBuffer-函数" class="headerlink" title="GetImageBuffer 函数"></a>GetImageBuffer 函数</h3><p>范例1：GetImageBuffer 通过<strong>直接操作显示缓冲区绘制渐变的蓝色</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	DWORD* pMem = <span class="built_in">GetImageBuffer</span>();							<span class="comment">// 获取当前窗口所指图像缓冲区的指针	</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">600</span> * <span class="number">400</span>; i++)</span><br><span class="line">		pMem[i] = <span class="built_in">BGR</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">0</span>, i * <span class="number">256</span> / (<span class="number">600</span> * <span class="number">400</span>)));	<span class="comment">// 直接对图像缓冲区每个坐标像素赋值（颜色）</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>范例2：图像翻转</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip_image</span><span class="params">(IMAGE* srcImg, IMAGE* dstImg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> w = srcImg-&gt;<span class="built_in">getwidth</span>();								<span class="comment">// 获取源图像宽度</span></span><br><span class="line">	<span class="type">int</span> h = srcImg-&gt;<span class="built_in">getheight</span>();							<span class="comment">// 获取源图像高度</span></span><br><span class="line">	<span class="built_in">Resize</span>(dstImg, w, h);									<span class="comment">// 设置目标图像与源图像宽高一致</span></span><br><span class="line">	DWORD* src_buffer = <span class="built_in">GetImageBuffer</span>(srcImg);				<span class="comment">// 获取源图像缓冲区指针</span></span><br><span class="line">	DWORD* dst_buffer = <span class="built_in">GetImageBuffer</span>(dstImg);				<span class="comment">// 获取目标图像缓冲区指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">		{</span><br><span class="line">			<span class="type">int</span> idx_src = y * w + x;</span><br><span class="line">			<span class="type">int</span> idx_dst = y * w + (w - x - <span class="number">1</span>);</span><br><span class="line">			dst_buffer[idx_dst] = src_buffer[idx_src];		<span class="comment">// 交换对应坐标像素的颜色值</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1400</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	IMAGE img1, img2;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img1, _T(<span class="string">"image\\background.jpg"</span>));</span><br><span class="line">	<span class="built_in">flip_image</span>(&amp;img1, &amp;img2);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/msg-func">https://docs.easyx.cn/zh-cn/msg-func</a></p>
<p><strong>消息缓冲区</strong>可以<strong>缓冲 63 个未处理的消息</strong>。每次获取消息时，将从消息缓冲区<strong>取出一个最早发生的</strong>消息。</p>
<table>
<thead>
<tr>
<th>函数用法</th>
<th>函数说明</th>
</tr>
</thead>
<tbody><tr>
<td>ExMessage <strong>getmessage</strong> ( BYTE filter = -1 )<br>void <strong>getmessage</strong> ( ExMessage *msg, BYTE filter = -1 )</td>
<td>从消息缓冲区获取一个消息。如果缓冲区中没有消息，则程序会一直等待（阻塞式）</td>
</tr>
<tr>
<td>bool <strong>peekmessage</strong> ( ExMessage *msg, BYTE filter = -1, bool removemsg = true)</td>
<td>从消息缓冲区获取一个消息，并立即返回</td>
</tr>
<tr>
<td>void <strong>flushmessage</strong> ( BYTE filter = -1 )</td>
<td>清空消息缓冲区</td>
</tr>
</tbody></table>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>msg</strong>：指向消息结构体 ExMessage 的指针，用来保存获取到的消息。</li>
<li><strong>filter</strong>：指定要获取的消息范围，默认 -1 获取所有类别的消息。可以用以下值或值的组合获取指定类别的消息</li>
</ul>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EX_MOUSE</td>
<td><strong>鼠标</strong>消息。</td>
</tr>
<tr>
<td>EX_KEY</td>
<td><strong>按键</strong>消息。</td>
</tr>
<tr>
<td>EX_CHAR</td>
<td>字符消息。</td>
</tr>
<tr>
<td>EX_WINDOW</td>
<td><strong>窗口</strong>消息。</td>
</tr>
</tbody></table>
<ul>
<li><strong>removemsg</strong>：在 peekmessage 处理完消息后，<strong>是否将其从消息队列中移除。</strong></li>
</ul>
<h3 id="ExMessage-结构体"><a href="#ExMessage-结构体" class="headerlink" title="ExMessage 结构体"></a><strong>ExMessage 结构体</strong></h3><p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/exmessage">https://docs.easyx.cn/zh-cn/exmessage</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct ExMessage</span><br><span class="line">{</span><br><span class="line">	USHORT message;					// 消息标识</span><br><span class="line">	union</span><br><span class="line">	{</span><br><span class="line">		// 鼠标消息的数据</span><br><span class="line">		struct</span><br><span class="line">		{</span><br><span class="line">			bool ctrl		:1;		// Ctrl 键是否按下</span><br><span class="line">			bool shift		:1;		// Shift 键是否按下</span><br><span class="line">			bool lbutton	:1;		// 鼠标左键是否按下</span><br><span class="line">			bool mbutton	:1;		// 鼠标中键是否按下</span><br><span class="line">			bool rbutton	:1;		// 鼠标右键</span><br><span class="line">			short x;				// 鼠标的 x 坐标</span><br><span class="line">			short y;				// 鼠标的 y 坐标</span><br><span class="line">			short wheel;			// 鼠标滚轮滚动值，为 120 的倍数</span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		// 按键消息的数据</span><br><span class="line">		struct</span><br><span class="line">		{</span><br><span class="line">			BYTE vkcode;			// 按键的虚拟键码</span><br><span class="line">			BYTE scancode;			// 按键的扫描码（依赖于 OEM）</span><br><span class="line">			bool extended	:1;		// 按键是否是扩展键</span><br><span class="line">			bool prevdown	:1;		// 按键的前一个状态是否按下</span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		// 字符消息的数据</span><br><span class="line">		TCHAR ch;</span><br><span class="line"></span><br><span class="line">		// 窗口消息的数据</span><br><span class="line">		struct</span><br><span class="line">		{</span><br><span class="line">			WPARAM wParam;</span><br><span class="line">			LPARAM lParam;</span><br><span class="line">		};</span><br><span class="line">	};	</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>message</strong> ：可以分为四大类：<strong>EX_MOUSE</strong>（鼠标11项）、<strong>EX_KEY</strong>（键盘2项）、<strong>EX_CHAR</strong>（字符1项）、<strong>EX_WINDOW</strong>（窗口3项）</p>
<p><strong>union</strong> ：共用体中存储具体消息的数据</p>
<h3 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h3><p>范例：跟随鼠标移动的圆</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> posX;</span><br><span class="line">	<span class="type">int</span> posY;</span><br><span class="line">	<span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Ball</span>(<span class="type">int</span> x = <span class="number">100</span>, <span class="type">int</span> y=<span class="number">100</span>, <span class="type">int</span> r=<span class="number">50</span>) : <span class="built_in">posX</span>(x), <span class="built_in">posY</span>(y), <span class="built_in">radius</span>(r) {}		<span class="comment">// 构造方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> posX; }</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> posY; }</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> radius; }</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span> </span>{ posX = x; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span> </span>{ posY = y; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">int</span> r)</span> </span>{ radius = r; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">bool</span> running = <span class="literal">true</span>;				<span class="comment">// 主循环控制参数</span></span><br><span class="line">	ExMessage msg;						<span class="comment">// 消息对象</span></span><br><span class="line">	<span class="function">Ball <span class="title">ball</span><span class="params">(<span class="number">400</span>, <span class="number">300</span>, <span class="number">50</span>)</span></span>;			<span class="comment">// 待绘制对象</span></span><br><span class="line">	<span class="comment">//Ball ball;	</span></span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">800</span>, <span class="number">600</span>);				<span class="comment">// 初始化绘图窗口	</span></span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();					<span class="comment">// 开启批量绘图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主循环</span></span><br><span class="line">	<span class="keyword">while</span> (running) {</span><br><span class="line">		<span class="comment">// 消息处理		</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg)) {</span><br><span class="line">			<span class="keyword">if</span> (msg.message == WM_MOUSEMOVE) {				<span class="comment">// 圆的位置随鼠标位置变化</span></span><br><span class="line">				ball.<span class="built_in">setX</span>(msg.x);</span><br><span class="line">				ball.<span class="built_in">setY</span>(msg.y);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_LBUTTONDOWN) {		<span class="comment">// 左键按下圆变红色</span></span><br><span class="line">				<span class="built_in">setfillcolor</span>(RED);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_LBUTTONUP) {			<span class="comment">// 左键松开圆变白色</span></span><br><span class="line">				<span class="built_in">setfillcolor</span>(WHITE);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_RBUTTONDOWN) {		<span class="comment">// 右键按下结束主循环</span></span><br><span class="line">				running = <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 绘图</span></span><br><span class="line">		<span class="built_in">cleardevice</span>();												<span class="comment">// 清除屏幕</span></span><br><span class="line">		<span class="built_in">solidcircle</span>(ball.<span class="built_in">getX</span>(), ball.<span class="built_in">getY</span>(), ball.<span class="built_in">getRadius</span>());	<span class="comment">// 绘制当前帧内容</span></span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();											<span class="comment">// 刷新批量绘图</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();						<span class="comment">// 关闭批量绘图</span></span><br><span class="line">	<span class="built_in">closegraph</span>();						<span class="comment">// 关闭绘图窗口</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h3><p>范例1：用键盘控制小球</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用结构体封装小球属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Ball</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> x;				<span class="comment">// 小球圆心坐标x</span></span><br><span class="line">	<span class="type">int</span> y;				<span class="comment">// 小球圆心坐标y</span></span><br><span class="line">	<span class="type">int</span> r;				<span class="comment">// 小球半径</span></span><br><span class="line">	<span class="type">int</span> dx;				<span class="comment">// 小球在x轴方向移动的增量</span></span><br><span class="line">	<span class="type">int</span> dy;				<span class="comment">// 小球在y轴方向移动的增量</span></span><br><span class="line">	COLORREF color;		<span class="comment">// 小球颜色</span></span><br><span class="line">} Ball;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">	ExMessage msg;</span><br><span class="line">	Ball ball = { <span class="number">300</span>, <span class="number">300</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, YELLOW };	<span class="comment">// 创建小球并初始化</span></span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (running)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (msg.message == WM_KEYDOWN)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">switch</span> (msg.vkcode)					<span class="comment">// 判断虚拟键代码</span></span><br><span class="line">				{</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'w'</span>:							<span class="comment">// 上键：小球Y坐标减少</span></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_UP:</span><br><span class="line">					ball.y -= ball.dy;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_DOWN:						<span class="comment">// 下键：小球Y坐标增加</span></span><br><span class="line">					ball.y += ball.dy;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_LEFT:						<span class="comment">// 右键：小球X坐标减少</span></span><br><span class="line">					ball.x -= ball.dx;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_RIGHT:						<span class="comment">// 右键：小球X坐标增加</span></span><br><span class="line">					ball.x += ball.dx;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> VK_ESCAPE:						<span class="comment">// ESC键：结束主循环</span></span><br><span class="line">					running = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}			</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cleardevice</span>();							<span class="comment">// 清除屏幕</span></span><br><span class="line">		<span class="built_in">setfillcolor</span>(ball.color);				<span class="comment">// 设置填充颜色</span></span><br><span class="line">		<span class="built_in">solidcircle</span>(ball.x, ball.y, ball.r);	<span class="comment">// 绘制无边框填充圆;</span></span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虚拟键代码 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes</a></p>
<p><strong>优化后</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN_WIDTH 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN_HEIGHT 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用结构体封装小球属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Ball</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> x;						<span class="comment">// 小球圆心坐标x</span></span><br><span class="line">	<span class="type">int</span> y;						<span class="comment">// 小球圆心坐标y</span></span><br><span class="line">	<span class="type">int</span> r;						<span class="comment">// 小球半径</span></span><br><span class="line">	<span class="type">int</span> dx;						<span class="comment">// 小球在x轴方向移动的增量</span></span><br><span class="line">	<span class="type">int</span> dy;						<span class="comment">// 小球在y轴方向移动的增量</span></span><br><span class="line">	COLORREF color;				<span class="comment">// 小球颜色</span></span><br><span class="line">	<span class="type">bool</span> isMoveUp = <span class="literal">false</span>;		<span class="comment">// 小球是否向四个方向移动</span></span><br><span class="line">	<span class="type">bool</span> isMoveDown = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> isMoveLeft = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> isMoveRight = <span class="literal">false</span>;</span><br><span class="line">} Ball;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">	ExMessage msg;</span><br><span class="line">	Ball ball = { <span class="number">300</span>, <span class="number">300</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, YELLOW };		<span class="comment">// 创建小球并初始化</span></span><br><span class="line">	<span class="built_in">initgraph</span>(WIN_WIDTH, WIN_HEIGHT);</span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (running)</span><br><span class="line">	{</span><br><span class="line">		DWORD beginTime = <span class="built_in">GetTickCount</span>();			<span class="comment">// 记录循环开始时间</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 消息处理</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (msg.message == WM_KEYDOWN)			<span class="comment">// 按下按键处理</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">switch</span> (msg.vkcode)</span><br><span class="line">				{</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_UP:</span><br><span class="line">					ball.isMoveUp = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_DOWN:</span><br><span class="line">					ball.isMoveDown = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_LEFT:</span><br><span class="line">					ball.isMoveLeft = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">					ball.isMoveRight = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> VK_ESCAPE:</span><br><span class="line">					running = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (msg.message == WM_KEYUP)			<span class="comment">// 松开按键处理</span></span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">switch</span> (msg.vkcode)</span><br><span class="line">				{</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_UP:</span><br><span class="line">					ball.isMoveUp = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_DOWN:</span><br><span class="line">					ball.isMoveDown = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_LEFT:</span><br><span class="line">					ball.isMoveLeft = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">				<span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">					ball.isMoveRight = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 斜向移动：计算不同方向(包括同时)按下时的速度增量</span></span><br><span class="line">		<span class="type">int</span> directX = ball.isMoveRight - ball.isMoveLeft;</span><br><span class="line">		<span class="type">int</span> directY = ball.isMoveDown - ball.isMoveUp;</span><br><span class="line">		<span class="type">double</span> directXY = <span class="built_in">sqrt</span>(directX * directX + directY * directY);</span><br><span class="line">		<span class="keyword">if</span> (directXY != <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="type">double</span> factorX = directX / directXY;	<span class="comment">//计算X、Y方向的标准化分量</span></span><br><span class="line">			<span class="type">double</span> factorY = directY / directXY;</span><br><span class="line">			ball.x += (<span class="type">int</span>)ball.dx * factorX;		<span class="comment">//小球坐标 = 方向增速 * 方向的标准化分量</span></span><br><span class="line">			ball.y += (<span class="type">int</span>)ball.dy * factorY;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 边缘检测</span></span><br><span class="line">		<span class="keyword">if</span> (ball.y - ball.r &lt;= <span class="number">0</span>)					<span class="comment">// 上</span></span><br><span class="line">			ball.y = ball.r;</span><br><span class="line">		<span class="keyword">if</span> (ball.y + ball.r &gt;= WIN_HEIGHT)			<span class="comment">// 下</span></span><br><span class="line">			ball.y = WIN_HEIGHT - ball.r - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (ball.x - ball.r &lt;= <span class="number">0</span>)					<span class="comment">// 左</span></span><br><span class="line">			ball.x = ball.r;</span><br><span class="line">		<span class="keyword">if</span> (ball.x + ball.r &gt;= WIN_WIDTH)			<span class="comment">// 右</span></span><br><span class="line">			ball.x = WIN_WIDTH - ball.r - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绘图</span></span><br><span class="line">		<span class="built_in">cleardevice</span>();								<span class="comment">// 清除屏幕</span></span><br><span class="line">		<span class="built_in">setfillcolor</span>(ball.color);					<span class="comment">// 设置填充颜色</span></span><br><span class="line">		<span class="built_in">solidcircle</span>(ball.x, ball.y, ball.r);		<span class="comment">// 绘制无边框填充圆;</span></span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 帧延时</span></span><br><span class="line">		DWORD endTime = <span class="built_in">GetTickCount</span>();				<span class="comment">// 记录循环结束时间</span></span><br><span class="line">		DWORD elapsedTime = endTime - beginTime;	<span class="comment">// 计算循环耗时</span></span><br><span class="line">		<span class="keyword">if</span> (elapsedTime &lt; <span class="number">1000</span> / <span class="number">60</span>)				<span class="comment">// 按每秒60帧进行补时</span></span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">60</span> - elapsedTime);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><h3 id="设置窗口标题"><a href="#设置窗口标题" class="headerlink" title="设置窗口标题"></a>设置窗口标题</h3><p>范例：使用 <strong>GetHWnd</strong> 和 <strong>SetWindowText</strong> 函数设置窗口标题</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);		</span><br><span class="line">	</span><br><span class="line">	HWND hWnd = <span class="built_in">GetHWnd</span>();						<span class="comment">// 获得窗口句柄	</span></span><br><span class="line">	<span class="built_in">SetWindowText</span>(hWnd, _T(<span class="string">"植物大战僵尸"</span>));		<span class="comment">// 使用 Windows API 修改窗口名称</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="弹窗消息"><a href="#弹窗消息" class="headerlink" title="弹窗消息"></a>弹窗消息</h3><p>在Visual C++（VC）中，MessageBox 函数是一个常用的 Windows API 函数，用于显示一个模态对话框，其中包含文本、标题、图标和按钮等。以下是函数的详细用法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageBox</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,           <span class="comment">// 父窗口句柄。如果为NULL，则消息框没有父窗口  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpText,         <span class="comment">// 要显示的消息文本  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCaption,      <span class="comment">// 消息框的标题  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT    uType           <span class="comment">// 指定消息框的内容和行为的标志  </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>参数说明</strong></p>
<ol>
<li><strong>hWnd</strong>：指定消息框的父窗口句柄。如果此参数为NULL，则消息框没有父窗口，且作为顶级窗口显示。</li>
<li><strong>lpText</strong>：要在消息框中显示的文本。</li>
<li><strong>lpCaption</strong>：消息框的标题。如果此参数为NULL，则默认标题为“Error”。</li>
<li><strong>uType</strong>：用于指定消息框的内容和行为的标志。这可以是一个或多个以下常量的组合：<ul>
<li>MB_OK：消息框包含一个“确定”按钮。</li>
<li>MB_OKCANCEL：消息框包含“确定”和“取消”按钮。</li>
<li>MB_YESNO：消息框包含“是”和“否”按钮。</li>
<li>MB_YESNOCANCEL：消息框包含“是”、“否”和“取消”按钮。</li>
<li>MB_ICONEXCLAMATION、MB_ICONWARNING、MB_ICONINFORMATION、MB_ICONQUESTION、MB_ICONERROR等：用于指定消息框中显示的图标。</li>
</ul>
</li>
</ol>
<p><strong>返回值</strong></p>
<p>函数返回一个整数值，表示用户点击的按钮。例如：</p>
<ul>
<li><strong>IDOK</strong>：用户点击了“确定”按钮。</li>
<li><strong>IDCANCEL</strong>：用户点击了“取消”按钮。</li>
<li><strong>IDYES</strong>：用户点击了“是”按钮。</li>
<li><strong>IDNO</strong>：用户点击了“否”按钮。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	HWND hWnd = <span class="built_in">GetHWnd</span>();</span><br><span class="line">	<span class="built_in">MessageBox</span>(hWnd, _T(<span class="string">"你被僵尸吃掉了！"</span>), _T(<span class="string">"游戏结束"</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：在使用 MessageBox 函数之前，需要包含 <strong>windows.h</strong> 头文件（<strong>如果已经包含了 graphics.h 头文件则可以省略</strong>）</p>
<h3 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h3><p><strong>mciSendString</strong>  是 Windows API 中的一个函数，用于向媒体控制接口（Media Control Interface，MCI）设备发送命令字符串。这个函数常用于控制多媒体设备，如音频和视频播放，支持 MPEG, AVI, WAV, MP3 等多种格式。</p>
<p>范例：播放背景音乐</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;				// 此项在导入graphics.h头文件后可以省略</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"winmm.lib"</span>)	<span class="comment">// 加载多媒体静态库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mciSendString</span>(_T(<span class="string">"open audio\\bg.mp3 alias BGM"</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);			<span class="comment">// 打开音乐文件，alias指定别名</span></span><br><span class="line">	<span class="built_in">mciSendString</span>(_T(<span class="string">"play BGM repeat"</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);						<span class="comment">// 使用别名播放音乐，repeat重复播放	</span></span><br><span class="line"></span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">"image\\background.jpg"</span>));</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h1><h3 id="练习1：鼠标-键盘绘图"><a href="#练习1：鼠标-键盘绘图" class="headerlink" title="练习1：鼠标+键盘绘图"></a>练习1：鼠标+键盘绘图</h3><p>功能要求：</p>
<ol>
<li><p>鼠标按下左键画 10*10 的正方形、按下右键画半径为 10 的圆（鼠标点击的位置为图形中心）</p>
</li>
<li><p>同时按下 Ctrl 键和鼠标左、右键，分别画 20*20 的正方形和半径为 20 的圆</p>
</li>
<li><p>按下键盘 C 键清屏、R/G/B/W 键分别修改画图颜色为红、绿、蓝、白，ESC 键退出</p>
</li>
</ol>
<h3 id="练习2：弹球"><a href="#练习2：弹球" class="headerlink" title="练习2：弹球"></a>练习2：弹球</h3><p>功能要求：</p>
<ol>
<li>一个自由运动的小球，碰到左、右、上边界会反弹，碰到下边界结束程序</li>
<li>一个键盘控制的挡板，挡板不能超出屏幕范围，小球碰到后会反弹</li>
<li>按P键可以切换画面暂停/继续</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://RXCCCCCC.github.io">RXCCCCCC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://rxcccccc.github.io/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/">http://rxcccccc.github.io/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/image/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">RXCCCCCC</div><div class="author-info-description">哦哦哦哦哦哦耶</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RXCCCCCC"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/RXCCCCCC" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://rxcccccc.github.io/atom.xml" target="_blank" title="Rss"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">孩子搭着玩的一个半成品,总能碰到好多常人碰不到的问题又解决不了,所以就成现在这样了(</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1OPP-Oriented-Procedural-Programming"><span class="toc-number">1.</span> <span class="toc-text">面向过程程序设计OPP(Oriented Procedural Programming)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">1.0.1.</span> <span class="toc-text">功能与数据分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.</span> <span class="toc-text">自顶向下的设计方法</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1. 类的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 私有成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3. 公有成员函数（接口）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">可初始化成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E7%BB%A7%E6%89%BF%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">可调用父类构造函数（继承场景）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BAconst%E3%80%81virtual%E6%88%96static"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">不能被声明为const、virtual或static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88C-11-%EF%BC%89"><span class="toc-number">2.3.0.4.</span> <span class="toc-text">委托构造函数（C++11+）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BB%93%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E6%84%8F%E4%B9%89"><span class="toc-number">2.4.</span> <span class="toc-text">总结：结构的核心意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">代码结构解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.6.</span> <span class="toc-text">1. 常量成员函数的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E8%AF%B4%E6%98%8E"><span class="toc-number">2.7.</span> <span class="toc-text">2. 代码示例与说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">2.8.</span> <span class="toc-text">3. 常量对象与函数调用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.</span> <span class="toc-text">4. 技术原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.10.</span> <span class="toc-text">5. 实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B3%A8%E6%84%8F%E8%A6%81%E7%82%B9"><span class="toc-number">2.11.</span> <span class="toc-text">6. 注意要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.12.</span> <span class="toc-text">继承关系说明：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template"><span class="toc-number">4.</span> <span class="toc-text">template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">5.</span> <span class="toc-text">数据结构与数据访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">C++函数的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">6.0.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.0.2.</span> <span class="toc-text">引用传递的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline-%E4%BB%A5%E7%9B%B8%E5%BA%94%E4%BB%A3%E7%A0%81%E4%BB%A3%E6%9B%BF"><span class="toc-number">6.0.3.</span> <span class="toc-text">内联函数inline(以相应代码代替)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.0.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.5.</span> <span class="toc-text">函数默认参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">初识类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-encapsulate"><span class="toc-number">8.</span> <span class="toc-text">封装(encapsulate)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">8.0.1.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4-protected"><span class="toc-number">8.0.2.</span> <span class="toc-text">保护 protected</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">对象的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.0.1.</span> <span class="toc-text">构造函数与析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">10.</span> <span class="toc-text">类的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%BF%85%E9%A1%BB%E9%A6%96%E5%85%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%B5%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">10.0.1.</span> <span class="toc-text">构造函数: 必须首先初始化内嵌对象的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%86%85%E5%B5%8C%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E5%85%B6%E5%87%BD%E6%95%B0-%E6%B3%A8%E6%84%8F%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%81"><span class="toc-number">10.0.2.</span> <span class="toc-text">成员函数: 可以使用内嵌对象调用其函数. 注意访问权限控制！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.0.3.</span> <span class="toc-text">成员对象的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">10.0.4.</span> <span class="toc-text">组合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">10.0.5.</span> <span class="toc-text">依赖关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">11.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83-%E5%87%BD%E6%95%B0-%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">友元 函数 与友元类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">12.0.1.</span> <span class="toc-text">友元函数和友元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">12.0.2.</span> <span class="toc-text">友元的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="toc-number">12.0.3.</span> <span class="toc-text">友元的主要用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#friend-%E5%A3%B0%E6%98%8E"><span class="toc-number">12.0.4.</span> <span class="toc-text">friend 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#friend-%E7%B1%BB"><span class="toc-number">12.0.5.</span> <span class="toc-text">friend 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-%E4%B8%8D%E5%85%81%E8%AE%B8%E7%BB%A7%E6%89%BF%E5%BE%AA%E7%8E%AF"><span class="toc-number">13.</span> <span class="toc-text">继承(不允许继承循环)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">13.0.1.</span> <span class="toc-text">继承的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">13.0.2.</span> <span class="toc-text">访问私有继承的成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">派生类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%86%B3%E5%AE%9A%E5%9B%A0%E7%B4%A0"><span class="toc-number">14.1.</span> <span class="toc-text">1. 初始化顺序的决定因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%9B%BA%E5%AE%9A%EF%BC%9F"><span class="toc-number">14.1.1.</span> <span class="toc-text">为什么初始化顺序固定？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">14.1.1.1.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">14.1.2.</span> <span class="toc-text">派生类构造函数的几点说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"><span class="toc-number">14.1.3.</span> <span class="toc-text">继承中的同名成员访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%97%8F%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9"><span class="toc-number">14.2.</span> <span class="toc-text">类族中的赋值兼容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-1"><span class="toc-number">15.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">15.0.1.</span> <span class="toc-text">静态多态的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.0.2.</span> <span class="toc-text">函数重载注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">15.0.3.</span> <span class="toc-text">动态多态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">15.0.4.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.0.5.</span> <span class="toc-text">虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">16.</span> <span class="toc-text">抽象类的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">16.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%81%94%E7%B3%BB"><span class="toc-number">16.2.</span> <span class="toc-text">二、联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">16.3.</span> <span class="toc-text">三、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EasyX-%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">EasyX 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EasyX-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">EasyX 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E7%AA%97%E5%8F%A3%E4%B8%8E%E8%AE%BE%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text">绘图窗口与设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%90%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="toc-number">1.3.</span> <span class="toc-text">颜色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EasyX-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0%EF%BC%8833%E4%B8%AA%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">EasyX 图形绘制函数（33个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E7%BB%98%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">双缓冲绘图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EasyX-%E8%BF%9B%E9%98%B6"><span class="toc-number"></span> <span class="toc-text">EasyX 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">图像处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE-%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">IMAGE 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadimage-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">loadimage 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putimage-%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">putimage 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.3.1.</span> <span class="toc-text">透明贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A8%E7%94%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">图片动画</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resize-%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">Resize 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetImageBuffer-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">GetImageBuffer 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">消息处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ExMessage-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">ExMessage 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E6%B6%88%E6%81%AF"><span class="toc-number">2.2.</span> <span class="toc-text">鼠标消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E6%B6%88%E6%81%AF"><span class="toc-number">2.3.</span> <span class="toc-text">键盘消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">其它函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">设置窗口标题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B9%E7%AA%97%E6%B6%88%E6%81%AF"><span class="toc-number">3.2.</span> <span class="toc-text">弹窗消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91"><span class="toc-number">3.3.</span> <span class="toc-text">播放音频</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E5%A0%82%E7%BB%83%E4%B9%A0"><span class="toc-number"></span> <span class="toc-text">随堂练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E9%BC%A0%E6%A0%87-%E9%94%AE%E7%9B%98%E7%BB%98%E5%9B%BE"><span class="toc-number">0.1.</span> <span class="toc-text">练习1：鼠标+键盘绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E5%BC%B9%E7%90%83"><span class="toc-number">0.2.</span> <span class="toc-text">练习2：弹球</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/text/" title="test">test</a><time datetime="2025-07-24T16:36:04.000Z" title="Created 2025-07-25 00:36:04">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/24/%E8%BF%9B%E8%A1%8Cvue%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E5%AD%A6/" title="进行vue的一个一个学">进行vue的一个一个学</a><time datetime="2025-07-24T04:51:39.000Z" title="Created 2025-07-24 12:51:39">2025-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/" title="面向对象（c艹）一个一个记">面向对象（c艹）一个一个记</a><time datetime="2025-07-03T00:35:38.000Z" title="Created 2025-07-03 08:35:38">2025-07-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/%E6%B5%B7%E6%80%9D%E8%B5%9B%E9%81%93%E5%B5%8C%E8%B5%9B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%97%A5%E8%AE%B0/" title="海思赛道嵌赛开发一个一个日记">海思赛道嵌赛开发一个一个日记</a><time datetime="2025-05-29T10:33:33.000Z" title="Created 2025-05-29 18:33:33">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/%E8%BF%9B%E8%A1%8Clinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AF%BB/" title="进行linux命令行大全的一个一个读">进行linux命令行大全的一个一个读</a><time datetime="2025-05-15T02:03:07.000Z" title="Created 2025-05-15 10:03:07">2025-05-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">©2025 By RXCCCCCC</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'RM6CxQZamBGOaLbqapwigHVR-MdYXbMMI',
      appKey: 'W0jx3oFV8keuvguIvlTiy8DQ',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>