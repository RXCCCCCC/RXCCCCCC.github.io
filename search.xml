<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机英语(bushi)</title>
      <link href="/2025/07/25/%E8%AE%A1%E7%A7%91%E7%9B%B8%E5%85%B3%E8%87%AA%E6%84%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%A1%A5%E5%85%85/"/>
      <url>/2025/07/25/%E8%AE%A1%E7%A7%91%E7%9B%B8%E5%85%B3%E8%87%AA%E6%84%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>英语蒟蒻记录一点冲浪时碰到的陌生英语词</p><p>[toc]</p><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><h2 id="dll文件"><a href="#dll文件" class="headerlink" title="dll文件"></a>dll文件</h2><p>.dll文件是<strong>Dynamic Link Library（<a href="https://zhida.zhihu.com/search?content_id=229567508&amp;content_type=Article&amp;match_order=1&amp;q=动态链接库&amp;zhida_source=entity">动态链接库</a>）文件的缩写</strong>，它是一种共享库文件，包含了程序所需的代码和数据。与静态链接库不同，动态链接库可以在<strong>程序运行时动态加载</strong>，使得程序的内存占用更小，同时也方便了程序的更新和维护。</p><h2 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h2><p>鲁棒性是 robustness 的音译，在中文中常常也被表达为健壮性和强壮性，总体来说其可以用于反映<strong>一个系统在面临着内部结构或外部环境的改变时也能够维持其功能稳定运行的能力</strong> 。</p><p>计算机系统：鲁棒性是一个系统或组件在出现不正确的或矛盾的输入时能够正确运行的程度。</p><p>人类语言技术：语言的鲁棒性（识别和分解等）是指人类即使在信息不完全、意思模糊或不断的变化情况下，仍然能够实现沟通的能力。</p><p>实用非线性控制：鲁棒性是一个系统在遇到了设计中所没有考虑过的情况时不受到影响的程度。</p><p>生物系统：鲁棒性是那些具有恢复、自动修复、自控制、自组装、自复制能力的系统所具有的特性。</p><p>面向对象的软件构造：鲁棒性是软件在非正常环境下（也就是在规范外的环境下，包括新的平台、网络超载、内存故障等）做出适当反应的能力。</p><h2 id="句柄（HANDLE）"><a href="#句柄（HANDLE）" class="headerlink" title="句柄（HANDLE）"></a>句柄（HANDLE）</h2><p>句柄是一个<strong>整数</strong>，单独的看它只是数字。</p><p>但这个整数是<strong>进程句柄表数组的下标</strong>，有了这个下标，操作系统就可以找到其索引的数据结构，并能找到数据结构里面的指针，然后根据这个指针获取内核里的某个对象。</p><h1 id="大知识点"><a href="#大知识点" class="headerlink" title="大知识点"></a>大知识点</h1><h2 id="缓冲（buffer）"><a href="#缓冲（buffer）" class="headerlink" title="缓冲（buffer）"></a>缓冲（buffer）</h2><p>缓冲区是<strong>内存空间的一部分</strong>。也就是说，在内存空间中<strong>预留</strong>了一定的存储空间，这些存储空间用来<strong>缓冲输入或输出的数据</strong>，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。</p><h4 id="为什么要引入缓冲区"><a href="#为什么要引入缓冲区" class="headerlink" title="为什么要引入缓冲区"></a>为什么要引入缓冲区</h4><p>比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，<strong>计算机再直接从缓冲区中取数据</strong>，等缓冲区的数据取完后再去磁盘中读取，这样就可以<strong>减少磁盘的读写次数</strong>，再加上计算机对缓冲区的操作<strong>速度大大快于</strong>对磁盘的操作，故应用缓冲区可大大<strong>提高计算机的运行速度。</strong></p><p>又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的<strong>CPU可以处理别的事情</strong>。缓冲区就是一块内存区，它<strong>用在输入输出设备和CPU之间</strong>，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够<strong>协调工作</strong>，避免低速的输入输出设备占用CPU，<strong>解放出CPU，使其能够高效率工作</strong>。</p><h2 id="缓存（cache）"><a href="#缓存（cache）" class="headerlink" title="缓存（cache）"></a>缓存（cache）</h2><p>cache是一个非常大的概念。</p><h3 id="一、CPU的Cache"><a href="#一、CPU的Cache" class="headerlink" title="一、CPU的Cache"></a><strong>一、CPU的Cache</strong></h3><p>CPU的Cache，它中文名称是高速缓冲存储器，读写速度很快，几乎与CPU一样。由于CPU的运算速度太快，<strong>内存的数据存取速度无法跟上CPU的速度</strong>，所以在cpu与内存间设置了cache为cpu的数据快取区。当计算机执行程序时，数据与地址管理部件会<strong>预测</strong>可能要用到的数据和指令，并将这些数据和指令<strong>预先从内存中读出送到Cache</strong>。一旦需要时，<strong>先检查Cache</strong>，若有就从Cache中读取，若无再访问内存，现在的CPU还有一级cache，二级cache。简单来说，Cache就是用来<strong>解决CPU与内存之间速度不匹配的问题</strong>，避免内存与辅助内存频繁存取数据，这样就提高了系统的执行效率。</p><h3 id="二、磁盘的Cache"><a href="#二、磁盘的Cache" class="headerlink" title="二、磁盘的Cache"></a><strong>二、磁盘的Cache</strong></h3><p>磁盘也有cache，硬盘的cache作用就类似于CPU的cache，它解决了总线接口的高速需求和读写硬盘的矛盾以及对某些扇区的反复读取。</p><h3 id="三、浏览器的Cache"><a href="#三、浏览器的Cache" class="headerlink" title="三、浏览器的Cache"></a><strong>三、浏览器的Cache</strong></h3><p><a href="https://so.csdn.net/so/search?q=浏览器缓存&amp;spm=1001.2101.3001.7020">浏览器缓存</a>（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览，并且可以减少服务器的压力。游览器的缓存的数据只是短时间保存，可以人为的清空</p><h4 id="缓存（cache）与缓冲-buffer-的主要区别"><a href="#缓存（cache）与缓冲-buffer-的主要区别" class="headerlink" title="缓存（cache）与缓冲(buffer)的主要区别"></a>缓存（cache）与缓冲(buffer)的主要区别</h4><p>Buffer的核心作用是用来缓冲，缓和冲击（对输出设备的冲击，包括磁盘、打印机、显示器）。比如你每秒要写100次硬盘，对系统冲击很大，<strong>浪费了大量时间</strong>在忙着<strong>处理</strong>开始写和结束写这两件事嘛。用个buffer暂存起来，变成每10秒写一次硬盘，对系统的冲<strong>击就很小</strong>，写入效率高了，日子过得爽了。极大缓和了冲击。</p><p>Cache的核心作用是加快取用的速度（加快读取速度，包括CPU读内存、内存读磁盘、用户通过浏览器请求资源）。比如你一个很复杂的计算做完了，下次还要用结果，就把结果放手边一个<strong>好拿</strong>的地方存着，下次不用再算了。加快了数据取用的速度。</p><p>简单来说就是buffer偏重于写，而cache偏重于读。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON: JavaScript Object Notation JS对象简谱 , 是一种轻量级的数据交换格式.</p><p>2.JSON对象格式<br>我们通过java，js,xml和json这几种不同的语言来描述一个对象<br>对象是book，它有两个属性，分别是name和info</p><p>java格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">class</span> <span class="title class_">Book</span>&#123; </span><br><span class="line">&gt; 　　　<span class="keyword">private</span> String name; </span><br><span class="line">&gt; 　　　<span class="keyword">private</span> String info;</span><br><span class="line">&gt; 　　　get/set... </span><br><span class="line">&gt; 　　　&#125;</span><br><span class="line">&gt;  　　<span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">&gt;   　　b.setName(“金苹果”); </span><br><span class="line">&gt;   　　b.setInfo(“种苹果”); </span><br><span class="line">&gt;      　　...</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">&gt; b.<span class="property">name</span> = <span class="string">&quot;金苹果&quot;</span>; </span><br><span class="line">&gt; b.<span class="property">info</span> = <span class="string">&quot;种苹果&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>金苹果<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">info</span>&gt;</span>种苹果<span class="tag">&lt;/<span class="name">info</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;金苹果&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="string">&quot;种苹果&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>一个对象, 由一个大括号表示.</strong><br>         括号中 描述对象的属性 .<br>         通过<strong>键值对来描述对象的属性</strong> (可以理解为, 大括号中, 包含的是一个个的键值对.)<br>         格式<br>                  键与值之间使用冒号连接, 多个键值对之间使用<strong>逗号分隔.</strong><br>                  键值对的键 应使用<strong>引号引住</strong> (通常Java解析时, 键不使用引号会报错. 而JS能正确解 析.)                   键值对的值, 可以是JS中的<strong>任意类型</strong>的数据</p><p>数组格式</p><blockquote><p>在JSON格式中可以与对象<strong>互相嵌套</strong><br>[元素1,元素2…]</p></blockquote><p><strong>案例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小陈&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;pengyou&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="string">&quot;李四&quot;</span><span class="punctuation">,</span><span class="string">&quot;王二&quot;</span><span class="punctuation">,</span><span class="string">&quot;麻子&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span> </span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小明&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="string">&quot;像彭于晏一样帅气的男人&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;heihei&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;大长刀&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;length&quot;</span><span class="punctuation">:</span><span class="string">&quot;40m&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3.JSON数据解析<br>下面开始讲解如何<strong>使用IDEA将Java对象快速转换成JSON数据</strong>，和如何将JSON数据转换成Java对象</p><p>将Java中的对象 快速的<strong>转换为 JSON格式的字符串.</strong><br>将JSON格式的字符串, 转换为Java的对象.</p><p>注意：</p><p>1.以下的导jar包操作如果不会，请去参考一些导jar包操作<br>2.在文章的底部提供了有关的jar包，需要自取<br><strong>GSON解析</strong></p><ul><li><p>将对象转换为JSON字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">转换JSON字符串的步骤: </span><br><span class="line"><span class="number">1.</span> 引入JAR包 </span><br><span class="line"><span class="number">2.</span> 在需要转换JSON字符串的位置编写如下代码即可: </span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJSON(要转换的对象); </span><br><span class="line">案例:</span><br><span class="line"><span class="comment">//1. 创建Gson类型的对象</span></span><br><span class="line">        <span class="type">Gson</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="comment">//2. 转换</span></span><br><span class="line">        <span class="comment">//优化   可以使用匿名对象</span></span><br><span class="line">        <span class="type">book</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;100&quot;</span>,<span class="string">&quot;金苹果&quot;</span>,<span class="string">&quot;种植苹果的故事&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> g.toJson(b);</span><br><span class="line">        System.out.println(s);</span><br></pre></td></tr></table></figure><p>  将JSON字符串转换为对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 引入JAR包 </span><br><span class="line"><span class="number">2.</span> 在需要转换Java对象的位置, 编写如下代码:</span><br><span class="line"><span class="comment">//1. 创建Gson类型的对象</span></span><br><span class="line">        <span class="type">Gson</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="comment">//2. 转换 &#123;&quot;id&quot;:&quot;100&quot;,&quot;name&quot;:&quot;金苹果&quot;,&quot;info&quot;:&quot;种植苹果的故事&quot;,&quot;page&quot;:[&quot;远赴人间惊鸿晏&quot;,&quot;一度人间盛世颜&quot;,&quot;致hdd&quot;]&#125;</span></span><br><span class="line">        <span class="comment">//2.1  返回book类型</span></span><br><span class="line">        <span class="type">book</span> <span class="variable">b</span> <span class="operator">=</span> g.fromJson(<span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;100\&quot;,\&quot;name\&quot;:\&quot;金苹果\&quot;,\&quot;info\&quot;:\&quot;种植苹果的故事\&quot;&#125;&quot;</span>, book.class);</span><br><span class="line">        System.out.println(b.getId());</span><br><span class="line">        <span class="comment">//2.2 返回MAP类型，键值对形式</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> g.fromJson(<span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;100\&quot;,\&quot;name\&quot;:\&quot;金苹果\&quot;,\&quot;info\&quot;:\&quot;种植苹果的故事\&quot;&#125;&quot;</span>, HashMap.class);</span><br><span class="line">        System.out.println(hm.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="comment">//2.3 MAP类型中值是一个数组形式</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">data</span> <span class="operator">=</span> g.fromJson(<span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;100\&quot;,\&quot;name\&quot;:\&quot;金苹果\&quot;,\&quot;info\&quot;:\&quot;种植苹果的故事\&quot;,\&quot;page\&quot;:[\&quot;远赴人间惊鸿晏\&quot;,\&quot;一度人间盛世颜\&quot;,\&quot;致hdd\&quot;]&#125;&quot;</span>, HashMap.class);</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> (List) data.get(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机英语(bushi)</title>
      <link href="/2025/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD-bushi/"/>
      <url>/2025/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD-bushi/</url>
      
        <content type="html"><![CDATA[<p>[TOC]<br>英语蒟蒻记录一点冲浪时碰到的陌生英语词</p><h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h1 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git系列速查一个一个记</title>
      <link href="/2025/07/25/Git%E7%B3%BB%E5%88%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/"/>
      <url>/2025/07/25/Git%E7%B3%BB%E5%88%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Git 的主要特点：<br>1.<strong>版本控制</strong>：每次提交都像写了⼀篇新⽇记，<strong>保存</strong>你的开发成果。<br>2.<strong>分⽀管理</strong>：分⽀就像章节，可以<strong>并⾏开发⽽互不⼲扰。</strong><br>3.分布式：每个⼈都拥有完整的“时光机⽇记本”，即便<strong>没有⽹络也可以⼯作</strong></p><p>GitHub：你可以把代码上传到 GitHub，随时随地访问，并与他⼈协作开发，甚⾄分享给全世界。</p><p>Gitee：</p><p>Gitee 是 GitHub 的“中国版伙伴”。</p><p> 优势：速度快、对<strong>国内开发者友好</strong>，能与本地⼯具（如钉钉、企业微信）⽆缝集成。 常⽤于<strong>企业内部</strong>项⽬或对<strong>私有化部署有需求</strong>的团队</p><h1 id="Git-常⽤命令及-SSH-配置"><a href="#Git-常⽤命令及-SSH-配置" class="headerlink" title="Git 常⽤命令及 SSH 配置"></a>Git 常⽤命令及 SSH 配置</h1><p>SSH：安全认证和便捷连接 ,允许在本地和远程仓库之间<strong>安全通信</strong>，并省去每次推送或拉取代码时输⼊密码的⿇烦</p><p><img src="/2025/07/25/Git%E7%B3%BB%E5%88%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/cea6e8ca8d4a0c3b8af35814dfcfb48d.png" alt="cea6e8ca8d4a0c3b8af35814dfcfb48d"></p><p><img src="/2025/07/25/Git%E7%B3%BB%E5%88%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/6ae805e806aeacb0b8a9274dcd11ab5c.png" alt="6ae805e806aeacb0b8a9274dcd11ab5c"></p><p><img src="/2025/07/25/Git%E7%B3%BB%E5%88%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/0128b3779daeee91001684f54a5ac973.png" alt="0128b3779daeee91001684f54a5ac973"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象（c艹）一个一个记</title>
      <link href="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/"/>
      <url>/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程程序设计OPP-Oriented-Procedural-Programming"><a href="#面向过程程序设计OPP-Oriented-Procedural-Programming" class="headerlink" title="面向过程程序设计OPP(Oriented Procedural Programming)"></a>面向过程程序设计OPP(Oriented Procedural Programming)</h2><p>将复杂过程简单的按功能分层从而解决问题<br>编程是<strong>面向操作</strong>的，编程的<strong>单位是函数</strong><br>规范的过程化程序: 过程的功能划分 / 编写</p><h4 id="功能与数据分离"><a href="#功能与数据分离" class="headerlink" title="功能与数据分离"></a>功能与数据分离</h4><p>不符合人们对现实世界的认识<br>要保持功能与数据的相容困难</p><h4 id="自顶向下的设计方法"><a href="#自顶向下的设计方法" class="headerlink" title="自顶向下的设计方法"></a>自顶向下的设计方法</h4><p>限制了软件的可重用性，<br>降低开发效率，<br>软件系统难以维护。</p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/4e9f2fabd86809a8bfd9e32c2ea93a51.png" alt="4e9f2fabd86809a8bfd9e32c2ea93a51"></p><p>结合在对象中，按对象组织</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类自动共享父类数据和方法的机制，它由<strong>类的派生</strong>体现。一个子类直接继承父类的全部描述，同时<strong>可修改和扩充</strong>，继承是对父类的<strong>重用</strong>机制。</p><p>E.G</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派生类：圆锥体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cone</span> : <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> height; <span class="comment">// 圆锥高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cone</span>(<span class="type">double</span> X , <span class="type">double</span> Y , <span class="type">double</span> r , <span class="type">double</span> h = <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span> </span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为<code>Cone</code>（圆锥体）的派生类，它继承自<code>Circle</code>（圆形）基类。这种结构体现了面向对象编程中的<strong>继承特性</strong>，下面详细解释其各部分含义：</p><h3 id="1-类的继承关系"><a href="#1-类的继承关系" class="headerlink" title="1. 类的继承关系"></a>1. 类的继承关系</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cone</span> : <span class="keyword">public</span> Circle</span><br></pre></td></tr></table></figure><ul><li><code>class Cone</code>：声明一个名为<code>Cone</code>的类（圆锥体）。</li><li><code>: public Circle</code>：表示<code>Cone</code>是<code>Circle</code>的<strong>公有派生类</strong>（<code>public</code>为<strong>继承方式</strong>）。<br>  这意味着：<code>Cone</code>会继承<code>Circle</code>中<strong>所有的非私有成员</strong>（包括<strong>成员变量和成员函数</strong>），可以直接使用基类的功能，同时扩展自己的特性。<br>  （例如：圆形的圆心坐标<code>X,Y</code>、半径<code>r</code>等属性，圆锥体也需要，因此无需重复定义，直接继承即可。）</li></ul><h3 id="2-私有成员变量"><a href="#2-私有成员变量" class="headerlink" title="2. 私有成员变量"></a>2. 私有成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> height; <span class="comment">// 圆锥高度</span></span><br></pre></td></tr></table></figure><ul><li><code>private</code>：访问权限修饰符，标识该部分成员<strong>仅能在<code>Cone</code>类内部</strong>使用，外部无法直接访问。</li><li><code>double height</code>：定义了圆锥体特有的成员变量<code>height</code>（高度），这是<code>Cone</code>在基类<code>Circle</code>基础上扩展的属性（圆形没有高度，圆锥有）。</li></ul><h3 id="3-公有成员函数（接口）"><a href="#3-公有成员函数（接口）" class="headerlink" title="3. 公有成员函数（接口）"></a>3. 公有成员函数（接口）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cone</span>(<span class="type">double</span> X , <span class="type">double</span> Y , <span class="type">double</span> r , <span class="type">double</span> h = <span class="number">1</span>); <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span></span>; <span class="comment">// 设置高度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 获取高度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 计算表面积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateVolume</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 计算体积</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 打印信息</span></span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><p>这些是<code>Cone</code>类<strong>对外提供的</strong>接口，用于操作和访问类的成员，具体功能如下：</p><ul><li><p><strong>构造函数</strong> <code>Cone(...)</code>(<strong>名称与类名相同</strong>,<strong>无返回类型</strong>,<strong>可重载</strong>,)：<br>  用于初始化圆锥体对象，参数包括：<code>X,Y</code>（圆心 / 顶点坐标，继承自<code>Circle</code>）、<code>r</code>（底面半径，继承自<code>Circle</code>）、<code>h</code>（高度，默认值为 1）。<br>  构造函数会<strong>先调用基类<code>Circle</code>的构造函数初始化继承的属性</strong>（如<code>X,Y,r</code>），<strong>再初始化自己的</strong><code>height</code>。</p><h5 id="可初始化成员变量"><a href="#可初始化成员变量" class="headerlink" title="可初始化成员变量"></a><strong>可初始化成员变量</strong></h5>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125; <span class="comment">// 初始化列表（推荐,最直观显式）</span></span><br><span class="line">    <span class="comment">// 或在函数体中赋值：</span></span><br><span class="line">    <span class="comment">// MyClass(int val) &#123; value = val; &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="可调用父类构造函数（继承场景）"><a href="#可调用父类构造函数（继承场景）" class="headerlink" title="可调用父类构造函数（继承场景）"></a><strong>可调用父类构造函数（继承场景）</strong></h5><ul><li><p>在派生类的构造函数中，<strong>必须显式调用</strong>父类的构造函数（除非父类有<strong>默认</strong>构造函数(如果类中<strong>未定义任何构造函数</strong>，编译器会自动生成一个<strong>隐式默认构造函数</strong>（无参数）。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">Base</span>(x) &#123;&#125; <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="不能被声明为const、virtual或static"><a href="#不能被声明为const、virtual或static" class="headerlink" title="不能被声明为const、virtual或static"></a><strong>不能被声明为<code>const</code>、<code>virtual</code>或<code>static</code></strong></h5></li><li><p>构造函数不能是<code>const</code>（因为它<strong>会修改对象状态</strong>）。</p></li><li>构造函数不能是<code>virtual</code>（虚函数<strong>依赖于对象</strong>的存在，而构造函数<strong>正在创建对象</strong>）。</li><li><p>构造函数不能是<code>static</code>（<strong>静态</strong>函数<strong>属于类</strong>，而<strong>构造</strong>函数<strong>属于对象</strong>）。</p><h5 id="委托构造函数（C-11-）"><a href="#委托构造函数（C-11-）" class="headerlink" title="委托构造函数（C++11+）"></a><strong>委托构造函数（C++11+）</strong></h5></li><li><p>构造函数可以<strong>调用同一个类的其他构造函数</strong>，避免代码重复。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">value</span>(x) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 委托给另一个构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>setter 和 getter 函数</strong>：</p><ul><li><code>setHeight(double h)</code>：设置圆锥的高度（修改<code>height</code>的值）。</li><li><code>getHeight() const</code>：返回圆锥的高度（读取<code>height</code>的值）。<br>  这是封装特性的体现：<strong>通过函数间接访问私有</strong>变量<strong>(在内部)</strong>，<strong>避免外部直接修改</strong>，保证数据安全性。</li></ul></li><li><p><strong>功能计算函数</strong>：</p><ul><li><code>calculateArea() const</code>：计算圆锥的表面积（基类<code>Circle</code>若有计算圆面积的函数，<strong>则此处重写</strong>为圆锥的表面积）。</li><li><code>calculateVolume() const</code>：计算圆锥的体积（圆锥特有的功能，基类<code>Circle</code>没有）。</li></ul></li><li><p><strong>信息打印函数</strong>：</p><ul><li><code>printInfo() const</code>：打印圆锥的所有信息（如圆心坐标、半径、高度、表面积、体积等），通常会结合继承自基类的信息和自身的信息。</li></ul></li></ul><h3 id="总结：结构的核心意义"><a href="#总结：结构的核心意义" class="headerlink" title="总结：结构的核心意义"></a>总结：结构的核心意义</h3><ul><li><strong>继承复用</strong>：<code>Cone</code>通过继承<code>Circle</code>，直接复用了圆形的属性（如圆心、半径），<strong>无需重复定义，减少代码冗余</strong>。</li><li><strong>扩展功能</strong>：在继承的基础上，<code>Cone</code><strong>增加</strong>了自身特有的属性（高度）和方法（体积计算、表面积计算等），实现了 “圆锥是一种特殊的圆形（带高度）” 的逻辑关系。</li><li><strong>封装接口</strong>：通过公有成员函数对外提供访问接口，<strong>隐藏内部实现细节</strong>（如<code>height</code>的存储方式），符合面向对象的封装原则。</li></ul><p>这种结构使得代码更具扩展性和维护性，例如未来若需要修改圆形的属性（如增加颜色），圆锥体也能自动继承该特性。这段代码定义了一个名为<code>Cone</code>的类，它是从<code>Circle</code>类派生而来的，这意味着<code>Cone</code>继承了<code>Circle</code>的属性和方法。这种继承关系形成了面向对象编程中的<strong>父子类结构</strong>。</p><h3 id="代码结构解析："><a href="#代码结构解析：" class="headerlink" title="代码结构解析："></a>代码结构解析：</h3><ol><li><strong>类定义</strong>：<ul><li><code>class Cone : public Circle</code>：<code>Cone</code>类公开继承自<code>Circle</code>类，因此<code>Cone</code>可以访问<code>Circle</code>的公有成员。</li></ul></li><li><strong>私有成员变量</strong>：<ul><li><code>double height;</code>：圆锥的高度，这是<code>Cone</code>类特有的属性。</li></ul></li><li><strong>构造函数</strong>：<ul><li><code>Cone(double X, double Y, double r, double h = 1)</code>：初始化圆锥的位置（继承自<code>Circle</code>的<code>X</code>和<code>Y</code>）、底面半径（继承自<code>Circle</code>的<code>r</code>）和高度<code>h</code>（默认值为 1）。</li></ul></li><li><strong>成员函数</strong>：<ul><li><code>setHeight(double h)</code>：设置圆锥的高度。</li><li><code>getHeight() const</code>：返回圆锥的高度。</li><li><code>calculateArea() const</code>：计算圆锥的表面积（可能包括底面积和侧面积）。</li><li><code>calculateVolume() const</code>：计算圆锥的体积。</li><li><code>printInfo() const</code>：打印圆锥的信息，可能包括位置、半径、高度、表面积和体积。</li></ul></li></ol><p><code>const</code> 关键字放在函数声明的后面，其作用是表明这个函数属于<strong>常量成员函数</strong>。如果写在<strong>前面</strong>则表示的是其<strong>返回值</strong>是常量</p><h3 id="1-常量成员函数的功能"><a href="#1-常量成员函数的功能" class="headerlink" title="1. 常量成员函数的功能"></a>1. 常量成员函数的功能</h3><ul><li><strong>保护对象状态</strong>：常量成员函数不可以对调用它的对象的非静态数据成员进行修改。</li><li><strong>适配常量对象</strong>：<strong>只有</strong>常量成员函数才能够被常量对象调用。</li></ul><h3 id="2-代码示例与说明"><a href="#2-代码示例与说明" class="headerlink" title="2. 代码示例与说明"></a>2. 代码示例与说明</h3><p>下面是一个包含常量成员函数的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量成员函数：不能修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius; <span class="comment">// 允许，因为没有修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量成员函数：计算圆的面积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// radius = 10.0; // 错误！不可以修改成员变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非常量成员函数：可以修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">        radius = r; <span class="comment">// 允许，因为这不是常量成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-常量对象与函数调用规则"><a href="#3-常量对象与函数调用规则" class="headerlink" title="3. 常量对象与函数调用规则"></a>3. 常量对象与函数调用规则</h3><ul><li><strong>常量对象</strong>：<strong>只能调用常量成员</strong>函数。</li><li><strong>非常量对象</strong>：<strong>既能调用常量成员函数，也能调用非常量成员函数</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Circle <span class="title">c1</span><span class="params">(<span class="number">5.0</span>)</span></span>; <span class="comment">// 常量对象,同时进行了初始化</span></span><br><span class="line"><span class="type">double</span> area = c<span class="number">1.</span><span class="built_in">calculateArea</span>(); <span class="comment">// 正确，calculateArea是常量成员函数</span></span><br><span class="line"><span class="comment">// c1.setRadius(10.0); // 错误，常量对象不能调用非常量成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">c2</span><span class="params">(<span class="number">3.0</span>)</span></span>; <span class="comment">// 非常量对象</span></span><br><span class="line">c<span class="number">2.</span><span class="built_in">setRadius</span>(<span class="number">10.0</span>); <span class="comment">// 正确</span></span><br><span class="line">area = c<span class="number">2.</span><span class="built_in">calculateArea</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="4-技术原理"><a href="#4-技术原理" class="headerlink" title="4. 技术原理"></a>4. 技术原理</h3><ul><li><p>隐式<code>this</code>指针的类型</p><p>  ：</p><ul><li>在常量成员函数里，<code>this</code> 指针的类型是 <code>const ClassName*</code>。</li><li>在非常量成员函数中，<code>this</code> 指针的类型是 <code>ClassName*</code>。</li></ul></li></ul><h3 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h3><ul><li><strong>访问器（Getter）函数</strong>：通常会被声明为常量成员函数，比如 <code>getRadius()</code>。</li><li><strong>不修改对象的计算函数</strong>：像 <code>calculateArea()</code> 就属于这类函数。</li><li><strong>操作符重载</strong>：例如 <code>operator==</code> 通常也会被声明为常量成员函数。</li></ul><h3 id="6-注意要点"><a href="#6-注意要点" class="headerlink" title="6. 注意要点"></a>6. 注意要点</h3><ul><li><strong>函数重载</strong>：常量版本和非常量版本的同一函数可以同时存在。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> constData; &#125; <span class="comment">// 常量版本</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125; <span class="comment">// 非常量版本</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* constData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>可变数据成员（mutable）</strong>：被 <code>mutable</code> 修饰的数据成员，能够在常量成员函数中被修改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount; <span class="comment">// 可变数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        accessCount++; <span class="comment">// 允许，因为accessCount是mutable的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承关系说明："><a href="#继承关系说明：" class="headerlink" title="继承关系说明："></a>继承关系说明：</h3><ul><li><strong>父类（基类）</strong>：<code>Circle</code>类（假设包含圆心坐标<code>X</code>、<code>Y</code>和半径<code>r</code>）。</li><li><strong>子类（派生类）</strong>：<code>Cone</code>类通过继承获得了<code>Circle</code>的属性，并添加了自己的属性<code>height</code>。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在<strong>继承体系结构</strong>中，同一消息<strong>为不同的对象接受时可产生完全不同的行动</strong></p><p>利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消<br>息的对象自行决定</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template<typename t></typename></h2><p>template：声明这是一个模板。<br>typename T：声明一个<strong>类型参数T</strong>，T<strong>可以是任何类型</strong>（如int、double、string等）。<br>typename 也可以用 class 替代（如 template<class t>），两者在模板中<strong>含义相同</strong>。</class></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T buffer[<span class="number">100</span>]; <span class="comment">// 假设栈大小为100</span></span><br><span class="line">    <span class="type">int</span> top;       <span class="comment">// 栈顶位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>() : <span class="built_in">top</span>(<span class="number">-1</span>) &#123;&#125; <span class="comment">// 初始化栈顶为-1，表示空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">99</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈满</span></span><br><span class="line">        buffer[++top] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;Stack is empty!&quot;</span>; <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> buffer[top--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack;    <span class="comment">// 存储int的栈</span></span><br><span class="line">Stack&lt;<span class="type">double</span>&gt; doubleStack; <span class="comment">// 存储double的栈</span></span><br><span class="line"></span><br><span class="line">intStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">doubleStack.<span class="built_in">push</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure><h2 id="数据结构与数据访问"><a href="#数据结构与数据访问" class="headerlink" title="数据结构与数据访问"></a><strong>数据结构</strong>与数据访问</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * length); </span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span> [length] ;</span><br><span class="line"><span class="keyword">delete</span> [ ]p2; <span class="comment">// 释放数组用法</span></span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">// 释放单个元素</span></span><br></pre></td></tr></table></figure><h2 id="C-函数的新特性"><a href="#C-函数的新特性" class="headerlink" title="C++函数的新特性"></a>C++函数的新特性</h2><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h4><p>对一个数据可以使用引用(reference)的方式声明，引用的作用是<strong>为一个变量起一个别名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a ; </span><br><span class="line">int &amp;b = a; // 声明b是int a的引用</span><br><span class="line">b = 20; // a = 20</span><br></pre></td></tr></table></figure><p>在一条语句中声明多个引用时<strong>应逐一声明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; x=a, y = b，z = c ; <span class="comment">//error</span></span><br><span class="line"><span class="type">int</span> &amp;x=a, &amp;y=b, &amp;z=c; </span><br></pre></td></tr></table></figure><p>声明引用变量<strong>必须进行初始化</strong>，引用未定义变量称悬挂引用。<br>将前面声明的引用重新变为另一变量的别名是个<strong>逻辑错误</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y =<span class="number">5</span>, z = <span class="number">3</span>; </span><br><span class="line"><span class="type">int</span> &amp;x = z, &amp;x = y</span><br></pre></td></tr></table></figure><p>&amp;在此<strong>不是求地址运算</strong>，而是起<strong>标识</strong>作用。</p><p>引用声明完毕后，相当于目标变量名有<strong>两个名称</strong>，</p><p>声明一个引用，<strong>不是新定义了一个变量</strong>，引用本身<strong>不占存储单元</strong>，系统也不给引用分配存储单元。</p><p>引用即用别名引用这个变量,目的是为了消除指针</p><h4 id="引用传递的特点"><a href="#引用传递的特点" class="headerlink" title="引用传递的特点"></a>引用传递的特点</h4><p><strong>消除了复制大量数据的开销</strong>，有利提高执行效率；<br>在被调用函数中直接使用形参变量，提高可读性；<br>安全性较差，被调用函数能直接访问和修改调用者的数据。<br>fun( const T&amp; value)；<br>若要传递较大的对象，用常量引用参数模拟按值调用．<br>要指定引用常量，在参数声明的类型说明符前面加上const</p><h4 id="内联函数inline-以相应代码代替"><a href="#内联函数inline-以相应代码代替" class="headerlink" title="内联函数inline(以相应代码代替)"></a><strong>内联函数inline(以相应代码代替)</strong></h4><p>C++为<strong>降低小程序调用开销</strong>的一种机制。<br><strong>默认参数值 default parameter value</strong><br>函数参数的默认值使得在函数调用时<strong>可不指定参数。</strong></p><p><strong>建议性声明：不能含有复杂结构控制语句和递归调用</strong></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h4><p>常用于处理<strong>不同数据类型</strong>而<strong>功能类似</strong>的<strong>同名</strong>函数;</p><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><p>经常需要用<strong>相同的参数调用同一函数时</strong>，简化函数调用。<br>当函数调用时，若实参数个数少于形参数的总数时，<br>则所缺参数自动取函数参数表中设置的缺省值。：<br>当函数声明时，由<strong>右至左指定默认参数</strong>的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length, <span class="type">int</span> width = <span class="number">1</span>, <span class="type">int</span> highth =<span class="number">1</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="title">volumn</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">2</span>, ,<span class="number">2</span>);<span class="comment">//中间参数默认</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length, <span class="type">int</span> width = <span class="number">1</span>, <span class="type">int</span> highth =<span class="number">1</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length, <span class="type">int</span> width )</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">volumn</span><span class="params">( <span class="type">int</span> length)</span>；</span></span><br><span class="line"><span class="function"><span class="title">volumn</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//有二义性,回出错</span></span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">2</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">volumn</span>(<span class="number">1</span>,<span class="number">2</span> ,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="初识类"><a href="#初识类" class="headerlink" title="初识类"></a>初识类</h2><h2 id="封装-encapsulate"><a href="#封装-encapsulate" class="headerlink" title="封装(encapsulate)"></a>封装(encapsulate)</h2><ul><li>把全部属性和全部行为封装在一起，<br>  形成一个不可分割的独立单位（即对象）。</li><li>信息隐蔽(information hiding)<br>  对象的外部不能直接地存取对象属性，只能通过几个允许外部使用的服务与对象发生联系。</li><li><strong>对象间通发送消息</strong>进行交互.</li></ul><p>类是面向对象编程的<strong>程序基本单位</strong><br>程序<strong>模块</strong>是各种<strong>由类构成的</strong><br>类是<strong>逻辑上相关</strong>数据和函数的<strong>封装</strong><br>类是对问题的<strong>抽象描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line"><span class="comment">//私有数据成员和成员函数；</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line"><span class="comment">//保护数据成员和成员函数；</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="comment">//公有数据成员和成员函数；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在<strong>类的外部</strong>定义成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回类型 类名::成员函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">函数定义体</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">( )</span></span>&#123; cout &lt;&lt; m_a &lt;&lt; m_b &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure><p>在<strong>类内</strong>直接定义成员函数, <strong>默认创建为内联</strong>函数<br>如果成员函数在类体外定义,要<strong>用inline声明为内联</strong>函数</p><p><strong>域运算符“∷”</strong>，<strong>成员运算符“.”</strong></p><p>在类外定义函数时，应指明成员函数的<strong>作用域</strong></p><p>在成员函数引用本对象的数据成员时，只需<strong>直接写数据成员名，</strong><br>这时C++系统会把它默认为本对象的数据成员。</p><h4 id="保护-protected"><a href="#保护-protected" class="headerlink" title="保护 protected"></a><strong>保护</strong> protected</h4><p><strong>除了类本身的成员函数和说明为友元函数或友元类的成员函数可以访问保</strong></p><p><strong>护成员外，该类的派生类的成员也可以访问**</strong>。**</p><p><strong>private 在首次出现时可以忽略</strong></p><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a><strong>对象的使用</strong></h2><p><strong>同类对象之间可以相互赋值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time tA, tB;</span><br><span class="line">tA.<span class="built_in">set</span> (<span class="number">15</span>,<span class="number">6</span>,<span class="number">0</span>);</span><br><span class="line">tB = tA;</span><br></pre></td></tr></table></figure><p>成员访问运算符“.” 和<strong>“-&gt;”(对象指针名-&gt;成员名)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; t.hour &lt;&lt; pTime -&gt;<span class="built_in">min</span>(相当于访问所指对象的成员min) &lt;&lt; (*pTime).sec;</span><br></pre></td></tr></table></figure><p>软件工程的一个最基本的原则就是<strong>将接口与实现分离</strong>，信息隐蔽是软件工程中一个非常重要的概念。</p><p><strong>自定义类库头文件.h</strong><br>文件中有用户自行设计的类的定义，包括类的外部接口（公有成员函数的原型）。任何需要使用这些类的源程序，只要在文件中包含这些头文件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//point.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">distance</span><span class="params">(Point &amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> j)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//point.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;point.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::distance</span><span class="params">(Point &amp; p)</span></span>&#123;<span class="comment">//定义要指明作用域</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((p.x-x)*(p.x-x)+(p.y-y)*(p.y-y)); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setX</span><span class="params">(<span class="type">double</span> i)</span></span>&#123;x=i;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setY</span><span class="params">(<span class="type">double</span> j)</span></span>&#123;y=j;&#125;</span><br></pre></td></tr></table></figure><p>在面向对象的程序开发中，一般做法是将<strong>类的声明</strong>放在指定的头文件中，用户如果想用该类，只要把有关的头文件包含进来即可，不必在程序中重复书写类的声明,在<strong>程序中</strong>就可以用该类来<strong>定义</strong>对象.为了实现信息隐蔽，对类成员函数的定义一般不放在头文件中，而另外放在一个文件中。</p><h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><p>(自定义)<strong>默认构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;默认构造函数名&gt;（）</span><br><span class="line">&#123; &#125;</span><br><span class="line">Time::<span class="built_in">Time</span>( )</span><br><span class="line">&#123; hour=min=sec = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p><strong>析构函数</strong></p><p>构造函数的反函数，析构函数是用于<strong>取消对象成员</strong>函数，<br>当一个对象生命期结束时，系统自动调用析构函数。</p><ul><li>析构函数名字为<strong>符号“~”</strong>加类名；<ul><li>析构函数<strong>没有参数和返回值</strong>。<ul><li>一个类中只可能定义一个析构函数，<br>  析构函数<strong>不能重载</strong>。<ul><li>析构函数的作用<br>  进行清除对象，释放内存等；</li></ul></li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名::</span><br><span class="line">~默认析构函数名（）</span><br><span class="line">&#123; &#125;<span class="comment">//空函数</span></span><br></pre></td></tr></table></figure><p>自动调用<br>(1) 一个对象当其结束生命周期时 ；<br>(2) 使用<strong>new运算符创建的对象</strong>，<br>在<strong>使用delete运算符释放</strong>该对象时；<br>一般析构函数的<strong>调用顺序</strong>与构造函数<strong>相反</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Rational&#123;</span><br><span class="line">public:</span><br><span class="line">Rational(int nn=1,int mm=1); //构造函数</span><br><span class="line">void print() ; // 输出化简的 分子/分母</span><br><span class="line">void simple(); // 约分</span><br><span class="line">double getValue(); // 返回分数值</span><br><span class="line">Rational add(Rational &amp; A); // r = r1.add(r2); </span><br><span class="line">void sub(Rational &amp; A , Rational &amp;B); // r.sub(r1,r2);</span><br><span class="line">Rational mul(Rational &amp; A);</span><br><span class="line">void _div(Rational &amp; A, Rational &amp;B); </span><br><span class="line">private:</span><br><span class="line">int m; // 分母</span><br><span class="line">int n; // 分子</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般情况下，如果类中的数据<strong>都在栈里</strong>，程序员不需要开发<strong>自定义的拷贝构造函数</strong></p><p><strong>默认拷贝构造函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A  b ( a )</span><br></pre></td></tr></table></figure><p>对象复制与对象赋值是<strong>不同的</strong></p><p>静态数据成员的初始化与一般数据成员不同,<strong>外部</strong>静态数据成员初始化的格式如下：    </p><p>&lt;类型&gt; &lt;类名&gt;::&lt;静态数据成员&gt; = &lt;值&gt;;</p><p>3）在引用静态数据成员时采用格式：      </p><p><strong>&lt;类名&gt;::&lt;静态数据成员&gt;</strong>    &lt;对象名&gt;. &lt;静态数据成员&gt;</p><p>静态数据成员 vs 全局变量     </p><p>有了静态数据成员，<strong>各对象之间(即不依赖于对象使用)</strong>的数据有了沟通的渠道，实现数据共享 。    全局变量<strong>破坏了封装的原则</strong>，不符合面向对象程序的要求。   </p><p>公用静态数据成员与全局变量的作用域不同  </p><p>静态数据成员的作用域<strong>只限于定义该类的作用域内</strong> </p><p>静态成员函数<strong>只能访问静态数据成员、静态成员函数和类以外的函数和数据，不能访问类中的非静态数据成员（因为非静态数据成员只有对象存在时才有意义）</strong>。但静态数据成员和静态成员函数可由任意访问权限许可的函数访问。和一般成员函数类似，静态成员函数也有访问限制，私有静态成员函数不能由外界访问。静态成员函数<strong>没有this指针</strong>，因此，静态成员函数<strong>只能直接访问类中的静态成员</strong>，若要访问类中的非静态成员时，<strong>必须借助对象名或指向对象的指针</strong>。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Counter</span></span><br><span class="line">&#123;         <span class="type">static</span>  <span class="type">int</span>  num ;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">           <span class="built_in">Counter</span>( )&#123; num++; &#125;</span><br><span class="line">            ～<span class="built_in">Counter</span>()&#123; num--; &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span>  <span class="title">setnum</span> <span class="params">( <span class="type">int</span> i )</span> </span>&#123; num = i ; &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span>  <span class="title">shownum</span><span class="params">()</span> </span>&#123; cout &lt;&lt; num &lt;&lt; <span class="string">&#x27;\t&#x27;</span> ; &#125;</span><br><span class="line">     <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> num ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">int</span>  Counter :: num = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  Counter  a ;      a.<span class="built_in">shownum</span>() ;</span><br><span class="line">Counter  b ;      b.<span class="built_in">shownum</span>() ;</span><br><span class="line">cout&lt;&lt;Counter::<span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static 数据是<strong>类共有</strong>的,static 函数可以类名调用，也可以对象调用,<strong>普通成员函数能访问static数据</strong></p><p>const成员变量<strong>只能由构造函数通过初始化列表对该数据成员进行初始化</strong></p><p>若<strong>成员函数不修改对象</strong>,则声明为const.</p><p>const关键词可以<strong>参与区分重载函数</strong>。</p><p>const 对象<strong>只能调用它的const 成员函数</strong>，而不能调用其他成员函数。</p><p>直接初始化</p><p><strong>分配空间的同时进行初始化</strong>. 一般数组成员较少.</p><p>Box b[3] = {Box(1),Box(1,1),Box(1,1,1)};  </p><p>间接初始化</p><p><strong>先分配空间</strong>，<strong>之后完成初始化</strong>. </p><p>Box a[50];//先调用默认                      </p><p>for( int i = 0; i&lt;50;i++){ a[i].set(i, i, i); }</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Box box [<span class="number">3</span>] ;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123;<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)&#125;;  </span><br><span class="line">Box box [<span class="number">3</span>] = &#123;<span class="built_in">Box</span>(),<span class="built_in">Box</span>(),<span class="built_in">Box</span>()&#125;;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123;Box, Box ,Box &#125;;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123;<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">2</span>),  &#125;;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123;<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>) &#125;;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123;<span class="built_in">Box</span>(<span class="number">1</span>) &#125;;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123; &#125;;</span><br><span class="line">Box box [<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Box *p =<span class="keyword">new</span> Box[<span class="number">3</span>];</span><br><span class="line">Box *p =<span class="keyword">new</span> Box[<span class="number">3</span>]&#123;<span class="built_in">Box</span>(<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">Box</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) &#125;;</span><br></pre></td></tr></table></figure><h2 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line">      Point（<span class="type">int</span>=<span class="number">0</span>,<span class="type">int</span>=<span class="number">0</span>）;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span>  </span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> x; </span><br><span class="line">     <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>                                   </span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Circle</span>(<span class="type">double</span> r, Point p);</span><br><span class="line">      <span class="built_in">Circle</span>(<span class="type">double</span> r, <span class="type">int</span> x, <span class="type">int</span> y)；</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">       <span class="function">Point <span class="title">getCenter</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> radius;</span><br><span class="line">      Point  center;<span class="comment">//类的嵌套    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数-必须首先初始化内嵌对象的数据"><a href="#构造函数-必须首先初始化内嵌对象的数据" class="headerlink" title="构造函数: 必须首先初始化内嵌对象的数据"></a>构造函数: 必须首先初始化内嵌对象的数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Circle ::<span class="built_in">Circle</span>(<span class="type">double</span> r, <span class="type">int</span> x, <span class="type">int</span> y):<span class="built_in">radius</span>(r), <span class="built_in">center</span>(x,y)&#123; &#125;</span><br><span class="line">Circle ::<span class="built_in">Circle</span>(<span class="type">double</span> r, Point p):<span class="built_in">radius</span>(r), <span class="built_in">center</span>(p)&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数-可以使用内嵌对象调用其函数-注意访问权限控制！"><a href="#成员函数-可以使用内嵌对象调用其函数-注意访问权限控制！" class="headerlink" title="成员函数: 可以使用内嵌对象调用其函数. 注意访问权限控制！"></a>成员函数: 可以使用内嵌对象调用其函数. 注意访问权限控制！</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">       center.<span class="built_in">setX</span>(x);  <span class="comment">//center.x = x;   compiler error!</span></span><br><span class="line">       center.<span class="built_in">setY</span>(y);  <span class="comment">//center.y = y;   compiler error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员对象的初始化"><a href="#成员对象的初始化" class="headerlink" title="成员对象的初始化"></a>成员对象的初始化</h4><p>一个对象如果有<strong>“成员对象”</strong>（即它的成员数据不是普通类型，而是“类”类型的），那么在<strong>实现构造函数时应对“成员对象”进行初始化</strong>)</p><p>方式是在构造函数中<strong>增加构造参数，指明“成员对象”构造的方式</strong></p><p>若没有“成员对象”构造方式的声明，系统<strong>默认调用“成员对象”的无参的构造函数。</strong></p><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>一个类包含另一个类的对象</p><p>描述<strong>整体拥有部分</strong>的关系，即<strong>has-a关系</strong></p><p>该类不与其他类共享对象的引用。即<strong>“整体”端重数只能是1</strong></p><p>如果这种类的对象生命周期结束，<strong>被包含的对象的生命周期也会结束。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Textfield</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Botton</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DialogueWindow</span>&#123;</span><br><span class="line">Textfield textfield;   <span class="comment">//data member</span></span><br><span class="line">Botton botton;        <span class="comment">//data member</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DialogueWindow</span>&#123;</span><br><span class="line">Textfield textfield1;  <span class="comment">//data member</span></span><br><span class="line">          Textfield textfield2;  <span class="comment">//data member</span></span><br><span class="line">Botton botton1;          <span class="comment">//data member</span></span><br><span class="line">          Botton botton2;          <span class="comment">//data member</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>描述两个类对象之间<strong>短暂的相互作用</strong></p><p>依赖关系表示一个类的对象<strong>短暂使用了另一个类对象</strong>，代表类之间<strong>“uses-a”关系</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hour;</span><br><span class="line"><span class="type">int</span> minute;</span><br><span class="line"><span class="type">int</span> second;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;  cout&lt;&lt;hour&lt;&lt;“ ”&lt;&lt;minute&lt;&lt;“ ”&lt;&lt;second&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;         <span class="comment">// 打印机类</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">// 打印</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>   <span class="comment">// 学生类</span></span><br><span class="line">&#123;  <span class="comment">// 使用打印机</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">usePrinter</span><span class="params">(Printer &amp;p)</span></span>&#123;  p.<span class="built_in">print</span>();  &#125;</span><br><span class="line">     ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Printer printer;   Student studnet;</span><br><span class="line">student.<span class="built_in">usePrinter</span>(printer);                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类的成员<strong>不包含打印机Printer的对象或者指针</strong>，即二者<strong>不具有“拥有has-a’关系</strong>。<strong>只有学生对象调用usePrinter( )函数时，学生对象与打印机对象才建立关系</strong>，并且在该<strong>函数执行完毕后，二者关系就结束了</strong>。一种<strong>短暂的”使用关系”</strong>，即“use-a”关系。依赖关系除了<strong>被依赖方作为依赖方的函数参数，还可能作为依赖方的函数中的临时对象</strong>。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:   <span class="type">int</span> x;</span><br><span class="line">Public:  <span class="built_in">A</span>()&#123;x=<span class="number">1</span>;&#125;</span><br><span class="line">     <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">Private:  <span class="type">char</span> c;</span><br><span class="line">Public:  <span class="built_in">B</span>() &#123;c=<span class="string">&#x27;c&#x27;</span>;&#125;</span><br><span class="line">              <span class="function"><span class="type">void</span> <span class="title">something</span><span class="params">()</span></span>&#123;</span><br><span class="line">                      A instance;</span><br><span class="line">cout&lt;&lt;instance.x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">B b_instance;</span><br><span class="line">b_instance.<span class="built_in">something</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="友元-函数-与友元类"><a href="#友元-函数-与友元类" class="headerlink" title="友元 函数 与友元类"></a>友元 函数 与友元类</h2><h4 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h4><p>可以访问另一个类的<strong>私有和保护（稍后更多）成员(区别于组合)</strong></p><p>友元函数不是类的成员函数</p><p>友元函数<strong>在类范围之外定义</strong></p><h4 id="友元的特性"><a href="#友元的特性" class="headerlink" title="友元的特性"></a>友元的特性</h4><p>友元是<strong>“给予”的，而不是“索要”的</strong></p><p><strong>非对称</strong>性（如果 B 是 A 的友元，A 不一定是 B 的友元）</p><p><strong>非传递</strong>性（如果 A 是 B 的友元，B 是 C 的友元，A 不一定是 C 的友元） </p><h4 id="友元的主要用途"><a href="#友元的主要用途" class="headerlink" title="友元的主要用途"></a>友元的主要用途</h4><p>提供了一种访问类成员的更方便快捷的途径</p><p>为运算符重载的实现提供了更方便的途径</p><p>友元<strong>可以访问类的任何成员(可不通过成员函数)</strong>,这破环了类的封装性，因此要谨慎使用友元</p><p><strong>有权从类外部更改类的内部状态</strong>。 因此推荐使用成员函数而不是友元来改变状态 </p><h4 id="friend-声明"><a href="#friend-声明" class="headerlink" title="friend 声明"></a>friend 声明</h4><p><strong>friend 函数</strong> </p><p> Keyword friend</p><p>friend int myFunction( int x );</p><p> <strong>声明在类内</strong>，<strong>保证这个函数可以在类外访问类成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Accumulator</span>() &#123; m_value = <span class="number">0</span>; &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value += value; &#125;</span><br><span class="line">    <span class="comment">// 声明reset() 函数是本类的友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// reset() 现在是 Accumulator 的友元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接访问Accumulator 对象的任何数据</span></span><br><span class="line">    accumulator.m_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="friend-类"><a href="#friend-类" class="headerlink" title="friend 类"></a>friend 类</h4><p>在类名前加 friend <strong>保证该类可以访问类成员</strong>,可以让整个类成为另一个类的友元。 这使<strong>友元类的所有成员函数都可以访问其他类的私有成员</strong>。友元类的<strong>所有函数都是友元函数</strong> </p><p>也可以不把整个类声明为友元, 仅仅只声明一个或多个函数为另一个类的友元函数. 这类似于声明普通函数成为友元，<strong>除了使用包含 className:: 前缀</strong></p><p>友元常用于<strong>定义重载运算符时</strong>。当两个或多个类需要以一种亲密的方式一起工作时，<strong>不常使用友元</strong>。使一个<strong>类</strong>成为友元<strong>只需要作为前向声明</strong>该类存在。 但是，使特定的类的<strong>成员函数</strong>成为友元则需要<strong>首先看到成员函数类的完整声明</strong>.</p><h2 id="继承-不允许继承循环"><a href="#继承-不允许继承循环" class="headerlink" title="继承(不允许继承循环)"></a><strong>继承</strong>(<strong>不允许继承循环</strong>)</h2><h4 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a><strong>继承的概念</strong></h4><p><strong>派生类具有基类的特性</strong></p><ul><li><p><strong>共享</strong>基类的<strong>成员函数</strong></p></li><li><p>使用基类的数据成员</p></li></ul><p><strong>派生类新增成员(拓展)</strong></p><ul><li><p>定义自己的数据成员</p></li><li><p>定义独特的成员函数</p></li></ul><p><strong>派生类改造基类</strong></p><ul><li><strong>重写基类某些成员函数</strong></li></ul><p>C++中单继承派生类的定义形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : [继承方式] 基类名</span><br><span class="line">&#123;</span><br><span class="line">派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式包括：</p><p>public（公有继承）<br>private（私有继承，<strong>默认</strong>）<br>protected（保护继承）(<strong>保护成员在本类与派生类中能直接访问</strong>)</p><p>C++中多重继承派生类的定义形式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: [继承方式] 基类名<span class="number">1</span>, [继承方式] 基类名<span class="number">2</span>,…, </span><br><span class="line">[继承方式] 基类名n</span><br><span class="line">&#123;</span><br><span class="line">派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">protected</span> Student, Teacher<span class="comment">//对Teacher默认是私有继承</span></span><br><span class="line">&#123; …… &#125;;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/fa7f516ffbe998538989d54213bb5837.png" alt="fa7f516ffbe998538989d54213bb5837"></p><p><strong>继承方式决定了基类成员在派生类中的访问权，</strong></p><p><strong>这种访问来自两个方面</strong>：</p><ul><li><strong>派生类中</strong></li></ul><p>新增函数成员访问从基类继承来的成员</p><ul><li><strong>派生类外部</strong></li></ul><p>通过派生类的对象访问从基类继承的成员</p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/94de02253d18c73529beb0753b328c5d.png" alt="94de02253d18c73529beb0753b328c5d"></p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/98f37468b772cd29ba63bb8ba5dfef81.png" alt="98f37468b772cd29ba63bb8ba5dfef81"></p><h4 id="访问私有继承的成员"><a href="#访问私有继承的成员" class="headerlink" title="访问私有继承的成员"></a>访问私有继承的成员</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123; <span class="type">int</span> number; <span class="type">char</span> school[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">protected</span>: <span class="type">char</span> name[<span class="number">10</span>]; <span class="type">char</span> sex; </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">input_data</span><span class="params">( )</span></span>; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeStudent</span> : <span class="keyword">private</span> Student</span><br><span class="line">&#123; <span class="type">char</span> major[<span class="number">10</span>]; <span class="comment">//新增成员:专业</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input_major</span><span class="params">( )</span></span>&#123;cin&gt;&gt;major ; &#125; </span><br><span class="line"><span class="comment">// 输入专业</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span></span>&#123; Student::<span class="built_in">print</span>(); </span><br><span class="line"><span class="comment">// 输出信息</span></span><br><span class="line">cout&lt;&lt;“name:”&lt;&lt;name &lt;&lt;“ sex:”&lt;&lt;sex &lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;major:&quot;</span>&lt;&lt;major&lt;&lt;endl; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123; …… &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeStudent</span> : <span class="keyword">private</span> Student&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Student s; s.<span class="built_in">input_data</span>(); s.<span class="built_in">print</span>();</span><br><span class="line">CollegeStudent cs;</span><br><span class="line">cs.<span class="built_in">input_data</span>(); <span class="comment">// 错误</span></span><br><span class="line">cs.<span class="built_in">input_major</span>();</span><br><span class="line">cs.<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>CollegeStudentl类访问基类,Student的能力没有变化，</p><p>在私有继承的情况下，通过派生类<strong>对象(并非类内)</strong>无法访问基类的任何成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123; <span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_XY</span><span class="params">( )</span> </span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put_XY</span><span class="params">( )</span> </span>; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::get_XY</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; cin &gt;&gt; x &gt;&gt; y ; &#125;</span><br><span class="line"><span class="type">void</span> A:: <span class="built_in">put_XY</span>( )</span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;x = &quot;</span>&lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span> ; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123; <span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_S</span><span class="params">()</span> </span>&#123; s = x * y ; <span class="keyword">return</span> s ; &#125; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123; <span class="keyword">public</span> : </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_H</span><span class="params">()</span> </span>&#123; cin &gt;&gt; h ; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_V</span><span class="params">()</span> </span>&#123;v = <span class="built_in">get_S</span>() * h ; <span class="keyword">return</span> v ; &#125;</span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="type">int</span> h, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; A objA ;</span><br><span class="line">B objB ;</span><br><span class="line">C objC ;</span><br><span class="line">objA.<span class="built_in">get_XY</span>() ;</span><br><span class="line">objA.<span class="built_in">put_XY</span>() ;</span><br><span class="line">objB.<span class="built_in">get_XY</span>() ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;S = &quot;</span> &lt;&lt; objB.<span class="built_in">get_S</span>() &lt;&lt; endl ;</span><br><span class="line">objC.<span class="built_in">get_XY</span>() ;</span><br><span class="line">objC.<span class="built_in">get_H</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;V = &quot;</span> &lt;&lt; objC.<span class="built_in">get_V</span>() &lt;&lt; endl ;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/a87a6f027be2e1b66c1c2497d61e59f3.png" alt="a87a6f027be2e1b66c1c2497d61e59f3"></p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/4d2fe503e36e73613dfe44ad25b9ed9e.png" alt="4d2fe503e36e73613dfe44ad25b9ed9e"></p><p><strong>三种继承方式的对比</strong></p><p>一般采用不会改变基类成员访问权限的<strong>公有继承</strong>。</p><p><strong>私有继承：</strong></p><p>基类的可被继承的成员都成了其直接派生类的私有成员，</p><p>无法再进一步派生，</p><p>实际上私有继承相当于终止了基类成员的继续派生。</p><p><strong>保护继承</strong>：</p><p>基类的可被继承的成员都成了直接派生类的保护成员，</p><p>保护继承保证了最上层基类的成员依然能被继承树中的</p><p>次级子类所继承。</p><p><strong>访问级别不能升只能降,一层一层来看即可</strong></p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/42f4358cb52c4ca97743131bb9022ee9.png" alt="42f4358cb52c4ca97743131bb9022ee9"></p><h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a><strong>派生类的构造函数</strong></h2><p><strong>派生类的构造与析构函数</strong></p><p>• <strong>创建派生类对象时调用基类的构造函数来初始化基类数据。</strong></p><p>• <strong>执行派生类的析构函数时，基类的析构函数也将被调用。</strong></p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/dcef7a843dbe532605e80a1b95c20b54.png" alt="dcef7a843dbe532605e80a1b95c20b54"></p><p><strong>派生类构造函数的定义方式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">派生类名（参数总表）：基类名（基类构造函数参数表<span class="number">1</span>）, 对象成员(参数表<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">派生类成员初始化；</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> no, <span class="type">char</span> name[],<span class="type">char</span> sex):<span class="built_in">Person</span>(name,sex)</span><br><span class="line">&#123; id = no; &#125;</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> no, <span class="type">char</span> name[],<span class="type">char</span> sex):</span><br><span class="line"><span class="built_in">Person</span>(name,sex), <span class="built_in">id</span>( no )&#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="keyword">public</span>: <span class="built_in">Base1</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base1&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="keyword">public</span>: <span class="built_in">Base2</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base2&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;  <span class="comment">// 基类声明顺序：Base2 → Base1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base1</span>(), <span class="built_in">Base2</span>() &#123;  <span class="comment">// 初始化列表顺序：Base1 → Base2（与声明顺序相反）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-初始化顺序的决定因素"><a href="#1-初始化顺序的决定因素" class="headerlink" title="1. 初始化顺序的决定因素"></a>1. <strong>初始化顺序的决定因素</strong></h3><ul><li><strong>基类</strong>：按照<strong>派生类定义时基类的声明顺序</strong>初始化（无论初始化列表中如何排列）。</li><li><strong>成员变量</strong>：按照成员在类中<strong>声明的顺序</strong>初始化（<strong>与初始化列表顺序无关</strong>）。</li><li><strong>派生类自身</strong>：<strong>最后执行派生类构造函数</strong>的<strong>函数体</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="keyword">public</span>: <span class="built_in">Base1</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base1&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="keyword">public</span>: <span class="built_in">Base2</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base2&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;  <span class="comment">// 基类声明顺序：Base2 → Base1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">Base1</span>(), <span class="built_in">Base2</span>() &#123;  <span class="comment">// 初始化列表顺序：Base1 → Base2（与声明顺序相反）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2</span><br><span class="line">Base1</span><br><span class="line">Derived</span><br></pre></td></tr></table></figure><h4 id="为什么初始化顺序固定？"><a href="#为什么初始化顺序固定？" class="headerlink" title="为什么初始化顺序固定？"></a><strong>为什么初始化顺序固定？</strong></h4><ul><li><strong>成员变量依赖</strong>：若成员变量的初始化依赖于其他成员的顺序，固定顺序可避免潜在错误。</li><li><strong>基类依赖</strong>：若基类的初始化顺序被用户随意调整，可能导致基类未完全初始化就被使用。</li></ul><h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h5><ul><li><strong>保持初始化列表顺序与声明顺序一致</strong>：提高代码可读性，避免混淆。</li><li><strong>避免成员间的初始化依赖</strong>：若必须依赖，通过构造函数体或成员函数处理。</li></ul><p><strong>构造函数执行顺序：</strong>基类-&gt;派生类中对象成员-&gt;派生类</p><h4 id="派生类构造函数的几点说明"><a href="#派生类构造函数的几点说明" class="headerlink" title="派生类构造函数的几点说明"></a>派生类构造函数的几点说明</h4><p>1）派生类构造函数的定义中可<strong>省略对基类构造函数的调用</strong>其条件是<strong>在基类中必须有默认的构造函数或者根本没有定义构造函数。</strong><br>2）当基类的构造函数使用<strong>一个或多个参数</strong>时，则<strong>派生类必须定义构造函数</strong>，提供<strong>将参数传递</strong>给基类构造函数途径。</p><h4 id="继承中的同名成员访问"><a href="#继承中的同名成员访问" class="headerlink" title="继承中的同名成员访问"></a><strong>继承中的同名成员访问</strong></h4><p>多重继承时不同基类成员同名也可以用<strong>类名限定符“::”</strong>来解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span>: <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;id&lt;&lt;endl; <span class="comment">//error!访问是二义的</span></span><br><span class="line">cout&lt;&lt;Student::id&lt;&lt;endl; <span class="comment">//访问Student的id</span></span><br><span class="line">cout&lt;&lt;Teacher::id&lt;&lt;endl; <span class="comment">//访问Teacher的id</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>继承时的同名成员隐藏规则</strong><br>派生类定义了与基类相同的成员，此时<strong>基类的同名成员在派生类内不可见</strong>，派生类成员隐藏了同名的基类成员.</p><p>基类成员与派生类成员同名，可以通过类名限定符“::”来解决。其语法为：<strong>类名</strong> <strong>: :</strong> <strong>成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person&#123; <span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">private</span>: <span class="type">int</span> id; <span class="comment">// 学号</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; <span class="comment">//测试函数</span></span><br><span class="line">id=<span class="number">123</span>; <span class="comment">// 访问派生类成员</span></span><br><span class="line">Person::id =<span class="number">456</span>; <span class="comment">// 访问基类成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承中成员同名有两种情况：<br>1.<strong>基类</strong>成员与<strong>派生类</strong>成员同名<br>2.多重继承时<strong>不同基类</strong>成员同名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123; <span class="keyword">protected</span>: <span class="type">int</span> id; &#125;; <span class="comment">// 身份号码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123; <span class="keyword">protected</span>: <span class="type">int</span> id; &#125;; <span class="comment">// 学号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123; <span class="keyword">protected</span>: <span class="type">int</span> id;&#125;; <span class="comment">// 职工号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span>: <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; <span class="comment">// 测试</span></span><br><span class="line">Student::id = <span class="number">1001</span>; <span class="comment">// 正确：访问Student类的id</span></span><br><span class="line">Teacher::id = <span class="number">101</span>; <span class="comment">// 正确：访问Teacher类的id</span></span><br><span class="line">Person::id =<span class="number">230</span>×××<span class="number">0001</span>; <span class="comment">// 错误&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/1e35cab60282a49190c05943c754245c.png" alt="1e35cab60282a49190c05943c754245c"></p><h3 id="类族中的赋值兼容"><a href="#类族中的赋值兼容" class="headerlink" title="类族中的赋值兼容"></a>类族中的<strong>赋值兼容</strong></h3><p><strong>公有继承</strong>时，一个<strong>派生类的对象</strong>可用于<strong>基类对象</strong>适用的地方，需要基类对象的任何地方都可以使用派生类对象<strong>替代</strong>。</p><p>赋值兼容规则有三种情况：<br>（1）派生类的对象可以<strong>赋值给基类的对象</strong>。<br>base <em>Obj = derived</em> Obj;<br>（2）派生类的对象可以<strong>初始化基类的引用</strong>。<br>base&amp; base_Obj = derived_obj;<br>（3）派生类的对象的<strong>地址可以赋给指向基类的指针</strong>。<br>base *pBase = &amp;derived_obj;</p><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/8b80309614a6abf7fa39b9b15d0abf52.png" alt="8b80309614a6abf7fa39b9b15d0abf52"></p><h2 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>指<strong>同样的消息</strong>被<strong>不同类型的对象接收</strong>时,产生不同行为的<strong>现象</strong>。(<strong>同一名字，多种语义</strong>；<strong>同个接口，多种方法</strong>)</p><h4 id="静态多态的概念"><a href="#静态多态的概念" class="headerlink" title="静态多态的概念"></a><strong>静态多态的概念</strong></h4><p>在程序<strong>编译时</strong>系统就能够<strong>确定要调用的是哪个函数</strong>，也被称为<strong>编译时多态</strong>。</p><ul><li><p>函数重载</p></li><li><p>运算符重载</p></li></ul><h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><p><strong>不能仅靠函数的返回值</strong>来区别重载函数，必须从<strong>形式参数上</strong>区别开来。</p><p><strong>派生类中的同名成员函数</strong></p><p>• <strong>使用</strong> <strong>::</strong> <strong>加以区分</strong></p><p>• <strong>使用对象加以区分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MonkyKong sun; </span><br><span class="line">sun. <span class="built_in">fly</span> ( )；</span><br><span class="line">sun . Follower :: <span class="built_in">fly</span> ( );</span><br><span class="line">Pig pigsy;</span><br><span class="line">pigsy.<span class="built_in">fly</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">A::<span class="built_in">Show</span> ( )</span><br><span class="line"><span class="built_in">Show</span> ( )</span><br><span class="line">Aobj . <span class="built_in">Show</span> ( )；</span><br><span class="line">Bobj . <span class="built_in">Show</span> ( );</span><br><span class="line">Bobj . A :: <span class="built_in">Show</span> ( );</span><br></pre></td></tr></table></figure><h4 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a><strong>动态多态性</strong></h4><p>指程序在编译时并不能确定要调用的函数，<strong>直到运行时</strong>系统才能动态地确定操作所针对的具体对象，它又被称为<strong>运行时多态</strong></p><p>动态多态是通过<strong>虚函数</strong>（virtual function）实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span>&lt;&lt;endl ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv1</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Derv1&quot;</span>&lt;&lt;endl ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv2</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Derv2&quot;</span>&lt;&lt;endl ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Derv1 dv1; </span><br><span class="line">Derv2 dv2; </span><br><span class="line">dv<span class="number">1.</span><span class="built_in">show</span>() ;</span><br><span class="line">dv<span class="number">2.</span><span class="built_in">show</span>() ;</span><br><span class="line">Base* pBase; </span><br><span class="line">pBase = &amp;dv1;</span><br><span class="line">pBase-&gt;<span class="built_in">show</span>();</span><br><span class="line">pBase = <span class="keyword">new</span> <span class="built_in">Derv2</span>(); </span><br><span class="line">pBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//通过基类指针只能访问从基类继承的成员</span></span><br></pre></td></tr></table></figure><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>C++中的虚函数的作用是<strong>允许在派生类中重新定义与基类同名的函数</strong>，并且可以<strong>通过基类指针或者基类引用来访问这个同名函数(最重要区别)</strong>。虚函数成员声明的语法为：</p><p>1．virtual只能使用<strong>在类定义</strong>的函数<strong>原型声明</strong>中，</p><p>不能在成员函数实现的时候使用，也<strong>不能用来限定类外</strong>的普通函数。</p><p>2．用virtual声明类的<strong>非静态</strong>的成员函数，<strong>只用于类的继承层次结构</strong>中。</p><p>不能将类外的普通函数(友员)和静态成员函数声明成虚函数。</p><p>virtual具有<strong>继承性</strong></p><p>在派生类中<strong>重新定义虚函数</strong>，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数<strong>完全相同</strong>。<br>否则不能实现多态性, 为<strong>函数重载</strong>.</p><p>虚函数是在基类中冠以关键字 virtual 的非静态成员函数。<br>继承体系：判断成员函数所在的类是否会作为基类；虚函数为类族提供了一种公共接口。<br>重写函数：该函数在类被继承后有无可能被更改功能；允许在派生类中对基类的虚函数重新定义<br>调用形式：是否通过基类指针或引用调用该虚函数；赋值兼容性原则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Follower</span> <span class="comment">// 徒弟类</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fight</span><span class="params">( Ghost&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuKong</span></span><br><span class="line">: <span class="keyword">public</span> Follower</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fight</span><span class="params">( Ghost* )</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p><strong>构造函数不能是虚函数</strong></p><p>建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数</p><p><strong>析构函数可以是虚函数</strong></p><p>虚析构函数用于<strong>指引 delete 运算符正确析构动态对象</strong></p><p>当<strong>基类的析构函数为虚函数</strong>时，无论指针指的是<strong>同一类族的哪一个类对象</strong>，对象撤销时，系统会采用动态关联，调用<strong>相应的析构函数</strong>，完成该对象的清理工作。</p><p>习惯把析构函数声明为虚函数，即使基类并不需要析构函数，以<strong>确保撤销动态存储空间时能够得到正确的处理</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Base</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Desconstruct Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv1</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv1</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Derv1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Derv1</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Desconstruct Derv1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv2</span>: <span class="keyword">public</span> Derv1</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv2</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Derv2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Derv2</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Desconstruct Derv2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Base* pBase = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"><span class="keyword">delete</span> pBase;</span><br><span class="line">Derv1* pDerv1 = <span class="keyword">new</span> <span class="built_in">Derv1</span>();</span><br><span class="line"><span class="keyword">delete</span> pDerv1;</span><br><span class="line">pBase = <span class="keyword">new</span> <span class="built_in">Derv2</span>();</span><br><span class="line"><span class="keyword">delete</span> pBase;<span class="comment">//析构由基类指针建立的派生类对象,没有调用派生类析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Desconstruct Base&quot;</span> &lt;&lt; endl; &#125;<span class="comment">//后面默认都虚,基类指针也可做到连删</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv1</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv1</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Derv1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Derv1</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Desconstruct Derv1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derv2</span>: <span class="keyword">public</span> Derv1</span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derv2</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Derv2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Derv2</span>( )&#123; cout &lt;&lt; <span class="string">&quot;Desconstruct Derv2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实现动态多态</strong></p><p>• 基类<strong>声明</strong>虚函数</p><p>• 派生类重写虚函数</p><p>• 基类指针或引用调用</p><p>在许多情况下，在基类中<strong>不能给出有意义的虚函数定义</strong>，这时可把它说明成纯虚函数，把它的<strong>定义留给派生类来做</strong>。<br>定义纯虚函数的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名(参数表) = <span class="number">0</span>；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>①纯虚函数<strong>没有函数体</strong>；<br>②最后面的“=0” 不表示函数返回值为0<br>③这是一个<strong>声明语句</strong>。</p><p>纯虚函数的作用<br>在基类中<strong>为其派生类保留一个函数的名字</strong>，<strong>以便派生类根据需要对它进行定义</strong>, 否则无法实现多态性。</p><h2 id="抽象类的概念"><a href="#抽象类的概念" class="headerlink" title="抽象类的概念"></a><strong>抽象类的概念</strong></h2><p>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类被成为<strong>抽象类</strong>（abstract class<strong>）</strong>。</p><p>抽象类必须用作派生其他类的基类,不能作为返回或参数类型，可使用指向抽象类的指针<strong>支持运行时多态性</strong>。而<strong>不能用于直接创建对象实例</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;<span class="built_in">getArea</span>(); (*p).<span class="built_in">draw</span>( );<span class="comment">//作指针做对象时的不同写法以区分</span></span><br></pre></td></tr></table></figure><p><strong>派</strong>生类中应<strong>重写</strong>基类中的纯虚函数，否则派生类<strong>仍将被看作</strong>一个<strong>抽象类</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test1(TwoDimensionalShape &amp; t)&#123;</span><br><span class="line">t.show( ); t.draw( ); cout&lt;&lt;t.getArea()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void test2(TwoDimensionalShape * p)&#123;</span><br><span class="line">p-&gt;show( ); p-&gt;draw( ); </span><br><span class="line">cout&lt;&lt; (*p).getArea()&lt;&lt;endl; //???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果二维图形又派生出了椭圆形，用于测试的test函数需要需改吗？这有何意义？</p><ol><li><strong>test 函数是否需要修改？</strong><br> <strong>不需要修改</strong>。<br> 若<code>椭圆形（Ellipse）</code>是<code>TwoDimensionalShape</code>的派生类，且正确重写了基类中的<code>show()</code>、<code>draw()</code>、<code>getArea()</code>虚函数（假设这三个函数在<code>TwoDimensionalShape</code>中是<strong>虚函数</strong>），则<code>test1</code>和<code>test2</code>函数可以<strong>直接接收<code>Ellipse</code>对象（或指针 / 引用）</strong>并<strong>正确调用派生类</strong>的实现。</li><li><strong>意义：</strong><br> 这体现了<strong>面向对象的多态性</strong>，具体意义如下：<ul><li><strong>代码复用性</strong>：新增派生类（如椭圆形）时，无需修改已有的<code>test1</code>、<code>test2</code>等通用函数，只需<strong>保证派生类遵循基类的接口规范（重写虚函数）</strong>，即可直接使用这些函数进行测试。</li><li><strong>扩展性</strong>：系统可以轻松扩展新的二维图形类型（如椭圆形、三角形等），而不影响原有代码的逻辑，符合 “开闭原则”（对扩展开放，对修改关闭）。</li><li><strong>接口统一性</strong>：通过基类的引用或指针调用派生类的方法，屏蔽了不同派生类的实现差异，使代码更简洁、通用，降低了模块间的耦合度。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoDimensionalShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">// 纯虚函数：显示图形信息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">// 纯虚函数：绘制图形</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数：计算面积</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TwoDimensionalShape</span>() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已有的派生类：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> TwoDimensionalShape &#123;</span><br><span class="line">    <span class="comment">// 实现show()、draw()、getArea()...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增派生类：椭圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span> : <span class="keyword">public</span> TwoDimensionalShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 计算椭圆面积 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Ellipse e;</span><br><span class="line">    <span class="built_in">test1</span>(e);       <span class="comment">// 传入Ellipse对象的引用，正确调用Ellipse的成员函数</span></span><br><span class="line">    <span class="built_in">test2</span>(&amp;e);      <span class="comment">// 传入Ellipse对象的指针，正确调用Ellipse的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>override</code>是一个<strong>关键字</strong>，用于显式声明派生类中的成员函数<strong>重写（覆盖）</strong> 了基类中的虚函数（<code>virtual</code>函数）。它的主要作用是<strong>增强代码的可读性和安全性</strong>。</p><p><strong>(3)</strong> <strong>在类的层次结构中，顶层或最上面的几层可以是抽象基类。</strong></p><p>抽象基类体现了<strong>本类族中各类的共性</strong>，把各类中共有的成员函数集中在抽象基类中<strong>声明</strong>。</p><p>为什么引⼊多态<br>利⽤多态性可以设计和实现⼀个易于扩展的系统。增强代码的通⽤性</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><div class="table-container"><table><thead><tr><th><strong>对比维度</strong></th><th><strong>重载（Overload）</strong></th><th><strong>多态（Polymorphism）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td><strong>同一作用域</strong>内，多个函数名相同但<strong>参数列表（参数类型、个数、顺序）不同</strong>的函数。</td><td><strong>基类与派生类中</strong>，派生类<strong>重写（<code>override</code>）基类的虚函数</strong>，通过<strong>基类指针 / 引用调用</strong>时，<strong>根据对象实际类型执行(多种对象对应执行)</strong>对应函数。</td></tr><tr><td><strong>实现阶段</strong></td><td><strong>编译时确定（静态多态）</strong>。编译器根据函数参数列表匹配对应的函数。</td><td><strong>运行时确定（动态多态）</strong>。程序运行时根据对象实际类型调用对应的函数。</td></tr><tr><td><strong>作用范围</strong></td><td><strong>同一类中（或全局函数）</strong>，函数名相同但参数<strong>不同(不完全等同于重写,属于新建,仅名字相同)</strong>。</td><td><strong>继承关系中，基类与派生类之间，函数名、参数列表、返回值完全相同（相同信息重写虚函数带来的不同处理响应）。</strong></td></tr><tr><td><strong>核心依赖</strong></td><td>函数<strong>参数列表的差异</strong>（与返回值无关）。</td><td><strong>基类虚函数、派生类重写、基类指针 / 引用能指向相应派生类对象并执行相应的函数。</strong></td></tr><tr><td></td><td></td></tr></tbody></table></div><h3 id="二、联系"><a href="#二、联系" class="headerlink" title="二、联系"></a><strong>二、联系</strong></h3><ol><li><strong>都是代码复用的手段</strong><ul><li>重载允许<strong>同一功能（函数名）适配不同参数</strong>，避免为相似功能起不同名字（如<code>printInt</code>、<code>printDouble</code>）。</li><li>多态允许通过<strong>统一接口（基类函数）操作不同派生类对象</strong>，简化代码逻辑（如<strong>用<code>Shape*</code>统一管理圆形、方形</strong>等）。</li></ul></li><li><strong>都体现 “一个接口，多种实现” 的思想</strong><ul><li>重载：同一函数名对应<strong>多种参数组合</strong>的实现。</li><li>多态：同一虚函数接口（基类）对应派生类的<strong>多种重写实现</strong>。</li></ul></li><li><strong>都依赖编译器的处理</strong><ul><li>重载依赖编译器在编译时<strong>根据参数匹配函数（静态绑定）</strong>。</li><li>多态依赖编译器对<strong>虚函数表的处理</strong>，实现<strong>运行时动态绑定</strong>。</li></ul></li></ol><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h3><ul><li><strong>重载</strong>是 “横向” 的函数扩展（同一类内，同名不同参），解决同一功能的不同参数适配问题，属于<strong>静态多态</strong>。</li><li><strong>多态</strong>是 “纵向” 的函数扩展（继承体系中，重写虚函数），解决不同派生类对象的统一接口调用问题，属于<strong>动态多态</strong>。</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h2><p><strong>模板</strong>可以实现<strong>类型参数化(包括新类型)</strong>,C++模板包括 函数模板和类模板两种类型<strong>。</strong></p><p><strong>函数模板</strong>就解决函数<strong>重载中</strong>多次定义函数的问题。</p><p><strong>类模板</strong>就是对一批<strong>仅仅成员数据类型不同</strong>的类的<strong>抽象</strong>。</p><p><strong>泛型编程（generic programming）</strong><br>模板用于<strong>表达逻辑结构相同</strong>，但<strong>具体数据元素类型不同</strong>的数据对象的通用行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span> <span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x*x ; &#125;</span><br><span class="line"><span class="function">Complex <span class="title">square</span> <span class="params">(Complex x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x*x ; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="function">T <span class="title">square</span> <span class="params">(T x )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br></pre></td></tr></table></figure><p>通过模板可以产生类或函数的<strong>集合</strong>，使它们操作不同的数据类型，避免需要为每种数据类型产生一个单独的类或函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> 类型参数名<span class="number">1</span> ,<span class="keyword">class</span> 类型参数 <span class="number">2</span>，…&gt;</span><br><span class="line">函数返回值类型 函数名(形式参数表)</span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><p>关键字class也可以使用<strong>关键字typename</strong>；</p><p>在template语句与函数模板定义语句&lt;返回类型&gt;之间<strong>不允许有别的语句</strong></p><p>函数模板允许使用多个类型参数，但在template定义部分的<strong>每个形参</strong>前必须有<strong>关键字typename或class</strong>，</p><p>函数形式参数表中可以使用模板类型参数，也可以使用一般类型参数.</p><p>模板参数说明的每个类型参数必须在函数定义形参表中至<strong>少出现一次</strong>；</p><p>类模板主要用于<strong>数据存储（容器）类</strong>。<strong>表示和算法</strong>不受所包含的元素类型的影响。</p><p>一个类模板在类层次结构中<br>既可以是基类也可以是派生类：<br>Ø 类模板可以从模板类派生<br>Ø 类模板可以从非模板类派生<br>Ø 模板类可以从类模板派生<br>Ø 非模板类可以从类模板派生</p><h1 id="EasyX-基础"><a href="#EasyX-基础" class="headerlink" title="EasyX 基础"></a>EasyX 基础</h1><ol><li>在项目中创建一个.cpp源文件（右键源文件 -&gt; 添加 -&gt; 新建项 -&gt; 设置文件名 first.cpp）</li></ol><p><img src="/2025/07/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88c%E8%89%B9%EF%BC%89%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/image-20250707160940619.png" alt="image-20250707160940619"></p><h2 id="EasyX-基本概念"><a href="#EasyX-基本概念" class="headerlink" title="EasyX 基本概念"></a>EasyX 基本概念</h2><h3 id="绘图窗口与设备"><a href="#绘图窗口与设备" class="headerlink" title="绘图窗口与设备"></a>绘图窗口与设备</h3><p>initgraph 函数用于<strong>初始化绘图窗口</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">initgraph</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flag = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例1：创建禁用最小化和关闭按钮的绘图窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(800, 600, EX_NOMINIMIZE | EX_NOCLOSE);</span><br></pre></td></tr></table></figure><p>示例2：窗口开启 EX_SHOWCONSOLE 模式，可以进行代码调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(800, 600, EX_SHOWCONSOLE);// 带控制台的图形窗口</span><br></pre></td></tr></table></figure><p>在 EasyX 中，<strong>设备</strong>分两种，一种是默认的<strong>绘图窗口</strong>，另一种是 <strong>IMAGE 对象</strong>。</p><p>通过 SetWorkingImage 函数可以设置当前用于绘图的设备。设置当前用于绘图的设备后，所有的绘图函数都会绘制在该设备上。</p><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>在 EasyX 中，坐标分两种：<strong>物理坐标和逻辑坐标</strong>。</p><ul><li><strong>物理坐标</strong></li></ul><p>物理坐标是描述设备的坐标体系。</p><p><strong>坐标原点在设备的左上角，X 轴向右为正，Y 轴向下为正(特点)，度量单位是像素（Pixel）。</strong></p><p>坐标原点、坐标轴方向、缩放比例都不能改变。</p><ul><li><strong>逻辑坐标</strong></li></ul><p>逻辑坐标是在程序中<strong>用于绘图的</strong>坐标体系。</p><p><strong>坐标默认的原点在窗口的左上角，X 轴向右为正，Y 轴向下为正，度量单位是点。</strong></p><p>默认情况下，逻辑坐标<strong>与物理坐标是一一对应</strong>的，<strong>一个逻辑点等于一个物理像素</strong>。</p><p><strong>在 EasyX 中，凡是没有特殊注明的坐标，均指逻辑坐标。</strong></p><p><strong>坐标相关函数</strong></p><div class="table-container"><table><thead><tr><th>函数用法</th><th>函数说明</th></tr></thead><tbody><tr><td>void <strong>setorigin</strong> ( int x, int y )</td><td>用于设置坐标原点。</td></tr><tr><td>void <strong>setaspectratio</strong> ( float xasp, float yasp )</td><td>通过设置 x 和 y 方向上的<strong>缩放因子</strong>，从而<strong>修改绘图的缩放比例或坐标轴方向</strong>。</td></tr></tbody></table></div><p>范例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">initgraph(600, 600);</span><br><span class="line">setorigin(300, 300);// 将绘图窗口的中心点作为坐标原点 </span><br><span class="line">circle(0, 0, 100);</span><br><span class="line">setorigin(0, 0);// 将绘图窗口的左上角作为坐标原点</span><br><span class="line">setaspectratio(2, 1);// x轴方向的缩放因子为2，y轴方向的缩放因子为1(默认值)</span><br><span class="line">circle(100, 100, 100);</span><br><span class="line">setorigin(0, 600);// 将绘图窗口的左下角作为坐标原点</span><br><span class="line">setaspectratio(1, -1);// 缩放因子为负数，可以实现坐标轴的翻转，此行可使y轴向上为正</span><br><span class="line">circle(100, 100, 100);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">closegraph();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>EasyX 使用 24bit 真彩色，有四种表示颜色的方法：<a href="https://docs.easyx.cn/zh-cn/color，通过">https://docs.easyx.cn/zh-cn/color，通过</a> <strong>setlinecolor</strong> 函数可以设置线条颜色</p><ol><li><p>用<strong>预定义常量</strong>表示颜色（ 常量名要大写 ）</p></li><li><p>用<strong>16进制数字表示颜色（ 0xBBGGRR ）</strong>，注意<strong>颜色的顺序与RGB宏相反</strong></p></li><li><p>用 <strong>RGB 宏合成颜色（ RGB(RRGGBB) ）</strong></p></li><li><p>用 HSLtoRGB、HSVtoRGB 转换其他色彩模型到 RGB 颜色</p></li></ol><p>范例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">initgraph(800, 600);</span><br><span class="line">setfillcolor(BLUE);// 用预定义常量表示颜色</span><br><span class="line">solidcircle(100, 200, 100);</span><br><span class="line">setfillcolor(0xaa0000);// 用16进制数字表示颜色</span><br><span class="line">solidcircle(300, 200, 100);</span><br><span class="line">setfillcolor(RGB(0, 0, 170));// 用RGB宏合成颜色</span><br><span class="line">solidcircle(500, 200, 100);</span><br><span class="line">setfillcolor(HSLtoRGB(240, 1, 0.33));// 用 HSLtoRGB、HSVtoRGB 转换其他色彩模型到 RGB 颜色</span><br><span class="line">solidcircle(700, 200, 100);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">closegraph();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EasyX-图形绘制函数（33个）"><a href="#EasyX-图形绘制函数（33个）" class="headerlink" title="EasyX 图形绘制函数（33个）"></a>EasyX 图形绘制函数（33个）</h2><p><a href="https://docs.easyx.cn/zh-cn/drawing-func">https://docs.easyx.cn/zh-cn/drawing-func</a>    </p><div class="table-container"><table><thead><tr><th style="text-align:left">函数用法</th><th>函数说明</th></tr></thead><tbody><tr><td style="text-align:left">void <strong>circle</strong> ( int x, int y, int radius )</td><td>画无填充的圆</td></tr><tr><td style="text-align:left">fillcircle</td><td>画有边框的填充圆</td></tr><tr><td style="text-align:left">solidcircle</td><td>画无边框的填充圆</td></tr><tr><td style="text-align:left">clearcircle</td><td>用当前背景色清空圆形区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>ellipse</strong> ( int left, int top, int right, int bottom )</td><td>画无填充的椭圆</td></tr><tr><td style="text-align:left">fillellipse</td><td>画有边框的填充椭圆</td></tr><tr><td style="text-align:left">solidellipse</td><td>画无边框的填充椭圆</td></tr><tr><td style="text-align:left">clearellipse</td><td>用当前背景色清空椭圆区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>pie</strong> ( int left, int top, int right, int bottom, double stangle, double endangle );</td><td>画无填充的扇形</td></tr><tr><td style="text-align:left">fillpie</td><td>画有边框的填充扇形</td></tr><tr><td style="text-align:left">solidpie</td><td>画无边框的填充扇形</td></tr><tr><td style="text-align:left">clearpie</td><td>用当前背景色清空扇形区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>rectangle</strong> ( int left, int top, int right, int bottom )</td><td>画无填充的矩形</td></tr><tr><td style="text-align:left">fillrectangle</td><td>画有边框的填充矩形</td></tr><tr><td style="text-align:left">solidrectangle</td><td>画无边框的填充矩形</td></tr><tr><td style="text-align:left">clearrectangle</td><td>用当前背景色清空矩形区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>roundrect</strong> ( int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight )</td><td>画无填充的圆角矩形</td></tr><tr><td style="text-align:left">fillroundrect</td><td>画有边框的填充圆角矩形</td></tr><tr><td style="text-align:left">solidroundrect</td><td>画无边框的填充圆角矩形</td></tr><tr><td style="text-align:left">clearroundrect</td><td>用当前背景色清空圆角矩形区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>polygon</strong> ( const POINT *points, int num );</td><td>画无填充的多边形</td></tr><tr><td style="text-align:left">fillpolygon</td><td>画有边框的填充多边形</td></tr><tr><td style="text-align:left">solidpolygon</td><td>画无边框的填充多边形</td></tr><tr><td style="text-align:left">clearpolygon</td><td>用当前背景色清空多边形区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>putpixel</strong> ( int x, int y, COLORREF color )</td><td>画点</td></tr><tr><td style="text-align:left">void <strong>line</strong> ( int x1, int y1, int x2, int y2 )</td><td>画直线</td></tr><tr><td style="text-align:left">void <strong>arc</strong> ( int left, int top, int right, int bottom, double stangle, double endangle )</td><td>画椭圆弧</td></tr><tr><td style="text-align:left">void <strong>polyline</strong> ( const POINT *points, int num )</td><td>画多条连续的直线</td></tr><tr><td style="text-align:left">void <strong>polybezier</strong> ( const POINT *points, int num )</td><td>画三次方贝塞尔曲线</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">void <strong>floodfill</strong> ( int x, int y, COLORREF color, int filltype = FLOODFILLBORDER )</td><td>填充区域</td></tr><tr><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">COLORREF <strong>getpixel</strong> ( int x, int y )</td><td>获取坐标点的颜色</td></tr><tr><td style="text-align:left">int <strong>getwidth</strong> ( )</td><td>获取绘图区的宽度</td></tr><tr><td style="text-align:left">int <strong>getheight</strong> ( )</td><td>获取绘图区的高度</td></tr></tbody></table></div><h2 id="双缓冲绘图"><a href="#双缓冲绘图" class="headerlink" title="双缓冲绘图"></a>双缓冲绘图</h2><p>双缓冲绘图通过在内存中创建一个与屏幕绘图区域<strong>一致的对象</strong>，先将图形绘制到<strong>内存中的这个对象上</strong>，再<strong>一次性将这个对象上的图形拷贝</strong>到屏幕上，从而<strong>减少对屏幕的直接绘图操作</strong>，<strong>提高绘图效率、消除屏幕闪烁</strong>，广泛应用于游戏开发、图形界面等领域。</p><div class="table-container"><table><thead><tr><th>函数用法</th><th>函数说明</th></tr></thead><tbody><tr><td>void <strong>BeginBatchDraw</strong> ()</td><td>开始批量绘图</td></tr><tr><td>void <strong>EndBatchDraw</strong> ()<br>void <strong>EndBatchDraw</strong> ( int left, int top, int right, int bottom )    // 指定区域</td><td>结束批量绘制，并执行（指定区域内）未完成的绘制任务</td></tr><tr><td>void <strong>FlushBatchDraw</strong> ()<br>void <strong>FlushBatchDraw</strong> ( int left, int top, int right, int bottom )    // 指定区域</td><td>执行（指定区域内）未完成的绘制任务</td></tr></tbody></table></div><p><a href="https://docs.easyx.cn/zh-cn/other-func">https://docs.easyx.cn/zh-cn/other-func</a></p><p><strong>自动移动的圆（帧数控制）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//include &lt;windows.h&gt;</span><br><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">initgraph(640, 480);</span><br><span class="line">BeginBatchDraw();</span><br><span class="line"></span><br><span class="line">setlinecolor(WHITE);</span><br><span class="line">setfillcolor(RED);</span><br><span class="line">for (int i = 50; i &lt; 600; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD beginTime = GetTickCount();// 记录循环开始时间</span><br><span class="line"></span><br><span class="line">cleardevice();</span><br><span class="line">circle(i, 100, 40);</span><br><span class="line">floodfill(i, 100, WHITE);</span><br><span class="line">FlushBatchDraw();</span><br><span class="line"></span><br><span class="line">DWORD endTime = GetTickCount();// 记录循环结束时间</span><br><span class="line">DWORD elapsedTime = endTime - beginTime;// 计算循环耗时</span><br><span class="line">if (elapsedTime &lt; 1000 / 60)// 按每秒60帧进行补时</span><br><span class="line">Sleep(1000 / 60 - elapsedTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EndBatchDraw();</span><br><span class="line">closegraph();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GetTickCount</strong> 是一个 Windows 系统函数，用于<strong>获取从操作系统启动以来所经过的毫秒数</strong>，通过在代码中的不同位置调用该函数，并计算两次调用之间的差值，可以得知某段代码或某个操作的执行时间。</p><p>注：GetTickCount 的值会在系统启动后约49.7天（(2^32-1) ms）后回绕到0，这是因为其返回值是一个32位无符号整数，<strong>可以使用 GetTickCount64 代替，需添加 windows.h 头文件。</strong></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h1 id="EasyX-进阶"><a href="#EasyX-进阶" class="headerlink" title="EasyX 进阶"></a>EasyX 进阶</h1><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p><a href="https://docs.easyx.cn/zh-cn/image-func">https://docs.easyx.cn/zh-cn/image-func</a></p><div class="table-container"><table><thead><tr><th>函数用法</th><th>函数说明</th></tr></thead><tbody><tr><td>void <strong>loadimage</strong> (<br>    IMAGE* pDstImg,    // 保存图像的 IMAGE 对象指针<br>    LPCTSTR pImgFile,   // 图片文件名<br>    int nWidth = 0,          // 图片的拉伸宽度<br>    int nHeight = 0,         // 图片的拉伸高度<br>    bool bResize = false //是否调整IMAGE的大小以适应图片<br>)</td><td>从文件中读取图像。如果pDstImg为NULL，则读取到绘图窗口</td></tr><tr><td>void <strong>putimage</strong> (<br>    int dstX,                    // 绘制位置的 x 坐标<br>    int dstY,                    // 绘制位置的 y 坐标<br>    IMAGE *pSrcImg,    // 要绘制的 IMAGE 对象指针<br>    DWORD dwRop = SRCCOPY    // 三元光栅操作码<br>);</td><td>在当前设备上绘制指定图像</td></tr><tr><td>void <strong>putimage</strong> (<br>    int dstX,                    // 绘制位置的 x 坐标<br>    int dstY,                    // 绘制位置的 y 坐标<br>    int dstWidth,            // 绘制的宽度 <br>    int dstHeight,           // 绘制的高度<br>    IMAGE *pSrcImg,    // 要绘制的 IMAGE 对象指针<br>    int srcX,  // 绘制内容在 IMAGE 对象中的左上角 x 坐标<br>    int srcY,  // 绘制内容在 IMAGE 对象中的左上角 y 坐标 <br>    DWORD dwRop = SRCCOPY    // 三元光栅操作码<br>)</td><td>在当前设备上绘制指定图像（指定宽高和起始位置）</td></tr><tr><td>void <strong>Resize</strong> ( IMAGE* pImg, int width, int height )</td><td>调整指定绘图设备的尺寸，pImg 如果为 NULL 表示默认绘图窗口</td></tr><tr><td>void <strong>rotateimage</strong> (<br>    IMAGE <em>dstimg,<br>    IMAGE </em>srcimg,<br>    double radian,<br>    COLORREF bkcolor = BLACK,<br>    bool autosize = false,<br>    bool highquality = true<br>)</td><td>旋转 IMAGE 中的绘图内容</td></tr><tr><td>void <strong>saveimage</strong> (<br>    LPCTSTR strFileName,<br>    IMAGE* pImg = NULL<br>)</td><td>保存绘图内容至图片文件，支持 bmp / gif / jpg / png / tif 格式</td></tr><tr><td>void <strong>SetWorkingImage</strong> ( IMAGE* pImg = NULL )</td><td>设定当前的绘图设备，如果参数为 NULL，表示绘图设备为默认绘图窗口</td></tr><tr><td>IMAGE<em> <em>*GetWorkingImage </em></em>()</td><td>获取当前的绘图设备，如果返回值为 NULL，表示当前绘图设备为绘图窗口</td></tr><tr><td>void <strong>getimage</strong> (<br>    IMAGE* pDstImg,   // 保存图像的 IMAGE 对象指针<br>    int srcX,               // 要获取图像区域左上角 x 坐标<br>    int srcY,               // 要获取图像区域的左上角 y 坐标<br>    int srcWidth,      // 要获取图像区域的宽度<br>    int srcHeight     // 要获取图像区域的高度<br>)</td><td>从当前绘图设备中获取图像</td></tr><tr><td>DWORD<em> <strong>GetImageBuffer</strong> ( IMAGE</em> pImg = NULL )</td><td>获取绘图设备的显示缓冲区指针，pImg 如果为 NULL，表示默认的绘图窗口</td></tr><tr><td>HDC <strong>GetImageHDC</strong> ( IMAGE* pImg = NULL )</td><td>获取绘图设备句柄(HDC)</td></tr></tbody></table></div><h3 id="IMAGE-类"><a href="#IMAGE-类" class="headerlink" title="IMAGE 类"></a><strong>IMAGE 类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">IMAGE</span><span class="params">(<span class="type">int</span> width = <span class="number">0</span>, <span class="type">int</span> height = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">公有成员</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getwidth</span><span class="params">()</span></span>;</span><br><span class="line">返回 IMAGE 对象的宽度，以像素为单位。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">()</span></span>;</span><br><span class="line">返回 IMAGE 对象的高度，以像素为单位。</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> =</span><br><span class="line">实现IMAGE对象的直接赋值。该操作仅拷贝源图像的内容，不拷贝源图像的绘图环境。</span><br></pre></td></tr></table></figure><p>在内存中保存图像信息。</p><h3 id="loadimage-函数"><a href="#loadimage-函数" class="headerlink" title="loadimage 函数"></a>loadimage 函数</h3><p>范例1：loadimage <strong>直接读取图片至绘图窗口</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1400</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">loadimage</span>(<span class="literal">NULL</span>, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));<span class="comment">// 第一个参数为NULL时，直接读取图片至绘图窗口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：修改窗口大小，可以显示图片部分内容，但<strong>只能从绘图窗口的坐标原点（左上角）开始显示</strong>图片</p><p>范例2：loadimage 直接读取图片至绘图窗口并进行图片或窗口缩放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">700</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">loadimage</span>(<span class="literal">NULL</span>, _T(<span class="string">&quot;image\\background.jpg&quot;</span>), <span class="number">700</span>, <span class="number">300</span>, <span class="literal">false</span>);<span class="comment">// 将图像缩放为700*300在绘图窗口显示</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注1：图片缩放后的尺寸<strong>小于</strong>窗口尺寸，则窗口会有<strong>黑边</strong>；若<strong>大于</strong>窗口尺寸，则图片<strong>显示不全</strong></p><p>注2：<strong>第五个参数若为 true，则会调整窗口以适应图片的大小</strong></p><p>注3：从磁盘中<strong>读取大量图片显示</strong>的情况下，使用 loadimage 直接读取图片至绘图窗口<strong>性能较差</strong></p><p>范例3：loadimage 读取本地图片文件，输出图片宽度和高度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">initgraph(1000, 600, SHOWCONSOLE);// 初始化绘图窗口并开启终端</span><br><span class="line"></span><br><span class="line">IMAGE img;// 定义图像对象</span><br><span class="line">loadimage(&amp;img, _T(&quot;image\\background.jpg&quot;));// 读取本地图片文件，存入图像对象</span><br><span class="line">printf(&quot;width=%d, height=%d \n&quot;, img.getwidth(), img.getheight());// 输出图像宽度和高度</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">closegraph();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本例中的图片内容<strong>不会在窗口内显示</strong></p><h3 id="putimage-函数"><a href="#putimage-函数" class="headerlink" title="putimage 函数"></a>putimage 函数</h3><p>范例1：putimage <strong>在绘图窗口显示图像</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);<span class="comment">// 将IMAGE对象显示在绘图窗口的坐标（0,0）处</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例2：putimage 截取图像部分内容进行显示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">900</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">900</span>, <span class="number">600</span>, &amp;img, <span class="number">115</span>, <span class="number">0</span>);<span class="comment">// 从图像的(115,0)坐标处截取宽900、高600的部分内容显示在窗口(0,0)处</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例3：putimage 三元光栅操作码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img, NOTSRCCOPY);<span class="comment">// 第四个参数是三元光栅操作码</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：putimage 第四个参数是 <strong>三元光栅操作码</strong> ，它定义了<strong>源图像与目标图像的位合并形式</strong>，默认值为 <strong>SRCCOPY</strong> 详见</p><p><a href="https://docs.easyx.cn/zh-cn/putimage">https://docs.easyx.cn/zh-cn/putimage</a></p><h4 id="透明贴图"><a href="#透明贴图" class="headerlink" title="透明贴图"></a>透明贴图</h4><p>范例1：通过PS制作<strong>原图</strong>的<strong>掩码图</strong>和<strong>前景图</strong>，再进行三元光栅操作叠加而成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IMAGE imgGuoqi, imgGuohui, imgGuohuiMask, imgGuohuiFg;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgGuoqi, _T(<span class="string">&quot;image\\guoqi.jpg&quot;</span>), <span class="number">1000</span>, <span class="number">600</span>);<span class="comment">// 加载国旗（背景图）</span></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgGuohui, _T(<span class="string">&quot;image\\guohui.jpg&quot;</span>), <span class="number">200</span>, <span class="number">200</span>);<span class="comment">// 加载国徽原图（白色周边）</span></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgGuohuiMask, _T(<span class="string">&quot;image\\guohui_mask.jpg&quot;</span>), <span class="number">200</span>, <span class="number">200</span>);<span class="comment">// 加载国徽掩码图（白色周边+黑色内容）</span></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgGuohuiFg, _T(<span class="string">&quot;image\\guohui_fg.jpg&quot;</span>), <span class="number">200</span>, <span class="number">200</span>);<span class="comment">// 加载国徽前景图（黑色周边+待显示内容）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuoqi);<span class="comment">// 显示国旗</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuohui);<span class="comment">// 显示国徽原图</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">200</span>, &amp;imgGuohuiMask);<span class="comment">// 显示国徽掩码图</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">400</span>, &amp;imgGuohuiFg);<span class="comment">// 显示国徽前景图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 透明贴图</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">200</span>, <span class="number">0</span>, &amp;imgGuohuiMask, SRCAND);<span class="comment">// 显示掩码图（SRCAND：按位与）</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">200</span>, <span class="number">0</span>, &amp;imgGuohuiFg, SRCPAINT);<span class="comment">// 显示前景图（SRCPAINT：按位或）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例2：TransparentBlt 函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;MSIMG32.LIB&quot;</span>)<span class="comment">// 链接器在链接过程中包含指定的库文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(IMAGE* dstImg, <span class="type">int</span> x, <span class="type">int</span> y, IMAGE* srcImg, UINT transparentColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HDC dstDC = <span class="built_in">GetImageHDC</span>(dstImg);</span><br><span class="line">HDC srcDC = <span class="built_in">GetImageHDC</span>(srcImg);</span><br><span class="line"><span class="type">int</span> w = srcImg-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line"><span class="type">int</span> h = srcImg-&gt;<span class="built_in">getheight</span>();</span><br><span class="line"><span class="built_in">TransparentBlt</span>(dstDC, x, y, w, h, srcDC, <span class="number">0</span>, <span class="number">0</span>, w, h, transparentColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line">IMAGE imgGuoqi, imgBaidu;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgGuoqi, _T(<span class="string">&quot;image\\guoqi.jpg&quot;</span>), <span class="number">1000</span>, <span class="number">600</span>);<span class="comment">// 加载国旗（背景图）</span></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgBaidu, _T(<span class="string">&quot;image\\baidu.png&quot;</span>));<span class="comment">// 加载百度LOGO（PNG格式）</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuoqi);<span class="comment">// 显示国旗</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBaidu);<span class="comment">// 显示百度LOGO</span></span><br><span class="line"><span class="built_in">putimage_alpha</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">300</span>, &amp;imgBaidu, BLACK);<span class="comment">// 显示百度LOGO（透明贴图）</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransparentBlt 是 Windows GDI（Graphics Device Interface）中的一个函数，用于在绘制位图时支持透明效果。</p><p>函数说明：第1个参数为目标设备，第2、3个参数是输出目标矩形左上角坐标，第4、5个参数是目标矩形的宽和高，参数6-10与1-5类似，第11个参数是<strong>透明底色</strong>（若图片是透明图片，默认为BLACK）</p><p><strong>注：此方法只支持 PNG 格式的图片</strong></p><p>范例3：AlphaBlend 函数实现（<strong>推荐</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;MSIMG32.LIB&quot;</span>)<span class="comment">// 链接器在链接过程中包含指定的库文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line"><span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line"><span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h, <span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, &#123; AC_SRC_OVER, <span class="number">0</span>, <span class="number">255</span>, AC_SRC_ALPHA &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">IMAGE imgGuoqi, imgBaidu;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgGuoqi, _T(<span class="string">&quot;image\\guoqi.jpg&quot;</span>), <span class="number">1000</span>, <span class="number">600</span>);<span class="comment">// 加载国旗（背景图）</span></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgBaidu, _T(<span class="string">&quot;image\\baidu.png&quot;</span>));<span class="comment">// 加载百度LOGO（PNG格式）</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgGuoqi);<span class="comment">// 显示国旗</span></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBaidu);<span class="comment">// 显示百度LOGO</span></span><br><span class="line"><span class="built_in">putimage_alpha</span>(<span class="number">0</span>, <span class="number">300</span>, &amp;imgBaidu);<span class="comment">// 显示百度LOGO（透明贴图）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AlphaBlend 是 Windows GDI 中用于实现 <strong>Alpha 混合（透明/半透明）</strong> 绘制的函数，比 TransparentBlt 更强大，支持 <strong>逐像素透明度（Alpha 通道）</strong> 和 <strong>整体透明度（全局 Alpha）</strong>。</p><p><strong>注：此方法只支持 PNG 格式的图片</strong></p><h4 id="图片动画"><a href="#图片动画" class="headerlink" title="图片动画"></a>图片动画</h4><p>图片动画的核心是<strong>一系列静态的图像（动画帧）</strong>。每一帧都是一张静态的图片，但它们之间略有不同，通常表现为物体的位置、形状或颜色的微小变化。这些帧按照特定的顺序排列，并以一定的速度连续播放，使得观者感受到运动的效果。</p><p>范例：角色动画</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;MSIMG32.LIB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_WIDTH = <span class="number">1000</span>;<span class="comment">//窗口宽度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_HEIGHT = <span class="number">600</span>;<span class="comment">//窗口高度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRAME = <span class="number">60</span>;<span class="comment">//帧数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INTERVAL_MS = <span class="number">15</span>;<span class="comment">//动画帧间隔</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> IMAGE_NUM = <span class="number">13</span>;<span class="comment">//动画图片数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示透明图片</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line"><span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line"><span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h, <span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, &#123; AC_SRC_OVER, <span class="number">0</span>, <span class="number">255</span>, AC_SRC_ALPHA &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;<span class="comment">//主循环控制</span></span><br><span class="line">ExMessage msg;<span class="comment">//键鼠消息</span></span><br><span class="line">IMAGE imgBackground;<span class="comment">//背景图片对象</span></span><br><span class="line">IMAGE imgPEA[<span class="number">13</span>];<span class="comment">//玩家动画图片</span></span><br><span class="line">TCHAR imgPath[<span class="number">256</span>];<span class="comment">//动画图片文件路径</span></span><br><span class="line"><span class="type">int</span> imgIndex = <span class="number">0</span>;<span class="comment">//动画帧索引</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> timer = <span class="number">0</span>;<span class="comment">//动画计时器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgBackground, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));<span class="comment">//加载背景图片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IMAGE_NUM; i++)<span class="comment">//加载动画图片</span></span><br><span class="line">&#123;</span><br><span class="line">_stprintf_s(imgPath, _T(<span class="string">&quot;image\\pea\\%d.png&quot;</span>), i + <span class="number">1</span>);<span class="comment">//动画图片路径（格式转换）</span></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;imgPEA[i], imgPath);<span class="comment">//加载动画图片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">initgraph</span>(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//主循环</span></span><br><span class="line"><span class="keyword">while</span> (running)</span><br><span class="line">&#123;</span><br><span class="line">DWORD beginTime = <span class="built_in">GetTickCount</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息处理</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据处理</span></span><br><span class="line">timer += <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (timer &gt; INTERVAL_MS)<span class="comment">//定时器超过预定的时间间隔时切换下一张图片</span></span><br><span class="line">&#123;</span><br><span class="line">imgIndex = (imgIndex + <span class="number">1</span>) % IMAGE_NUM;<span class="comment">//循环切换图片：索引值0-12</span></span><br><span class="line">timer = <span class="number">0</span>;<span class="comment">//重置计时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘图</span></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;imgBackground);<span class="comment">//绘制背景图片</span></span><br><span class="line"><span class="built_in">putimage_alpha</span>(<span class="number">500</span>, <span class="number">300</span>, &amp;imgPEA[imgIndex]);<span class="comment">//绘制豌豆图片</span></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//帧延时处理</span></span><br><span class="line">DWORD endTime = <span class="built_in">GetTickCount</span>();</span><br><span class="line">DWORD elapsedTime = endTime - beginTime;</span><br><span class="line"><span class="keyword">if</span> (elapsedTime &lt; <span class="number">1000</span> / FRAME)</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span> / FRAME - elapsedTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Resize-函数"><a href="#Resize-函数" class="headerlink" title="Resize 函数"></a>Resize 函数</h3><h3 id="GetImageBuffer-函数"><a href="#GetImageBuffer-函数" class="headerlink" title="GetImageBuffer 函数"></a>GetImageBuffer 函数</h3><p>范例1：GetImageBuffer 通过<strong>直接操作显示缓冲区绘制渐变的蓝色</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">DWORD* pMem = <span class="built_in">GetImageBuffer</span>();<span class="comment">// 获取当前窗口所指图像缓冲区的指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">600</span> * <span class="number">400</span>; i++)</span><br><span class="line">pMem[i] = <span class="built_in">BGR</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">0</span>, i * <span class="number">256</span> / (<span class="number">600</span> * <span class="number">400</span>)));<span class="comment">// 直接对图像缓冲区每个坐标像素赋值（颜色）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例2：图像翻转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip_image</span><span class="params">(IMAGE* srcImg, IMAGE* dstImg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w = srcImg-&gt;<span class="built_in">getwidth</span>();<span class="comment">// 获取源图像宽度</span></span><br><span class="line"><span class="type">int</span> h = srcImg-&gt;<span class="built_in">getheight</span>();<span class="comment">// 获取源图像高度</span></span><br><span class="line"><span class="built_in">Resize</span>(dstImg, w, h);<span class="comment">// 设置目标图像与源图像宽高一致</span></span><br><span class="line">DWORD* src_buffer = <span class="built_in">GetImageBuffer</span>(srcImg);<span class="comment">// 获取源图像缓冲区指针</span></span><br><span class="line">DWORD* dst_buffer = <span class="built_in">GetImageBuffer</span>(dstImg);<span class="comment">// 获取目标图像缓冲区指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> idx_src = y * w + x;</span><br><span class="line"><span class="type">int</span> idx_dst = y * w + (w - x - <span class="number">1</span>);</span><br><span class="line">dst_buffer[idx_dst] = src_buffer[idx_src];<span class="comment">// 交换对应坐标像素的颜色值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1400</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">IMAGE img1, img2;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img1, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));</span><br><span class="line"><span class="built_in">flip_image</span>(&amp;img1, &amp;img2);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p><a href="https://docs.easyx.cn/zh-cn/msg-func">https://docs.easyx.cn/zh-cn/msg-func</a></p><p><strong>消息缓冲区</strong>可以<strong>缓冲 63 个未处理的消息</strong>。每次获取消息时，将从消息缓冲区<strong>取出一个最早发生的</strong>消息。</p><div class="table-container"><table><thead><tr><th>函数用法</th><th>函数说明</th></tr></thead><tbody><tr><td>ExMessage <strong>getmessage</strong> ( BYTE filter = -1 )<br>void <strong>getmessage</strong> ( ExMessage *msg, BYTE filter = -1 )</td><td>从消息缓冲区获取一个消息。如果缓冲区中没有消息，则程序会一直等待（阻塞式）</td></tr><tr><td>bool <strong>peekmessage</strong> ( ExMessage *msg, BYTE filter = -1, bool removemsg = true)</td><td>从消息缓冲区获取一个消息，并立即返回</td></tr><tr><td>void <strong>flushmessage</strong> ( BYTE filter = -1 )</td><td>清空消息缓冲区</td></tr></tbody></table></div><p><strong>参数说明：</strong></p><ul><li><strong>msg</strong>：指向消息结构体 ExMessage 的指针，用来保存获取到的消息。</li><li><strong>filter</strong>：指定要获取的消息范围，默认 -1 获取所有类别的消息。可以用以下值或值的组合获取指定类别的消息</li></ul><div class="table-container"><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>EX_MOUSE</td><td><strong>鼠标</strong>消息。</td></tr><tr><td>EX_KEY</td><td><strong>按键</strong>消息。</td></tr><tr><td>EX_CHAR</td><td>字符消息。</td></tr><tr><td>EX_WINDOW</td><td><strong>窗口</strong>消息。</td></tr></tbody></table></div><ul><li><strong>removemsg</strong>：在 peekmessage 处理完消息后，<strong>是否将其从消息队列中移除。</strong></li></ul><h3 id="ExMessage-结构体"><a href="#ExMessage-结构体" class="headerlink" title="ExMessage 结构体"></a><strong>ExMessage 结构体</strong></h3><p><a href="https://docs.easyx.cn/zh-cn/exmessage">https://docs.easyx.cn/zh-cn/exmessage</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct ExMessage</span><br><span class="line">&#123;</span><br><span class="line">USHORT message;// 消息标识</span><br><span class="line">union</span><br><span class="line">&#123;</span><br><span class="line">// 鼠标消息的数据</span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">bool ctrl:1;// Ctrl 键是否按下</span><br><span class="line">bool shift:1;// Shift 键是否按下</span><br><span class="line">bool lbutton:1;// 鼠标左键是否按下</span><br><span class="line">bool mbutton:1;// 鼠标中键是否按下</span><br><span class="line">bool rbutton:1;// 鼠标右键</span><br><span class="line">short x;// 鼠标的 x 坐标</span><br><span class="line">short y;// 鼠标的 y 坐标</span><br><span class="line">short wheel;// 鼠标滚轮滚动值，为 120 的倍数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 按键消息的数据</span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">BYTE vkcode;// 按键的虚拟键码</span><br><span class="line">BYTE scancode;// 按键的扫描码（依赖于 OEM）</span><br><span class="line">bool extended:1;// 按键是否是扩展键</span><br><span class="line">bool prevdown:1;// 按键的前一个状态是否按下</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 字符消息的数据</span><br><span class="line">TCHAR ch;</span><br><span class="line"></span><br><span class="line">// 窗口消息的数据</span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">WPARAM wParam;</span><br><span class="line">LPARAM lParam;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>message</strong> ：可以分为四大类：<strong>EX_MOUSE</strong>（鼠标11项）、<strong>EX_KEY</strong>（键盘2项）、<strong>EX_CHAR</strong>（字符1项）、<strong>EX_WINDOW</strong>（窗口3项）</p><p><strong>union</strong> ：共用体中存储具体消息的数据</p><h3 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h3><p>范例：跟随鼠标移动的圆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> posX;</span><br><span class="line"><span class="type">int</span> posY;</span><br><span class="line"><span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Ball</span>(<span class="type">int</span> x = <span class="number">100</span>, <span class="type">int</span> y=<span class="number">100</span>, <span class="type">int</span> r=<span class="number">50</span>) : <span class="built_in">posX</span>(x), <span class="built_in">posY</span>(y), <span class="built_in">radius</span>(r) &#123;&#125;<span class="comment">// 构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> posX; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> posY; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; posX = x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123; posY = y; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123; radius = r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;<span class="comment">// 主循环控制参数</span></span><br><span class="line">ExMessage msg;<span class="comment">// 消息对象</span></span><br><span class="line"><span class="function">Ball <span class="title">ball</span><span class="params">(<span class="number">400</span>, <span class="number">300</span>, <span class="number">50</span>)</span></span>;<span class="comment">// 待绘制对象</span></span><br><span class="line"><span class="comment">//Ball ball;</span></span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">800</span>, <span class="number">600</span>);<span class="comment">// 初始化绘图窗口</span></span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();<span class="comment">// 开启批量绘图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主循环</span></span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line"><span class="comment">// 消息处理</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg)) &#123;</span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_MOUSEMOVE) &#123;<span class="comment">// 圆的位置随鼠标位置变化</span></span><br><span class="line">ball.<span class="built_in">setX</span>(msg.x);</span><br><span class="line">ball.<span class="built_in">setY</span>(msg.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_LBUTTONDOWN) &#123;<span class="comment">// 左键按下圆变红色</span></span><br><span class="line"><span class="built_in">setfillcolor</span>(RED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_LBUTTONUP) &#123;<span class="comment">// 左键松开圆变白色</span></span><br><span class="line"><span class="built_in">setfillcolor</span>(WHITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_RBUTTONDOWN) &#123;<span class="comment">// 右键按下结束主循环</span></span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘图</span></span><br><span class="line"><span class="built_in">cleardevice</span>();<span class="comment">// 清除屏幕</span></span><br><span class="line"><span class="built_in">solidcircle</span>(ball.<span class="built_in">getX</span>(), ball.<span class="built_in">getY</span>(), ball.<span class="built_in">getRadius</span>());<span class="comment">// 绘制当前帧内容</span></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();<span class="comment">// 刷新批量绘图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();<span class="comment">// 关闭批量绘图</span></span><br><span class="line"><span class="built_in">closegraph</span>();<span class="comment">// 关闭绘图窗口</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h3><p>范例1：用键盘控制小球</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用结构体封装小球属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Ball</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;<span class="comment">// 小球圆心坐标x</span></span><br><span class="line"><span class="type">int</span> y;<span class="comment">// 小球圆心坐标y</span></span><br><span class="line"><span class="type">int</span> r;<span class="comment">// 小球半径</span></span><br><span class="line"><span class="type">int</span> dx;<span class="comment">// 小球在x轴方向移动的增量</span></span><br><span class="line"><span class="type">int</span> dy;<span class="comment">// 小球在y轴方向移动的增量</span></span><br><span class="line">COLORREF color;<span class="comment">// 小球颜色</span></span><br><span class="line">&#125; Ball;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">ExMessage msg;</span><br><span class="line">Ball ball = &#123; <span class="number">300</span>, <span class="number">300</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, YELLOW &#125;;<span class="comment">// 创建小球并初始化</span></span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (running)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_KEYDOWN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg.vkcode)<span class="comment">// 判断虚拟键代码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:<span class="comment">// 上键：小球Y坐标减少</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_UP:</span><br><span class="line">ball.y -= ball.dy;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_DOWN:<span class="comment">// 下键：小球Y坐标增加</span></span><br><span class="line">ball.y += ball.dy;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_LEFT:<span class="comment">// 右键：小球X坐标减少</span></span><br><span class="line">ball.x -= ball.dx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_RIGHT:<span class="comment">// 右键：小球X坐标增加</span></span><br><span class="line">ball.x += ball.dx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> VK_ESCAPE:<span class="comment">// ESC键：结束主循环</span></span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cleardevice</span>();<span class="comment">// 清除屏幕</span></span><br><span class="line"><span class="built_in">setfillcolor</span>(ball.color);<span class="comment">// 设置填充颜色</span></span><br><span class="line"><span class="built_in">solidcircle</span>(ball.x, ball.y, ball.r);<span class="comment">// 绘制无边框填充圆;</span></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟键代码 <a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes</a></p><p><strong>优化后</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN_WIDTH 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN_HEIGHT 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用结构体封装小球属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Ball</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;<span class="comment">// 小球圆心坐标x</span></span><br><span class="line"><span class="type">int</span> y;<span class="comment">// 小球圆心坐标y</span></span><br><span class="line"><span class="type">int</span> r;<span class="comment">// 小球半径</span></span><br><span class="line"><span class="type">int</span> dx;<span class="comment">// 小球在x轴方向移动的增量</span></span><br><span class="line"><span class="type">int</span> dy;<span class="comment">// 小球在y轴方向移动的增量</span></span><br><span class="line">COLORREF color;<span class="comment">// 小球颜色</span></span><br><span class="line"><span class="type">bool</span> isMoveUp = <span class="literal">false</span>;<span class="comment">// 小球是否向四个方向移动</span></span><br><span class="line"><span class="type">bool</span> isMoveDown = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> isMoveLeft = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> isMoveRight = <span class="literal">false</span>;</span><br><span class="line">&#125; Ball;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">ExMessage msg;</span><br><span class="line">Ball ball = &#123; <span class="number">300</span>, <span class="number">300</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, YELLOW &#125;;<span class="comment">// 创建小球并初始化</span></span><br><span class="line"><span class="built_in">initgraph</span>(WIN_WIDTH, WIN_HEIGHT);</span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (running)</span><br><span class="line">&#123;</span><br><span class="line">DWORD beginTime = <span class="built_in">GetTickCount</span>();<span class="comment">// 记录循环开始时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息处理</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_KEYDOWN)<span class="comment">// 按下按键处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg.vkcode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_UP:</span><br><span class="line">ball.isMoveUp = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_DOWN:</span><br><span class="line">ball.isMoveDown = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_LEFT:</span><br><span class="line">ball.isMoveLeft = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">ball.isMoveRight = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> VK_ESCAPE:</span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_KEYUP)<span class="comment">// 松开按键处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg.vkcode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_UP:</span><br><span class="line">ball.isMoveUp = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_DOWN:</span><br><span class="line">ball.isMoveDown = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_LEFT:</span><br><span class="line">ball.isMoveLeft = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">ball.isMoveRight = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斜向移动：计算不同方向(包括同时)按下时的速度增量</span></span><br><span class="line"><span class="type">int</span> directX = ball.isMoveRight - ball.isMoveLeft;</span><br><span class="line"><span class="type">int</span> directY = ball.isMoveDown - ball.isMoveUp;</span><br><span class="line"><span class="type">double</span> directXY = <span class="built_in">sqrt</span>(directX * directX + directY * directY);</span><br><span class="line"><span class="keyword">if</span> (directXY != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> factorX = directX / directXY;<span class="comment">//计算X、Y方向的标准化分量</span></span><br><span class="line"><span class="type">double</span> factorY = directY / directXY;</span><br><span class="line">ball.x += (<span class="type">int</span>)ball.dx * factorX;<span class="comment">//小球坐标 = 方向增速 * 方向的标准化分量</span></span><br><span class="line">ball.y += (<span class="type">int</span>)ball.dy * factorY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边缘检测</span></span><br><span class="line"><span class="keyword">if</span> (ball.y - ball.r &lt;= <span class="number">0</span>)<span class="comment">// 上</span></span><br><span class="line">ball.y = ball.r;</span><br><span class="line"><span class="keyword">if</span> (ball.y + ball.r &gt;= WIN_HEIGHT)<span class="comment">// 下</span></span><br><span class="line">ball.y = WIN_HEIGHT - ball.r - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ball.x - ball.r &lt;= <span class="number">0</span>)<span class="comment">// 左</span></span><br><span class="line">ball.x = ball.r;</span><br><span class="line"><span class="keyword">if</span> (ball.x + ball.r &gt;= WIN_WIDTH)<span class="comment">// 右</span></span><br><span class="line">ball.x = WIN_WIDTH - ball.r - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘图</span></span><br><span class="line"><span class="built_in">cleardevice</span>();<span class="comment">// 清除屏幕</span></span><br><span class="line"><span class="built_in">setfillcolor</span>(ball.color);<span class="comment">// 设置填充颜色</span></span><br><span class="line"><span class="built_in">solidcircle</span>(ball.x, ball.y, ball.r);<span class="comment">// 绘制无边框填充圆;</span></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帧延时</span></span><br><span class="line">DWORD endTime = <span class="built_in">GetTickCount</span>();<span class="comment">// 记录循环结束时间</span></span><br><span class="line">DWORD elapsedTime = endTime - beginTime;<span class="comment">// 计算循环耗时</span></span><br><span class="line"><span class="keyword">if</span> (elapsedTime &lt; <span class="number">1000</span> / <span class="number">60</span>)<span class="comment">// 按每秒60帧进行补时</span></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">60</span> - elapsedTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><h3 id="设置窗口标题"><a href="#设置窗口标题" class="headerlink" title="设置窗口标题"></a>设置窗口标题</h3><p>范例：使用 <strong>GetHWnd</strong> 和 <strong>SetWindowText</strong> 函数设置窗口标题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">HWND hWnd = <span class="built_in">GetHWnd</span>();<span class="comment">// 获得窗口句柄</span></span><br><span class="line"><span class="built_in">SetWindowText</span>(hWnd, _T(<span class="string">&quot;植物大战僵尸&quot;</span>));<span class="comment">// 使用 Windows API 修改窗口名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弹窗消息"><a href="#弹窗消息" class="headerlink" title="弹窗消息"></a>弹窗消息</h3><p>在Visual C++（VC）中，MessageBox 函数是一个常用的 Windows API 函数，用于显示一个模态对话框，其中包含文本、标题、图标和按钮等。以下是函数的详细用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageBox</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,           <span class="comment">// 父窗口句柄。如果为NULL，则消息框没有父窗口  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpText,         <span class="comment">// 要显示的消息文本  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCaption,      <span class="comment">// 消息框的标题  </span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT    uType           <span class="comment">// 指定消息框的内容和行为的标志  </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ol><li><strong>hWnd</strong>：指定消息框的父窗口句柄。如果此参数为NULL，则消息框没有父窗口，且作为顶级窗口显示。</li><li><strong>lpText</strong>：要在消息框中显示的文本。</li><li><strong>lpCaption</strong>：消息框的标题。如果此参数为NULL，则默认标题为“Error”。</li><li><strong>uType</strong>：用于指定消息框的内容和行为的标志。这可以是一个或多个以下常量的组合：<ul><li>MB_OK：消息框包含一个“确定”按钮。</li><li>MB_OKCANCEL：消息框包含“确定”和“取消”按钮。</li><li>MB_YESNO：消息框包含“是”和“否”按钮。</li><li>MB_YESNOCANCEL：消息框包含“是”、“否”和“取消”按钮。</li><li>MB_ICONEXCLAMATION、MB_ICONWARNING、MB_ICONINFORMATION、MB_ICONQUESTION、MB_ICONERROR等：用于指定消息框中显示的图标。</li></ul></li></ol><p><strong>返回值</strong></p><p>函数返回一个整数值，表示用户点击的按钮。例如：</p><ul><li><strong>IDOK</strong>：用户点击了“确定”按钮。</li><li><strong>IDCANCEL</strong>：用户点击了“取消”按钮。</li><li><strong>IDYES</strong>：用户点击了“是”按钮。</li><li><strong>IDNO</strong>：用户点击了“否”按钮。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">HWND hWnd = <span class="built_in">GetHWnd</span>();</span><br><span class="line"><span class="built_in">MessageBox</span>(hWnd, _T(<span class="string">&quot;你被僵尸吃掉了！&quot;</span>), _T(<span class="string">&quot;游戏结束&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"></span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在使用 MessageBox 函数之前，需要包含 <strong>windows.h</strong> 头文件（<strong>如果已经包含了 graphics.h 头文件则可以省略</strong>）</p><h3 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h3><p><strong>mciSendString</strong>  是 Windows API 中的一个函数，用于向媒体控制接口（Media Control Interface，MCI）设备发送命令字符串。这个函数常用于控制多媒体设备，如音频和视频播放，支持 MPEG, AVI, WAV, MP3 等多种格式。</p><p>范例：播放背景音乐</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;// 此项在导入graphics.h头文件后可以省略</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;winmm.lib&quot;</span>)<span class="comment">// 加载多媒体静态库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1000</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;open audio\\bg.mp3 alias BGM&quot;</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 打开音乐文件，alias指定别名</span></span><br><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;play BGM repeat&quot;</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 使用别名播放音乐，repeat重复播放</span></span><br><span class="line"></span><br><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img, _T(<span class="string">&quot;image\\background.jpg&quot;</span>));</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进行一个一个算法知识点的复习</title>
      <link href="/2025/04/11/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/04/11/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本篇为方便博主笨比时及时进行算法知识点的一个一个快速回顾</p><h1 id="赛前提醒"><a href="#赛前提醒" class="headerlink" title="赛前提醒"></a>赛前提醒</h1><ul><li><p>能用long long和double就用,记得宏替换endl</p></li><li><p>像什么<strong>从0看</strong>什么<strong>从1看</strong>这样的状态设置,<strong>怎么方便就怎么来(不一定就要统一,但若要输出记得还原)</strong>,但<strong>一定一定要在开做前就区分好了</strong>,再去实现,不然后面会<strong>容易混淆的</strong>.不过,这些<strong>初步设置成啥样也只是实现难度的问题,并不会影响最终结果</strong>的话,就<strong>切忌一直在这方面思考优化</strong>了,既<strong>没啥大用</strong>还有<strong>可能导致自己一直左右手互博而一直浪费不必要的时间</strong>,题目进展却一点没有(</p></li><li><p>真<strong>不要吝啬于多处理几个边界</strong>情况,要求稳,<strong>不用追求一个写法</strong>处理好全局情况(也可能<strong>本来就不能仅一个写法</strong>)</p></li><li><p>稳定心态,减少失误,能得就得,至少能把自己能力范围内的分100%拿到</p></li><li><p>先通看一遍,有个整体把握,<strong>可以边看边把模板写好</strong>.</p></li><li><p>三思而后行(思考对了才好实现),一定要花足够多的时间去读题和构思(花多点时间读题思考肯定<strong>比在一个错误的思路上进行要好</strong>的多!<strong>多一分钟好的思考也许能减少五分钟的码量</strong>)</p><ul><li><p>仔细读题,确保每个字眼都读到读懂,<strong>题目理解是一定要注意有没有问题的,直接就决定了开头方向对不对,写不写得出来!</strong></p><ul><li>数据范围及分布</li><li>极端/边界情况</li></ul></li><li><p>构思代码</p><ul><li>多用稿纸辅助思考,推算思路</li><li>不要尝试用不熟练的算法,就靠已学尽力做就好</li></ul></li><li><p>实现代码</p><ul><li>一遍实现一遍思考极端,边界等情况(极端小数据 ,边界数据等)思路是否仍正确</li></ul></li><li><p>检查</p><ul><li>低级错误(变量名,数组清空,初始化赋值,符号,数据类型)</li><li><p>提交前多多测试几个数据,自己捏也好,generate一些也好</p><p>如果怎么找思路上和实现上的错误都找不出来,那么一定是<strong>很细微的铸币低级错误,就再重新确认一遍题目要求(最好是一开始就能确定好,如果做题的根基都错了就烷基八蛋了,但碰上这种情况也再去看一遍(你也不知道你第一遍认为的是不是真的就跟题意切合,再揣摩好)),挑着低级错误细细去看,并且把看过的部分就收起来,不要再重复看了!!!那是无意义的浪费时间(除非自己检查的标准有了新变动,那就应该用新标准再去看一遍)</strong></p></li></ul></li><li><p>有时间的话,对于<strong>没有把握</strong>的题,不要吝啬去蒙去猜结论,肯定是稳赚不赔的</p><ul><li><strong>时间不多没啥好思路</strong>,就先暴力搜索+分段(先处理小的,对大的单独优化),再优化(剪枝,记忆化),<strong>赌数据弱去骗分</strong></li><li>加上贪心</li><li>打表</li><li>找规律</li></ul></li></ul></li><li><p>除非还能有把握,不然最后10分钟就全面检查(中间就注意保存),看看好还能不能救(命名,数组大小等)</p></li></ul><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><ul><li>传入常数时<strong>注意使用lld强转</strong></li><li>一秒认定为<strong>2e8</strong></li><li><strong>堆上256MB</strong>最多可开<strong>5e7个int最好不超1e7(所以开大数组时再慎用lld)</strong></li><li>erase会返回所删除元素的下一个元素的迭代器,赋值即可</li><li>对于递推式,一般而言若<strong>由子状态递推</strong>,要<strong>根据子状态所处位置选择正确的循环顺序</strong>.</li><li></li></ul><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ul><li>在main()里面用solve()函数,方便运行至中间就结束</li><li>学会多去<strong>使用空间记录来简化</strong>代码量<strong>(本来也就用不完)</strong></li><li>对于二维的状态压缩,可以<strong>先用一维的去存储(将二维拆分为一维)</strong>,在<strong>处理时再转化为二维</strong>的</li><li>若有多次求取而<strong>有可能出现重复</strong>,则<strong>使用记忆化数组记下第一次求的值</strong></li><li><strong>根据题目情况</strong>,确定好什么<strong>从0看</strong>什么<strong>从1看</strong>,<strong>最好统一</strong>来看更方便,但一定要<strong>明确好什么变量怎么看,才方便做题</strong></li><li>把<strong>bitset当作二进制数串来看即可</strong></li></ul><h1 id="铸币小错"><a href="#铸币小错" class="headerlink" title="铸币小错"></a>铸币小错</h1><ul><li><strong>实数!=整数!!!要用lf!!!</strong></li><li>调用stl函数放入是<strong>从0开始</strong>的!</li><li><strong>unorder_</strong>map<strong>不存在pair的hash</strong>,而map用key存储无影响</li><li>使用stl会略增大空间使用和运行效率,<strong>大数据下且卡得死的话</strong>不如数组模拟效率高</li><li>使用pair,map等<strong>需要排序占用时间</strong>部分需要留意(尤其时间卡的死的时候,把不必要的时间消耗部分去掉)</li></ul><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>只看<strong>目前何种选择最好</strong>就去选(局部的,对于全局来说不一定选择这个就最好,可能现在差点会对全局更好)</p><p>证明其正确性即证明<strong>局部最优解就是全局最优解</strong>(局部最好<strong>就对全局最好</strong>,一般要<strong>独立的或能共同好</strong>的)</p><h4 id="差分-不同于用树状数组-维护的是变化数组-并非差分"><a href="#差分-不同于用树状数组-维护的是变化数组-并非差分" class="headerlink" title="差分(不同于用树状数组,维护的是变化数组,并非差分)"></a>差分(不同于用树状数组,维护的是变化数组,并非差分)</h4><p>当需要<strong>多次修改区间O(1)但仅少量查询O(n)</strong>时可用</p><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p>注意维护好边界情况,看好是否要减去或是加上(<strong>写成区块去看</strong>)</p><p>向右下<strong>加和,块+块-重叠+单点</strong></p><p>求取 <strong>块-(块+块-重叠)+(边界)</strong></p><h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><p>差分&lt;-&gt;原数组&lt;-&gt;前缀和三者之间都可<strong>运算互化</strong></p><p>二维差分定义式 <strong>b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</strong></p><p><strong>修改时注意b[x2+1][y2+1]处也要+1</strong></p><h4 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h4><p>表示用一个<strong>二进制数(虽然短,但其实能对应很多种情况,所以也是独特的)来表示一个子集(相对于总体集合,每个元素选与不选)</strong>,从而共可能有<strong>2的n次方种情况</strong></p><p>即为<strong>状态压缩</strong>,用一个二进制<strong>数特别地表示出一个状态</strong></p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>元素<strong>入队前</strong>把<strong>队首会破坏区间性</strong>和<strong>队尾会破坏单调性</strong>的元素去掉(队列<strong>保存下标即可</strong>,<strong>调用原数组读取值</strong>,否则要用pair)</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>每个元素最多出入一次</p><p>元素<strong>入栈前</strong>把<strong>栈顶</strong>会破坏单调性的元素去掉</p><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><p><strong>gcd*lcm=a*b</strong></p><h4 id="组合数思想"><a href="#组合数思想" class="headerlink" title="组合数思想"></a>组合数思想</h4><p>互补性质<img src="/2025/04/11/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/189b3a44f8bcf6b0e687730f596d413d.png" alt="189b3a44f8bcf6b0e687730f596d413d"></p><p>杨辉三角</p><p><img src="/2025/04/11/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/7e32652740f3f8403d4fea252c15d9ed.png" alt="7e32652740f3f8403d4fea252c15d9ed"></p><p>可用于<strong>线性递推二项式系数(先乘后除)</strong><img src="/2025/04/11/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/69c41febe0e1fd9d41106447ed434f31.png" alt="69c41febe0e1fd9d41106447ed434f31"></p><p>直观解释</p><p><img src="/2025/04/11/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/2536917b2042b0806ac454700cb38442.png" alt="2536917b2042b0806ac454700cb38442"></p><p>Cmn的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lld <span class="title">C</span><span class="params">(lld m,lld n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==m||m==<span class="number">0</span>) ret <span class="number">1</span>;<span class="comment">//边界情况</span></span><br><span class="line">    <span class="built_in">ret</span> (<span class="built_in">C</span>(m<span class="number">-1</span>,n<span class="number">-1</span>)+<span class="built_in">C</span>(m,n<span class="number">-1</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>求回文串(接近线性)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ull h1[N], h2[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(ull h[], ull l, ull r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>) &amp;&amp; <span class="built_in">strcmp</span>(s + <span class="number">1</span>, <span class="string">&quot;END&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i / <span class="number">2</span>];</span><br><span class="line">            s[i - <span class="number">1</span>] = <span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[ ++ n] = <span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n; i &lt;= n; i ++ , j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            h1[i] = h1[i - <span class="number">1</span>] * P + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            h2[i] = h2[i - <span class="number">1</span>] * P + s[j] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        &#125;</span><br><span class="line">        ull ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            ull r = <span class="built_in">min</span>(i - <span class="number">1</span>, n - i);</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= r || <span class="built_in">get</span>(h1, i - ans, i - <span class="number">1</span>) != <span class="built_in">get</span>(h2, n - (i + ans) + <span class="number">1</span>, n - i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (ans &lt;= r &amp;&amp; <span class="built_in">get</span>(h1, i - ans, i - <span class="number">1</span>) == <span class="built_in">get</span>(h2, n - (i + ans) + <span class="number">1</span>, n - i)) ans ++ ;</span><br><span class="line">            ans -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++ cnt, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>若用于二维就<strong>多套一层循环</strong>即可</p><h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><p><strong>阶段:从起始阶段转移到目标阶段的若干个子问题序列,每个是解决某个子问题以进行状态转移的解题过程,在一系列的阶段中逐步推进(每个阶段都依赖于前面阶段的结果,需要满足避免重复计算,无后效性)</strong></p><p><strong>状态表示f[i][j]</strong>:<strong>子问题的特征</strong></p><p><strong>决策</strong>:<strong>状态转移方程</strong>,可以<strong>多根据状态转移的限制来思考</strong>出状态转移方程</p><p><strong>状态设置要求</strong></p><p><strong>只有dp的初始状态按要求设置好了,才能够确保是由初始状态递推而来的答案.</strong></p><p>要设置成互无影响的,不重不漏的状态,能划分而<strong>确定好局部与全局的关系(部分好能推得全局好,否则换一种状态表示)</strong>.要确保当使用子问题结果递推时<strong>子问题已经完全解决(或者不完全解决也不影响结果,是互相独立的,可以叠加)</strong>才<strong>可用于递推更新状态</strong></p><p>此后,别以为可能会互相囊括冲突,其实因为<strong>有维度i,j的限制</strong>,每个值都是<strong>要看作两两独立的(只是讲求取时不会互相有囊括冲突影响)</strong></p><p>满足三个条件：最优子结构，无后效性和子问题重叠。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>具有最优子结构也可能是<strong>适合用贪心</strong>的方法求解。</p><p>注意要确保我们<strong>考察了最优解中用到的所有子问题</strong>。</p><ol><li>证明问题最优解的第一个组成部分是做出一个选择；</li><li>对于一个给定问题，在其可能的第一步选择中，<strong>假定你已经知道哪种选择才会得到最优解(假设要是求得的就会是最优(但其实现在还没求得),那么也一定是由求得的子问题的最优解得到的(即肯定会是由最优继承,不可能有漏解或非最优继承影响))</strong>,现在并不用关心这种选择具体是如何得到的.</li><li>给定可获得的最优解的选择后，确定<strong>这次选择会产生哪些子问题</strong>，以及<strong>如何最好地刻画子问题空间</strong>；</li><li>证明<strong>在这一种决策下</strong>,<strong>作为构成原问题最优解的组成部分</strong>，每个<strong>子问题</strong>的解<strong>就是它本身的最优解</strong>。方法是<strong>反证法</strong>，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li></ol><p>要保持子问题空间尽量简单，只在必要时扩展。</p><p>最优子结构的不同体现在两个方面：</p><ol><li>原问题的最优解中涉及多少个子问题；</li><li>确定最优解使用哪些子问题时，需要考察多少种选择。</li></ol><p>子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。</p><h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>已经求解的子问题，<strong>不会再受到后续决策的影响</strong>。</p><h3 id="子问题重叠"><a href="#子问题重叠" class="headerlink" title="子问题重叠"></a>子问题重叠</h3><p>如果有<strong>大量的重叠子问题</strong>，可以<strong>记忆化避免重复求解(在当前阶段解决该阶段的总体的子问题需要解决若干个子问题的子问题,而部分子问题的子问题在之前的阶段已经求过了)</strong>相同的子问题，从而提升效率(方便<strong>由先前状态得出的最优值</strong>,判断性继承)。</p><h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><p>如果需要<strong>将边按边权排序</strong>,需要<strong>多次建图（如建一遍原图，建一遍反图）</strong>可以将边直接存下来，需要<strong>重新建图</strong>时<strong>利用直接存下的边</strong>来建图,<strong>就用vector<int> e</int></strong></p><p>邻接矩阵<strong>只适用于没有重边（或重边可以忽略,如求最短路,就只要看最小的那条边就足够）的情况</strong>。(或者<strong>能够特殊处理</strong>)</p><p>其最显著的优点是可以 <strong>O(1) 查询一条边是否存在</strong>。一般只会在<strong>稠密图上</strong>使用</p><p><strong>邻接表vector<int> e[N]</int></strong>,存<strong>各种图</strong>都很适合除非有特殊需求（如需要<strong>快速查询</strong>一条边是否存在，且点数较少，可以使用邻接矩阵）。</p><p><strong>链式前向星</strong>,不能快速查询一条边是否存在，也<strong>不能方便地对一个点的出边进行排序</strong>。优点是<strong>边是带编号</strong>的.而且<strong>如果 <code>cnt</code> 的初始值为奇数</strong>，存<strong>双向边时 <code>i ^ 1</code> 即是 <code>i</code> 的反边(且一定这么关联)</strong>（常用于 <a href="https://oi-wiki.org/graph/flow/">网络流</a>）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>比赛相关内容的一个一个记</title>
      <link href="/2025/04/10/%E6%AF%94%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/"/>
      <url>/2025/04/10/%E6%AF%94%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇对各个比赛的一个一个印象记录</p><h1 id="蓝桥杯"><a href="#蓝桥杯" class="headerlink" title="蓝桥杯"></a>蓝桥杯</h1><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><ul><li><p>填空 (2-4) 手动计算(日期,如闰年;几何,数学) <strong>保证正确率</strong></p></li><li><p>编程 (省6国8) (搜索,dp,贪心) 有部分分 <strong>先暴力,后优化</strong></p></li></ul><p><strong>模板为王</strong></p><p>必须在代码结尾 <strong>return 0</strong>，否则一定为零分</p><p>检查好自己提交的代码是否为<strong>去除多余东西,(只含必要输出成果)</strong>有必要东西的代码</p><h1 id="全国大学生嵌入式芯片与系统设计竞赛-芯片应用赛道选题指南"><a href="#全国大学生嵌入式芯片与系统设计竞赛-芯片应用赛道选题指南" class="headerlink" title="全国大学生嵌入式芯片与系统设计竞赛(芯片应用赛道选题指南)"></a><strong>全国大学生嵌入式芯片与系统设计竞赛(</strong>芯片应用赛道选题指南<strong>)</strong></h1><p><strong>星闪物联网应用平台</strong></p><p>以下仅介绍WS63相关</p><p><strong>关键特性</strong>:高性能 32bit 微处理器、2.4GHz WiFi 6、SLE、BLE三模、丰富的外设接口，其中增强款WS63E 支持2.4GHz 的雷达人体活动检测功能</p><p><strong>应用场景</strong>:智慧家居、雷达感知、星闪网关、星闪中控屏、星闪手柄等</p><p><strong>注：</strong>星闪（NearLink），是中国原生的新一代无线短距通信技术。与传统短距传输技术方案相比，星闪在功耗、速度、覆盖范围和连接性能全面领先，可以在智能终端、智能家居、智能汽车、智能制造等各类细分场景下实现更极致的用户体验。</p><p><strong>选题方向一：星闪物联网应用方向（参赛组别：本科生）</strong></p><p>1、本选题参赛作品的主控要求优先使用星闪 WS63 或 WS63E 或 BS21，</p><p>Hi3861V100 也可使用，操作系统可使用 LiteOS 或 OpenHarmony 版本。</p><p>2、如采用星闪 WS63 或 WS63E 或 BS21，并发挥星闪技术特性可酌情加分。</p><p>3、本选题重点考察参赛选手的嵌入式系统开发能力, SLE/BLE/WiFi 多端互联能力。</p><p>4、参赛选手须具备基础的 C 语言编码能力，了解物联网技术及应用相关知识。</p><p>5、本选题学习资料可参考《2025 年嵌入式竞赛海思赛道学习入口》，并知晓开发环境要求及套件功能限制。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建环境做一个一个备忘</title>
      <link href="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>为临时需要再搭建环境时做一个一个备忘</p><p>记得先切换电脑自带的快捷键,如切换<strong>语言标点</strong></p><h1 id="c-类型"><a href="#c-类型" class="headerlink" title="c++类型"></a>c++类型</h1><h2 id="关于GCC"><a href="#关于GCC" class="headerlink" title="关于GCC"></a>关于GCC</h2><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>完全支持</p><p>从GCC4.8.1版本完全支持</p><p>-std=c++11 or std=gnu++11</p><h2 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h2><p>完全支持</p><p>从GCC6.1版本开始完全支持，从6.1-10(包括)的默认模式</p><p>-std=c++14 or std=gnu++14</p><h2 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h2><p>完全支持</p><p>从GCC 5版本开始支持，到GCC 7版本已完全支持，是GCC 11到13版本的默认模式</p><p>-std=c++17 or std=gnu++17</p><h2 id="C-17-1"><a href="#C-17-1" class="headerlink" title="C++17"></a>C++17</h2><p>完全支持</p><p>从GCC 5版本开始支持，到GCC 7版本已完全支持，是GCC 11到13版本的默认模式</p><p>-std=c++17 or std=gnu++17</p><p>C++20</p><p>未完全支持</p><p>从GCC 8版本开始支持</p><p>-std=c++20 or</p><p>std=gnu++20（GCC 9以及之前版本使用<strong>-std=c++2a</strong>）</p><h1 id="CPH"><a href="#CPH" class="headerlink" title="CPH"></a>CPH</h1><p>抓取洛谷题目需要<strong>右键选取LuoguProblemParser</strong></p><h1 id="Devc"><a href="#Devc" class="headerlink" title="Devc"></a>Devc</h1><p>最高支持c++11标准</p><p>安装时按默认(包括语言),可改安装到那个盘</p><h3 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a><strong>选择语言</strong></h3><p>在这里选择简体中文。</p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/903788e3cc733503d1b25dd3be391ac9.png" alt="图片"></p><h2 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h2><p>工具-&gt;编译选项-&gt;代码生成优化-&gt;代码生成-&gt;语言标准(根据需要修改)</p><p>​              -&gt; 代码性能-&gt;生成代码性能信息</p><p>​              -&gt;连接器-&gt;产生调试信息</p><p>工具-&gt;环境选项-&gt;鼠标查看变量值</p><p><strong>有改动,重启都一定要先编译再调试</strong></p><p>快捷键   F5   <strong>开始</strong>调试</p><p>快捷键   F6   <strong>停止</strong>调试</p><p>快捷键   F7   单步调试（运行下一步）</p><p>快捷键   F8   单步<strong>进入函数</strong>调试</p><p>如果你调试前设置查看的话，变量会<strong>“Execute to evaluate”</strong></p><p>遇见 <code>endl</code> 会卡死！调试查看 STL 里面参数会卡死！</p><p><strong>看stl去调试的话一定会卡死,只能打印出来,或者(赋值给一个变量，查看变量)(注意取消鼠标看变量)</strong></p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/600d17661c6b3c7b5f944514539744ae.png" alt="查看"></p><h2 id="自动整理代码"><a href="#自动整理代码" class="headerlink" title="自动整理代码"></a>自动整理代码</h2><p>按下Ctrl+<strong>Shift</strong>+A整理</p><h4 id="调整界面风格"><a href="#调整界面风格" class="headerlink" title="调整界面风格"></a><strong>调整界面风格</strong></h4><p>工具 -&gt; 编辑器选项 -&gt; 基本 -&gt;去掉高亮显示当前行的√</p><p>​                -&gt; 语法-&gt;预设-&gt;obsidian</p><h2 id="手动补全-自己用过的变量"><a href="#手动补全-自己用过的变量" class="headerlink" title="手动补全(自己用过的变量)"></a>手动补全(自己用过的变量)</h2><p>打开工具 -&gt; 快捷键选项，找到最下面的Show code completion，把快捷键改成别的 （我选择的是Ctrl+Enter，就是选中你要更改的那项，然后直接按下你想要的组合键，自动就改了），然后确定后退出。<br><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3eac3cf5dc10ab53b736de9936e7d5d6.png" alt="只要鼠标点击到上面就可以按下要更改的快捷键"></p><p>它只能提示出它<strong>已经缓存好了的头文件的内容</strong>，(不如<strong>去查api文档</strong>)如果你在安装的时候只缓存了常用头文件的话， 你包含<br>以下为收集的一些可以提示和不可以提示的总结：</p><p>已经写上的头文件里面的函数<br>函数形参列表<br>你定义的变量、函数名<br>对象实例的方法、构造方法<br>宏定义</p><p>看上去可以，实际上不能提示的有一些，但不限于：</p><p>语言保留字（一些关键字），比如break、return、continue、sizeof、malloc……<br>头文件（就是#include后不能像visual studio一样出现一些头文件的提示）<br>预处理语句</p><p>如果你想让它提示保留字出来的话，你可以这样解决，那就是写这么一个宏定义（以continue为例）：</p><h1 id="define-continue-continue"><a href="#define-continue-continue" class="headerlink" title="define continue continue"></a>define continue continue</h1><p>然后continue就能被作为一个宏而提示出来了，但是完全没必要</p><h1 id="小熊猫devc"><a href="#小熊猫devc" class="headerlink" title="小熊猫devc"></a>小熊猫devc</h1><h2 id="配置及使用"><a href="#配置及使用" class="headerlink" title="配置及使用"></a>配置及使用</h2><p><strong>ctrl+R(非H) </strong>替换(<strong>蓝块为当前</strong>)</p><p>可以<strong>自行调整各栏间距</strong>以方便观察</p><p>F10无功能</p><p>F11为编译并运行(如果有改动会编译,挺智能的)</p><p>F12全部重编译(<strong>改动编译器设置时必须用</strong>)</p><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p>自带类似cph插件,在下栏试题处,添加即可</p><p>编译完<strong>确认好是报错还是警告</strong></p><h2 id="调试-可能需要多按几次换行-所以最好输入时就自带"><a href="#调试-可能需要多按几次换行-所以最好输入时就自带" class="headerlink" title="调试(可能需要多按几次换行,所以最好输入时就自带)"></a>调试(可能需要多按几次换行,所以最好输入时就自带)</h2><p>如果<strong>要调试必须把输入输出优化先注释掉,不然不会提前出结果</strong>.</p><p><strong>调试窗口</strong>会<strong>吞复制内容</strong>,<strong>必须再次复制</strong>才行</p><p>ctrl+F5 执行到光标处(中间<strong>有断点就暂停</strong>)</p><p>F6 停止调试</p><h4 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h4><p>顾名思义，单步执行就是让程序执行一步后暂停。问题在于，到底多少程序算”一步“？在小熊猫C++的运行菜单中，有这么几种单步执行：</p><ul><li>单步跳过F8：一行程序算一步。执行完当前行后暂停。</li><li>单步进入F7：如果当前行不包含函数调用，则一行程序算一步；如果这行程序中包含对函数的调用，会在进入函数后暂停；如果找不到该函数的符号信息，则在执行完该函数后暂停。</li><li>单步跳出ctrl+F8：退出当前函数后暂停。</li></ul><h4 id="继续执行F4"><a href="#继续执行F4" class="headerlink" title="继续执行F4"></a>继续执行F4</h4><p>程序暂停后，通过”运行“菜单或者调试工具栏选择”继续执行”，程序就<strong>会继续以调试方式运行</strong>，<strong>直到遇到下一个断点(包括在循环内再次遇到自己这行)</strong>，或者程序运行结束为止。</p><h4 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h4><p>如果变量在<strong>当前作用域</strong>无效会直接无,尽量开全局看全局,但若同名也只优先显示当前作用域的值</p><p>添加完之后改不了名字,但是<strong>双击可以修改其值</strong></p><p>*(a+3)@10监视数组部分(注意下标也会随+3变化)</p><p>下方栏调试-局部变量可<strong>自动</strong>看当前函数作用域中的所有局部变量（包括函数参数）</p><p>gdb（小熊猫C++使用的调试器）支持监视<strong>任何合法的C、C++表达式(包括函数,这样递归函数时方便直接看返回值了)</strong>。但请保证在<strong>表达式中不会出现无穷递归、无限循环等错误</strong>，否则gdb调试器<strong>会卡死</strong>无法正常使用。</p><h4 id="调用栈视图"><a href="#调用栈视图" class="headerlink" title="调用栈视图"></a>调用栈视图</h4><p>我们按照<strong>自顶向下或者模块化</strong>的思路设计程序时，会<strong>以函数为单位</strong>来组织和实现的程序的功能。在调试程序时，我们经常需要知道，函数现在<strong>正被谁调用</strong>？调用者的状态是怎样的？</p><p>调试面板中的调用栈视图为我们<strong>提供了程序调用栈（Call Stack）的信息</strong>。从下图中我们可以看出，当前程序执行到isPrime函数中，它是在main函数的第30行被调用的。</p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/v2-cd058dfc523f80464f665e4296eb09eb_1440w.jpg" alt="img"></p><p>在调用栈视图中双击某一行，小熊猫C++就会自动跳转到对应的程序位置。</p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/v2-6cf7f15962e80b2d0f4b6c63f5505a22_1440w.jpg" alt="img"></p><h4 id="求值工具"><a href="#求值工具" class="headerlink" title="求值工具"></a>求值工具</h4><p>除了监视和局部变量之外，我们还可以使用求值工具<strong>来快速计算某个表达式</strong>。</p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/v2-2e2ab8da54241be35d7b47a496861217_1440w.jpg" alt="img"></p><p>注意，求值工具可以执行任意合法的C/C++表达式，包括赋值表达式！其<strong>效果和在程序中执行该表达式的作用是相同的(别冲突了)</strong>。例如，我们在求值输入框中输入n=500，就可以将变量n的值<strong>改为500</strong>。</p><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p><strong>打开gdb server调试模式</strong></p><p>调试的数据重定向功能需要打开gdb server调试模式。从“工具”菜单“选项”打开“选项”对话框，在“<a href="https://zhida.zhihu.com/search?content_id=189947528&amp;content_type=Article&amp;match_order=1&amp;q=调试器&amp;zhida_source=entity">调试器</a>”-&gt;“通用”选项页中可以找到“使用gdb server调试“选项，将其勾选上，然后确定即可。</p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/v2-385e5ac602415c34da1cc9ba0bc15bd4_1440w.jpg" alt="img"></p><h4 id="指定数据文件-从而可以直接只看输出"><a href="#指定数据文件-从而可以直接只看输出" class="headerlink" title="指定数据文件(从而可以直接只看输出)"></a>指定数据文件(从而可以直接只看输出)</h4><p>通过工具栏或者<strong>”运行“菜单中的”运行参数…“按钮，打开”运行参数“选项页</strong></p><p>在选项页中，勾选”将程序的标准输入重定向到下面的文件“，并选择<strong>数据所在的文件</strong>（本例中使用F盘根目录下的test.txt文件，即F:\test.txt作为输入文件），然后确定即可。</p><p><img src="/2025/04/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/v2-96d0c56a476cc963e80c828d9394fb00_1440w.jpg" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>顽强拼搏记录</title>
      <link href="/2025/03/23/%E9%A1%BD%E5%BC%BA%E6%8B%BC%E6%90%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/03/23/%E9%A1%BD%E5%BC%BA%E6%8B%BC%E6%90%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本篇记录博主自己顽强拼搏的时刻以供回念,以激励博主继续又菜又爱玩.<strong>(没有含金量,全是刺激性)</strong></p><p>2025.3.23</p><h1 id="大工之星第二场"><a href="#大工之星第二场" class="headerlink" title="大工之星第二场"></a>大工之星第二场</h1><p>开头ev录屏忘开了,中间又花了近1h去做了个志愿活动(雾</p><p><img src="/2025/03/23/%E9%A1%BD%E5%BC%BA%E6%8B%BC%E6%90%8F%E8%AE%B0%E5%BD%95/ab0a68dd90d0f528e83e053c6fc546fb.png" alt="ab0a68dd90d0f528e83e053c6fc546fb"></p><p>2025.4.14</p><h1 id="大工之星第五场"><a href="#大工之星第五场" class="headerlink" title="大工之星第五场"></a>大工之星第五场</h1><p>最后发现数据<strong>没取模连lld都爆了</strong>(INT128好像爆不了),急救了一波.</p><p><img src="/2025/03/23/%E9%A1%BD%E5%BC%BA%E6%8B%BC%E6%90%8F%E8%AE%B0%E5%BD%95/2d0d43ec394364fe67b27d4ab4ec41a7.png" alt="2d0d43ec394364fe67b27d4ab4ec41a7"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>唐b杂事</title>
      <link href="/2025/03/17/%E5%94%90b%E6%9D%82%E4%BA%8B/"/>
      <url>/2025/03/17/%E5%94%90b%E6%9D%82%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="算法学习方面"><a href="#算法学习方面" class="headerlink" title="算法学习方面"></a>算法学习方面</h1><p>1.vscode调试跟coderunner插件配置文件是分开来的,要想用vscode自带调试设置为c++20,必须在tasks.json文件中的args里面添加一个”-std=c++2<strong>a”,</strong>(注意逗号,双引号和a).</p><p>2.玛德用<strong>宏定义</strong>(纯文本替换卧槽忘了<strong>运算顺序</strong>)被干死了,再用宏定义我就是煞笔.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>麦麦--qq聊天机器人部署备忘</title>
      <link href="/2025/03/17/%E9%BA%A6%E9%BA%A6-qq%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%83%A8%E7%BD%B2%E5%A4%87%E5%BF%98/"/>
      <url>/2025/03/17/%E9%BA%A6%E9%BA%A6-qq%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%83%A8%E7%BD%B2%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<h1 id="重启电脑后如何启动"><a href="#重启电脑后如何启动" class="headerlink" title="重启电脑后如何启动"></a>重启电脑后如何启动</h1><h2 id="启动QQ"><a href="#启动QQ" class="headerlink" title="启动QQ"></a>启动QQ</h2><h2 id="打开compass，启动数据库"><a href="#打开compass，启动数据库" class="headerlink" title="打开compass，启动数据库"></a>打开compass，启动数据库</h2><h2 id="打开bot文件夹，启动终端"><a href="#打开bot文件夹，启动终端" class="headerlink" title="打开bot文件夹，启动终端"></a>打开bot文件夹，启动终端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bot\\Scripts\\activate</span><br><span class="line">nb run</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>身为一个小白,有了这次经历后,感觉真不该嗯看个几把教程,身为新手,无法分辨教程是不是全对,又搜不到,该问的时候就正确的去发问,真几把别不好意思.</strong></p><p>多看看新的教程,评价好的,完整的教程,甚至是视频教程(虽然慢点但是最稳,能看见所有步)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习有感</title>
      <link href="/2025/03/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/"/>
      <url>/2025/03/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>一定要有能自主配好<strong>成熟</strong>环境的能力,总会遇到<strong>到新环境要调整</strong>的时候</p><p><strong>多多去通过问问题(学长,ai)等去学习理解问题而非总是自己死磕(自个儿而看都卡了,还光重复多看怎么可能高效学习的了呢?自主学习不是纯靠自己学习,故步自封),要避免不必要的麻烦</strong></p><ul><li><p>一定要能独立完成(<strong>包括不看资料(除非纯生涩那种)</strong>)编码——可以参考别人的代码，但是<strong>写的时候要独立</strong>。凡是参考过别人代码的题，隔一段时间之后<strong>要重写</strong></p></li><li><p>多问几个为什么，不要在知识点和代码里遗留那些：好像这样就能过了的问题，AC不是一个题做完的标志，<strong>想明白的才是</strong>。</p></li><li><p>写题解——题解应该包含的内容：<strong>英文题的大概意思</strong>、大体思路、<strong>“我是哪里没想到”，产生错误提交的原因(别只会总结对的不会纠正错的,那样遇到错遇到不会又出错误思路怎么办)</strong></p></li></ul><h1 id="关键问题：先看题解还是先做题？"><a href="#关键问题：先看题解还是先做题？" class="headerlink" title="关键问题：先看题解还是先做题？"></a>关键问题：先看题解还是先做题？</h1><h2 id="分场景策略"><a href="#分场景策略" class="headerlink" title="分场景策略"></a>分场景策略</h2><div class="table-container"><table><thead><tr><th>情况</th><th>建议方法</th><th>示例</th></tr></thead><tbody><tr><td><strong>完全无</strong>思路</td><td><strong>先看题解</strong>理解算法思想，<strong>再独立实现</strong>代码</td><td>初次接触“状态压缩DP”时，参考题解学习状态设计技巧。</td></tr><tr><td><strong>有思路</strong>但代码写不出</td><td>尝试手写<strong>伪代码</strong>，再<strong>对比题解优化</strong>逻辑</td><td>BFS迷宫问题中，自己设计队列结构后对比标准实现。</td></tr><tr><td>能<strong>通过部</strong>分测试用例</td><td>先<strong>自行调试（打印中间变量!!!）</strong>，<strong>参考题解找错误</strong></td><td>动态规划题中n=0或n=1的边界情况处理。</td></tr></tbody></table></div><h2 id="学习步骤建议"><a href="#学习步骤建议" class="headerlink" title="学习步骤建议"></a>学习步骤建议</h2><ol><li>自主思考（出思路前<strong>10分钟最多</strong>）：尝试建立问题<strong>模型</strong>，写出<strong>伪代码或暴力解法</strong>。  </li><li>代码复现：关闭题解，<strong>独立写出并能记忆下</strong>通过代码，<strong>确保理解</strong>每一行逻辑。  </li></ol><h1 id="3-高效刷题技巧"><a href="#3-高效刷题技巧" class="headerlink" title="3. 高效刷题技巧"></a>3. 高效刷题技巧</h1><h2 id="错题本整理"><a href="#错题本整理" class="headerlink" title="错题本整理"></a>错题本整理</h2><ul><li>记录题目<strong>链接</strong>、<strong>错误原因</strong>（如越界、逻辑错误）、正确解法。  </li><li><strong>定期重做高重要度错题</strong>（建议每周复盘一次）。</li></ul><p><img src="/2025/03/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/image-20250313181037086.png" alt="image-20250313181037086"></p><p><img src="/2025/03/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/image-20250313181112291.png" alt="image-20250313181112291"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进行一个一个比赛的补</title>
      <link href="/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/"/>
      <url>/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>本页面记录了本人在<strong>赛时</strong>和赛后的思路和相关问题以及对应解法,总结和反思</p><h1 id="cf"><a href="#cf" class="headerlink" title="cf"></a>cf</h1><h2 id="2025cccc选拔赛"><a href="#2025cccc选拔赛" class="headerlink" title="2025cccc选拔赛"></a>2025cccc选拔赛</h2><p>后记:一定要用成熟的版本,不要临时求变,一定要<strong>巩固好最稳定的做法</strong>.前几题考不到什么大的知识点的,主要都是侧重思维,因此一定要<strong>注意</strong>自己解法<strong>在思维上的投入(太少太暴力模拟肯定不对)</strong>,肯定<strong>不能过于直观</strong>,一般一定是错的,要不在此基础上优化,要不就全部推翻用<strong>新思路</strong>.<strong>确定了绝对不可能</strong>的思路那就一定要<strong>及时完全跳出</strong>来,不要再被拖累了,每次都是先想到了巨麻烦的做法但是又总不即时抛弃掉,<strong>脑子跳不出来想</strong>.</p><p><strong>B 放烟花</strong></p><p>Bob喜欢放烟花，他购买了两个烟花发射装置和大量的发射炮弹。</p><p>两个装置同时开启。第一个装置每隔 $a$ 分钟（即开启后 $a, 2 \cdot a, 3 \cdot a, \dots$ 分钟）发射一次烟花。第二个装置每隔 $b$ 分钟（即开启后 $b, 2 \cdot b, 3 \cdot b, \dots$ 分钟）发射一次烟花。</p><p>每个烟花在发射后的 $m + 1$ 分钟内都可以在天空中看到，也就是说，如果一个烟花是在装置开启后的 $x$ 分钟后发射的，那么从 $x$ 到 $x + m$ （包括首尾两分钟）的每一分钟都可以看到该烟花。如果一个烟花在另一个烟花 $m$ 分钟后发射，则两个烟花都将在一分钟内可见。</p><p>天空中最多可以同时看到多少枚烟花？</p><p>第一行包含一个整数 $t$ $(1 \le t \le 10^4)$ 代表测试用例数。</p><p>每个测试用例的第一行也是唯一一行包含整数 $a$, $b$, $m$ $(1 \le a, b, m \le 10^{18})$ 代表第一个装置、第二个装置的发射频率和烟花在天空中可见的时间。</p><p>赛时思路:画图直观枚举叠加,发现数据量过大暴力不行,又想到差分(?),根据样例分析直接盲猜*2做差的结论(?),后面才发现只需求出各个区间内最多后再相加即可</p><p>正确思路:由于<strong>时间无限</strong>,直接求出<strong>各个区间内最多</strong>后再相加即可,总有重叠的时候.</p><p>反思:不要直观画图了真就完全只按直观的来,肯定要在图上思考优化的,甚至是推翻图重做,思路一定要打开,别把前面的题就想得那么难直接<strong>硬套太多大知识点</strong>.可以根据样例分析而思考相应做法,但样例分析肯定不会完全透出正解甚至可能完全跟正解做法不相关(<strong>纯暴力模拟</strong>),绝对<strong>不能完全依靠据此猜得的各种结论和做法</strong>.</p><p><strong>C 自然语言处理</strong></p><p>Alice 觉得无聊，于是决定用五个字母 $\texttt{a}$ , $\texttt{b}$ , $\texttt{c}$ , $\texttt{d}$ , $\texttt{e}$ 创造一种简单的语言。字母分为两类：</p><ul><li>元音 — 字母 $\texttt{a}$ 和 $\texttt{e}$ 。用 $\textsf{V}$ 表示。</li><li>辅音 — 字母 $\texttt{b}$ , $\texttt{c}$ 和 $\texttt{d}$ 。用 $\textsf{C}$ 表示。</li></ul><p>这种语言中有两种类型的音节： $\textsf{CV}$ （辅音后接元音）或 $\textsf{CVC}$ （元音前后均有辅音）。例如， $\texttt{ba}$ , $\texttt{ced}$ , $\texttt{bab}$ 是音节，但 $\texttt{aa}$ , $\texttt{eda}$ , $\texttt{baba}$ 不是。</p><p>语言的单词由音节序列构成。Alice 写了一个单词，但她不知道如何将其分割为音节。请帮助她分割单词。</p><p>例如，给定单词 $\texttt{bacedbab}$ ，应分割为 $\texttt{ba.ced.bab}$ （点 $\texttt{.}$ 表示音节边界）。</p><p><strong>Input</strong></p><p>输入包含多个测试用例。</p><p>第一行包含一个整数 $t$ $(1 \leq t \leq 100)$ 代表测试用例数量。接下来描述每个测试用例。</p><p>每个测试用例的第一行包含一个整数 $n$ $(1 \leq n \leq 2 \cdot 10^5)$ 代表单词长度。</p><p>每个测试用例的第二行包含一个由 $n$ 个小写拉丁字母组成的字符串，代表要分割的单词。</p><p>所有给定的单词均为合法单词，即仅使用字母 $\texttt{a}$, $\texttt{b}$, $\texttt{c}$, $\texttt{d}$, $\texttt{e}$，且每个单词由若干音节构成。</p><p>保证所有测试用例的 $n$ 之和不超过 $2 \cdot 10^5$。</p><p><strong>Output</strong></p><p>对每个测试用例，输出一个字符串，通过在相邻音节间插入点 .. 来表示分割后的结果。</p><p>若存在多种可能的分割方式，输出任意一种即可。输入保证至少存在一种有效分割。</p><p>赛时思路:一个个找出来再分割,不同的分割情况相应深搜再剪枝叶(?),后面发现数据量太大不可能,随后观察题意,才发现有元音处一定有分割,于是想先找出所有元音位置后再进行分割然后再深搜剪枝(?),发现肯定也太麻烦,后面对比两种形式后才发现元音前一定是辅音,只要在辅音前加.则一定会满足题意(题目保证了一定有一种解法,这样一定最优,无论哪种分割都不会漏点)</p><p>正解思路:对比两种形式后才发现元音前一定是辅音,<strong>只要在辅音前加.</strong>则一定会满足题意(<strong>题目保证</strong>了一定有一种解法,这样一定最优,无论哪种分割都不会漏点)</p><p>反思:要学会观察题意对比,找出<strong>共通点</strong>从而形成<strong>简单而符合题意的思路</strong>.</p><p>代码问题:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">repp</span>(i,<span class="number">0</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)<span class="comment">//循环中用了s.length,由于字符串被修改且长度变化,这里循环次数也是会变化的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>||s[i]==<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(i<span class="number">-1</span>,<span class="string">&quot;.&quot;</span>);<span class="comment">//就在该位置插入,然后把后面字符串往后推</span></span><br><span class="line">            i++;<span class="comment">//关键一步,如果插入了,则肯定要再向后推(s长度变化了),不然这里指向的位置就不再是原来的a/e</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());<span class="comment">//前面肯定会有一个多的点,要删除掉</span></span><br></pre></td></tr></table></figure><p>D 数学平均数</p><p>Bob 有一个由 $n$ 个整数组成的数组 $a$。让我们用 $k$ 表示这些元素的数学平均数（注意 $k$ 有可能不是整数）。</p><p>由 $n$ 个元素组成的数组的数学平均数是所有元素之和除以这些元素的个数（即和除以 $n$）。</p><p>Bob 希望从 $a$ 中恰好删除两个元素，这样剩下的 $(n - 2)$ 个元素的数学平均数仍然等于 $k$。</p><p>你的任务是计算有多少对位置 $[i, j]$ (i &lt; j)$，使得删除这些位置上的两个元素后，剩下的 $(n - 2)$ 个元素的数学平均数仍然等于 $k$（即等于原数组 $a中 n个元素的数学平均数）。</p><p>赛时思路:求出所有i-n的数的出现次数,一开始想用二分,但发现<strong>并非有序</strong>,但发现<strong>空间太大</strong>,无法完成,又尝试用map映射,但发现也是空间太大,实现不了<strong>(本质都没变)</strong>,</p><p>正解思路:先处理好1-n的数的出现次数,再倒序遍历,对于遍历到每个数时减去一次该数相应求平均数对象的出现次数,再加和<strong>即为1-i-1的数的出现次数</strong>.</p><p>反思:使用任何方法时要<strong>注意限制条件再使用</strong>,换方法时一定要注意自己<strong>本质变没变</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[(<span class="type">int</span>)<span class="number">2e5</span><span class="number">+3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;s;<span class="comment">//记得每次都要重新开,得hu</span></span><br><span class="line">        lld sum=<span class="number">0</span>;lld ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">repp</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            sum+=a[i];</span><br><span class="line">            s[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        lf k0=(sum*<span class="number">2.0</span>/n);lld k=(sum*<span class="number">2.0</span>/n);</span><br><span class="line">        <span class="keyword">if</span>(k0!=k)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;ct;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">repm</span>(i,n,<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a0=k-a[i];s[a[i]]--;</span><br><span class="line">                ans+=(s[a0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="2025-牛客寒假训练1"><a href="#2025-牛客寒假训练1" class="headerlink" title="2025 牛客寒假训练1"></a>2025 牛客寒假训练1</h2><p><strong>G    调整出1-n序列(贪心+排序)</strong></p><p>题意：给一个数组，每次操作可以使一个元素加1，另一个元素减1，问变成排列的最小操作次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lld a[<span class="number">100003</span>],sum,ans;<span class="type">bool</span> biao[<span class="number">100003</span>];vi dai,que;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0);cin.tie(0);</span></span><br><span class="line">    <span class="comment">//int t;cin&gt;&gt;t;</span></span><br><span class="line">    <span class="comment">//while(t--)&#123; &#125;</span></span><br><span class="line">    lld n;cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">repp</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum!=(n*(n<span class="number">+1</span>))/<span class="number">2</span>)<span class="comment">//加减操作不应影响整个的和</span></span><br><span class="line">    &#123;cout&lt;&lt;<span class="number">-1</span>;ret <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">    <span class="built_in">repp</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">abs</span>(a[i]-i);<span class="comment">//对应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans/<span class="number">2</span>;<span class="comment">//取一半即可,加减操作次数相同</span></span><br><span class="line">    ret <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>E 双生双宿之错</strong></p><p>题意：给定一个数组，每次操作可以使得一个元素加1或者减1，问最小操作几次可以变成双生数组，即元素种类数为2、且出现次数相同。</p><p><strong>中位数定理</strong>：给定一个数组，每次操作<strong>加1或者减1</strong>，将所有元素<strong>变成相同</strong>的<strong>最小操作次数</strong>则是<strong>将所有元素变成中位数即可。</strong>(出现浮点数时整左右<strong>哪个整数都行</strong>,因为左右两半的<strong>数个数是相同的</strong>)</p><p><img src="/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/2a4d15a25658e929758cd4a0a0afd4d2.png" alt="2a4d15a25658e929758cd4a0a0afd4d2"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">lld a[<span class="number">100003</span>],x,y,t,n;</span><br><span class="line"><span class="function">lld <span class="title">check</span><span class="params">(lld xx,lld yy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lld sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(xx!=yy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">repp</span>(i,<span class="number">1</span>,t)</span><br><span class="line">        sum+=<span class="built_in">abs</span>(a[i]-xx);</span><br><span class="line">        <span class="built_in">repp</span>(i,t<span class="number">+1</span>,n)</span><br><span class="line">        sum+=<span class="built_in">abs</span>(a[i]-yy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果相等分类讨论取最小</span></span><br><span class="line">    &#123;</span><br><span class="line">        lld sum1=<span class="number">0</span>;lld sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">repp</span>(i,<span class="number">1</span>,t)</span><br><span class="line">        sum1+=<span class="built_in">abs</span>(a[i]-(xx<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">repp</span>(i,t<span class="number">+1</span>,n)</span><br><span class="line">        sum1+=<span class="built_in">abs</span>(a[i]-yy);</span><br><span class="line">        <span class="built_in">repp</span>(i,<span class="number">1</span>,t)</span><br><span class="line">        sum2+=<span class="built_in">abs</span>(a[i]-xx);</span><br><span class="line">        <span class="built_in">repp</span>(i,t<span class="number">+1</span>,n)</span><br><span class="line">        sum2+=<span class="built_in">abs</span>(a[i]-(yy<span class="number">+1</span>));</span><br><span class="line">        sum=<span class="built_in">min</span>(sum1,sum2);</span><br><span class="line">    &#125;</span><br><span class="line">    ret sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0);cin.tie(0);</span></span><br><span class="line">    <span class="type">int</span> k;cin&gt;&gt;k;<span class="comment">//记得把t换了</span></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123; </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">repp</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);<span class="comment">//排好序</span></span><br><span class="line">    t=n&gt;&gt;<span class="number">1</span>;<span class="comment">//拆一半</span></span><br><span class="line">    <span class="keyword">if</span>(t&amp;<span class="number">1</span>)<span class="comment">//如何取中位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=a[(t<span class="number">+1</span>)/<span class="number">2</span>];</span><br><span class="line">        y=a[(n+t<span class="number">+1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=a[t/<span class="number">2</span>];<span class="comment">//不统一方向取,尽量防止相等</span></span><br><span class="line">        y=a[(n+t<span class="number">+1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">check</span>(x, y)&lt;&lt;endl;<span class="comment">//输出处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>M 数值膨胀之美</strong></p><p><strong>STL、排序，枚举</strong></p><p>要使得数组极差变小，显然需要先让最小值乘以 2 ，然后是<strong>次小值</strong>，……，以此类推。</p><p>新的区间一定会<strong>包含</strong>这个区间.我们需要在<strong>每次乘以 2 操作后计算</strong>数组的极差。</p><p>我们需要一个容器：每次操作可以在容器中<strong>删除</strong>一个数，<strong>并插入</strong>一个数。符合条件的容器有许多，我们选择的是 <strong>multiset</strong></p><p>时间复杂度 O(nlogn)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;<span class="comment">//用于读取</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; b;<span class="comment">//用于形成映射并排序</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; st;<span class="comment">//用于读取两个最值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        b.<span class="built_in">push_back</span>(&#123;a[i], i&#125;);<span class="comment">//用&#123;&#125;也能造pair</span></span><br><span class="line">        st.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());<span class="comment">//排序,从而读取原序列第k小值位置</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator it;<span class="comment">//先定义迭代器及其类型(auto 在 if里面不给用)</span></span><br><span class="line">    <span class="keyword">auto</span> [l, r] = b[<span class="number">0</span>];<span class="comment">//读取pair的一种方法</span></span><br><span class="line">    <span class="keyword">if</span>(( it=st.<span class="built_in">find</span>(l))!=st.<span class="built_in">end</span>())st.<span class="built_in">erase</span>(it);<span class="comment">//只能删除一个数一次,不然还得数多少个,麻烦</span></span><br><span class="line">    st.<span class="built_in">insert</span>(l * <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> ans = *st.<span class="built_in">rbegin</span>() - *st.<span class="built_in">begin</span>();<span class="comment">//逆向即末尾数</span></span><br><span class="line">    l = r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, i] : b)&#123;<span class="comment">//当用不上一个元素时,可用_代替(记得打上&amp;)</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= l &amp;&amp; i &lt;= r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l - <span class="number">1</span>; j &gt;= i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((it=st.<span class="built_in">find</span>(a[j]))!=st.<span class="built_in">end</span>())st.<span class="built_in">erase</span>(it);</span><br><span class="line">            st.<span class="built_in">insert</span>(a[j] * <span class="number">2</span>);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, *st.<span class="built_in">rbegin</span>() - *st.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="built_in">min</span>(l, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = r + <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((it=st.<span class="built_in">find</span>(a[j]))!=st.<span class="built_in">end</span>())st.<span class="built_in">erase</span>(it);</span><br><span class="line">            st.<span class="built_in">insert</span>(a[j] * <span class="number">2</span>);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, *st.<span class="built_in">rbegin</span>() - *st.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        r = <span class="built_in">max</span>(r, i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-井然有序之窗"><a href="#H-井然有序之窗" class="headerlink" title="H 井然有序之窗"></a>H 井然有序之窗</h2><p><strong>构造、贪心</strong></p><p><strong>从小到大考虑(后面选择合理的前提条件)</strong>1-n的数.在<strong>符合要求(l&lt;i,此时选择l更大的或者更小的都不会影响最终结果,因为都是符合这个要求的了)</strong>的<strong>所有</strong>区间中选择 <strong>r 最小的区间给使用掉(限制最严的)</strong>一定不会使得答案变劣。</p><p>可以使用<strong>优先队列维护右端点最小的区间</strong>，对区间<strong>先按左端点排序后</strong>，可以从前往后将左端点小于i的<strong>区间加入优先队列(所以这个优先队列里的一直都能用,因为i是从小到大考虑的,i增大后放进来的数也肯定还满足l&lt;i)</strong>，然后<strong>取出右端点最小</strong>的区间。</p><p>若右端点小于i ，理论上应该将这个区间丢弃，找到第一个满足右端点大于等于i的区间，但由<strong>于区间不能浪费(据题意每个区间内都要有一个数)</strong>，因此此时一定无解。若<strong>优先队列为空，同样无解</strong>。</p><p>我的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">st qujian&#123;</span><br><span class="line">    <span class="type">int</span> l;<span class="type">int</span> r;<span class="type">int</span> hao;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(qujian a,qujian b)</span><span class="comment">//用于sort比较的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l!=b.l)</span><br><span class="line">    <span class="built_in">ret</span>(a.l&lt;b.l);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">ret</span>(a.r&lt;b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(qujian a,qujian b)<span class="comment">//用于pq特殊比较的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l!=b.l)</span><br><span class="line">    <span class="built_in">ret</span>(a.l&gt;b.l);<span class="comment">//记得反过来</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">ret</span>(a.r&gt;b.r);</span><br><span class="line">&#125;</span><br><span class="line">lld n,a[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;<span class="type">int</span> nowhao=<span class="number">0</span>;<span class="comment">//标记第几个区间</span></span><br><span class="line">    pq&lt;qujian&gt;q;</span><br><span class="line">    deque&lt;qujian&gt;<span class="built_in">s</span>(n);<span class="comment">//提前预定好空间,从而下面可借助引用&amp;读取输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[l, r, i] : s)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        i = ++nowhao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">repp</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">front</span>().l&lt;=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [l,r,hao]=s.<span class="built_in">front</span>();s.<span class="built_in">pop_front</span>();<span class="comment">//因为不可以浪费,所以这里直接弹出就好</span></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;r,l,hao&#125;);<span class="comment">//注意只在这边反着存入,读取时仍然按原定义的l,r顺序读取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())&#123;<span class="comment">//特判空的1情况</span></span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>;ret <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> tt=q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(i&gt;tt.l)<span class="comment">//肯定不符合要求了</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">            ret <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[tt.hao]=i;q.<span class="built_in">pop</span>();<span class="comment">//在a的指定位置填入i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">repp</span>(i,<span class="number">1</span>,n)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ret <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>佬写的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    deque&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">a</span>(n);</span><br><span class="line">    <span class="type">int</span> pt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[l, r, i] : a)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        i = ++pt;</span><br><span class="line">    &#125;</span><br><span class="line">    ranges::<span class="built_in">sort</span>(a);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    set&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="built_in">size</span>() &amp;&amp; a[<span class="number">0</span>][<span class="number">0</span>] &lt;= i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [l, r, i] = a[<span class="number">0</span>];</span><br><span class="line">            st.<span class="built_in">insert</span>(&#123;r, l, i&#125;);</span><br><span class="line">            a.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [r, l, j] = *st.<span class="built_in">begin</span>();</span><br><span class="line">        st.<span class="built_in">erase</span>(st.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span>(r &lt; i)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="J-硝基甲苯之袭"><a href="#J-硝基甲苯之袭" class="headerlink" title="J 硝基甲苯之袭"></a>J 硝基甲苯之袭</h2><p><strong>因数分解、打表、质数筛</strong></p><p><strong>先x 的因子 t,再枚举 x</strong>  ，那么 y=x⊕t，再检查 gcd(x,y)=t 是否合法(逆向思维)**，若合法统计答案。</p><p>时间复杂度 O(nsqrt(n)) ，使用质数筛大概可以优化到 O(nlogn)) 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ci M = (<span class="type">int</span>)<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line">lld n,a[M],maxn,ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cin&gt;&gt;n;unordered_map&lt;lld,lld&gt;s;<span class="comment">//标记出现次数</span></span><br><span class="line">        <span class="built_in">repp</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">cin&gt;&gt;a[i];s[a[i]]++;maxn=<span class="built_in">max</span>(maxn,a[i]);&#125;</span><br><span class="line"><span class="built_in">repp</span>(i,<span class="number">1</span>,maxn)<span class="comment">//先枚举x的因子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(lld j=i;j&lt;=maxn;j+=i)<span class="comment">//再枚举数x</span></span><br><span class="line">&#123;</span><br><span class="line">lld k=i^j;</span><br><span class="line"><span class="keyword">if</span>(j&lt;k&amp;&amp;__gcd(j,k)==i&amp;&amp;k&lt;=maxn)<span class="comment">//需满足的条件</span></span><br><span class="line">ans+=s[j]*s[k];<span class="comment">//如果两个数都存在才会叠加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2025牛客寒假训练营"><a href="#2025牛客寒假训练营" class="headerlink" title="2025牛客寒假训练营"></a>2025牛客寒假训练营</h1><h2 id="D-字符串里串"><a href="#D-字符串里串" class="headerlink" title="D 字符串里串"></a>D 字符串里串</h2><p>思维、贪心</p><p>有一个比较容易想到的结论，如果从前往后第i&gt;1个字符在i之后的第j个位置还出现过，那么选择这[1,i]]前缀作为子串，子序列就把[1,i-1]和[j,j]拼在一起，就得到了两个不一样的子串。</p><p>然后把字符串翻转一下，再跑一次即可（<strong>从前往后和从后往前都是可以的不要只有一个方向</strong>）。</p><p>注意 “aba” 的<strong>答案是 0 ，而不是 1</strong> ，之前 std 也错了，不过数据里没有这个，所以不考虑这一个也能过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">2</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(s[i]))&#123; ans = <span class="built_in">max</span>(ans, i);<span class="keyword">break</span>;&#125;<span class="comment">//看后面有没有这个字母,仅在此可break</span></span><br><span class="line">        st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    st = <span class="built_in">set</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//可以清空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;<span class="comment">//另一个方向</span></span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(s[i])) ans = <span class="built_in">max</span>(ans, n - i + <span class="number">1</span>);</span><br><span class="line">        st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-字符串外串"><a href="#C-字符串外串" class="headerlink" title="C 字符串外串"></a>C 字符串外串</h2><p>构造</p><p>首先要知道D题的结论，那我们需要构造一个字符串使得<strong>从前往后看和从后往前看可爱度都是</strong>m的字符串。</p><p>那就思考一下<strong>类似回文串的构造</strong>方法。</p><p>如果 n超过了m的两倍，意味着前m个和后m个字母<strong>对称</strong>（”abcdefcba”），<strong>中间n-2m</strong>个字母在<strong>整个字符串中全都只能出现一次</strong>，总共需要的字母种类是m+n-2m=n-m，很显然字母种类不能超过26个。</p><p>如果 n不超过m的两倍，意味着前 n-m个和后n-m个字母对称（”abczzzcba”），<strong>中间字母任意</strong>，总共需要的字母种类是n-m，很显然字母种类不能超过26个。</p><p>按上述情况<strong>分类讨论构造</strong>一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0);cin.tie(0);</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n-m&gt;<span class="number">26</span>||n&lt;=m)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;ct;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;=<span class="number">2</span>*m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">repp</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">repp</span>(i,m,n-m<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">repm</span>(i,m<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">repp</span>(i,<span class="number">0</span>,n-m<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">repp</span>(i,<span class="number">1</span>,<span class="number">2</span>*m-n)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=(<span class="string">&#x27;a&#x27;</span>+n-m<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">repm</span>(i,n-m<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="H-一起画很大的圆！"><a href="#H-一起画很大的圆！" class="headerlink" title="H 一起画很大的圆！"></a>H 一起画很大的圆！</h2><p><strong>构造、计算几何，贪心</strong></p><p>三个不共线的点确定一个圆。</p><p>如果这三个点<strong>越接近一条直线，这个圆最大(三点共线的时候这个最大)</strong>。</p><p>那么我们需要在边界上找三个点使得最接近一条直线，<strong>猜一下有一个点会在边角</strong>，那剩下的点就不难确定了。</p><p><strong>横着</strong>可以找到一个答案是<img src="/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/9d846c00bf84543b285250dadf59bd12.png" alt="9d846c00bf84543b285250dadf59bd12">，但如果<img src="/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/c32aae6022cbfb5e60918fcde1845b07.png" alt="c32aae6022cbfb5e60918fcde1845b07"> 的话，就应该<strong>竖着</strong>找。</p><p>显然<strong>在长边取两个点越接近直线斜边也越长</strong></p><p>我们应当使得斜边尽可能的大，同时斜边所对的角尽可能的接近0 或 <img src="https://www.nowcoder.com/equation?tex=180%20%5E%7B%5Ccirc%7D" alt="180 ^{\circ}">。前者很好实现，令长边上的一点<strong>位于角落</strong>（如图中点A，短边上点尽可能靠近角落（如图中点C)，此时可使得AB所对的锐角角度最小(相切那个是<strong>角度最大</strong>)。</p><p><img src="/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/D2B5CA33BD970F64A6301FA75AE2EB22.png" alt="alt"></p><p>再<strong>移动一位</strong>取B</p><p><img src="/2025/02/16/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%E7%9A%84%E8%A1%A5/D2B5CA33BD970F64A6301FA75AE2EB22-1742044851694-89.png" alt="alt"></p><p>那么关键就在于<strong>找出长边</strong>了.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进行一个一个前端的雪</title>
      <link href="/2025/01/23/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9B%AA/"/>
      <url>/2025/01/23/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9B%AA/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Web-开发概况"><a href="#Web-开发概况" class="headerlink" title="Web 开发概况"></a>Web 开发概况</h2><p>Web 开发是指创建和维护<strong>网站</strong>、<strong>客户端程序</strong>、<strong>服务器</strong>与<strong>其他 Web 应用程序</strong>的过程。它包括使用不同的编程语言和技术来编写、测试和部署 Web 应用程序，以满足特定的业务需求和用户需求</p><p>通过 Web 开发技术，开发者能够设计实现诸多满足不同需求场景的<strong>应用程序</strong>，包括但不限于：网站开发、Android/IOS/Harmony OS NEXT 移动端应用程序、微信小程序、桌面应用、群聊机器人、游戏、浏览器插件、3D 建模、高性能服务器、分布式应用、虚拟现实应用、区块链、物联网设备……</p><h2 id="前端和后端"><a href="#前端和后端" class="headerlink" title="前端和后端"></a>前端和后端</h2><p>在软件架构和程序设计领域，前端是软件系统中<strong>直接</strong>和用户交互的部分，而后端控制着<strong>软件的输出</strong>。将软件分为前端和后端是一种将<strong>软件不同功能</strong>的部分相互分离的抽象</p><p>在 Web 开发中，前端在绝大多数情况下指能够被<strong>用户直接访问与交互的模块</strong>，如<strong>网页、手机 App、桌面应用、小程序等</strong>。后端包括<strong>程序运行的后台服务器</strong>、<strong>存储数据的数据库</strong>以及<strong>其他数据中间件</strong>。大部分软件都<strong>概念性地</strong>分成了前端和后端，在大多数情况下，软件的后端经常是隐藏着而不被用户看到</p><p><strong>狭义</strong>的前端通常是指网站或应用程序中与用户直接交互的部分。它是一种用于<strong>构建用户界面的技术和工具的集合</strong>，这些界面可以在 <strong>Web 浏览器</strong>中运行</p><p>后端开发主要负责编写<strong>运行在服务端上的</strong>代码，通常来说，这部分的工作需要和<strong>数据库</strong>与 <strong>Web API</strong> 打交道，比如读写数据、读写文件、实现业务逻辑等。有些时候，业务逻辑存储在<strong>客户端</strong>，这时后台就是用来<strong>以 Web 服务的形式</strong>提供数据库中的数据</p><p>开发者<strong>可以同时掌握</strong>前端和后端的技术，但大多数 Web 开发者都还是有<strong>一定的专精</strong>方向，甚至只在某一方面深入研究。尽管前后端是有天然的区别，但并没有规定它们各自的具体任务。有时前端只是完成数据的显示，而其他主要工作都在后端完成。但也有时，后端只是提供数据，而所有的计算和具体功能都在前端完成。前后端工作的分配，通常都是<strong>由项目的设计和架构来决定</strong>的</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器是用来<strong>检索、展示以及传递</strong> <strong>Web 信息资源的应用程序</strong>。Web 信息资源由<strong>统一资源标识符 (Uniform Resource Identifier，URI)</strong> 所标记，它可以是一张网页、一张图片、一段视频或者<strong>任何在 Web 上所呈现的内容</strong>。使用者可以<strong>借助超链接</strong>，<strong>通过浏览器浏览</strong>互相关联的信息</p><p>浏览器<strong>内核</strong> (Rendering Engine)，是指浏览器最核心的部分，负责<strong>对网页语法的解释（如标准通用标记语言下的一个应用 HTML、CSS、JavaScript）并渲染网页</strong>。通常所谓的浏览器内核也就是浏览器所采用的<strong>渲染引擎</strong>，渲染引擎决定了浏览器<strong>如何显示网页的内容</strong>以及<strong>页面的格式信息</strong>。不同的浏览器内核对网页编写语法的解释也有不同</p><h2 id="C-S-与-B-S-架构"><a href="#C-S-与-B-S-架构" class="headerlink" title="C/S 与 B/S 架构"></a><strong>C/S</strong> <strong>与</strong> <strong>B/S</strong> 架构</h2><p>C/S 架构是一种典型的<strong>两层架构</strong>，其全称是 <strong>Client/Server</strong>，即<strong>客户</strong>端<strong>服务器</strong>端架构，其客户端包含一个或多个在用户的电脑上运行的<strong>程序</strong>，而服务器端有两种，一种是<strong>数据库</strong>服务器端，客户端<strong>通过数据库连接访问服务器端的数据</strong>；另一种是 <strong>Socket</strong> 服务器端，<strong>服务器端的程序</strong>通过 Socket 与<strong>客户端的程序</strong>通信</p><p>B/S 架构的全称为 <strong>Browser/Server</strong>，即<strong>浏览器</strong>/<strong>服务器</strong>结构。Browser 指的是 <strong>Web 浏览器</strong>，极少数事务逻辑在前端实现，但<strong>主要</strong>事务逻辑在<strong>服务器端</strong>实现。B/S 架构的系统无须特别安装，<strong>只要有 Web 浏览器</strong>即可</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>超文本标记语言（Hyper Text Markup Language，简称：HTML）是一种<strong>用于创建网页</strong>的标准标记语言。HTML 是一种基础技术，常与 CSS、JavaScript 一起被众多网站用于<strong>设计网页</strong>、<strong>网页应用程序</strong>以及<strong>移动应用程序</strong>的<strong>用户界面</strong>。网页<strong>浏览器</strong>可以读取 HTML 文件，并将其<strong>渲染成可视化网页</strong>。HTML 描述了<strong>一个网站的结构语义随着线索的呈现</strong>，使之成为一种<strong>标记</strong>语言而非编程语言</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><strong>层叠样式表（Cascading Style Sheets）</strong>是一种用来<strong>为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）</strong>的计算机语言。CSS3 现在已被大部分现代浏览器支持，而下一版的 CSS4 仍在开发中。CSS 不仅可以<strong>静态地修饰</strong>网页，还可以<strong>配合各种脚本语言动态地</strong>对网页各元素进行<strong>格式</strong>化。CSS 能够对网页中元素位置的<strong>排版进行像素级精确控制</strong>，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript 是一种高级的、<strong>解释型</strong>的<strong>编程</strong>语言</p><p>JavaScript 是一门基于原型、头等函数的语言，是一门多范式的语言，它支持面向对象程序设计，指令式编程，以及函数式编程。它由 ECMA（欧洲电脑制造商协会）通过 ECMAScript 实现语言的标准化</p><p>ECMAScript 6.0（简称 ES6）是 JavaScript 语言的下一代<strong>标准</strong>，于 2015 年 6 月正式发布。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准</p><h2 id="计算机网络基础知识"><a href="#计算机网络基础知识" class="headerlink" title="计算机网络基础知识"></a>计算机网络基础知识</h2><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p><strong>HTTP 是 <em>Hyper Text Transfer Protocol</em>（超文本传输协议）</strong>的缩写。HTTP 协议用于<strong>从 WWW 服务器传输超文本到本地浏览器</strong>的传送协议。它可以使浏览器更加高效，使<strong>网络传输减少</strong>。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容<strong>首先</strong>显示 (如文本先于图形) 等。HTTP 是一个<strong>应用层协议</strong>，由<strong>请求</strong>和<strong>响应</strong>构成，是一个标准的<strong>客户端服务器模型</strong>。</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>在互联网上，<strong>每一</strong>信息资源都有<strong>统一的且在网上唯一的地址</strong>，该地址就叫 URL（Uniform Resource Locator, 统一资源定位符）。</p><p>URL 由三部分组成：资源<strong>类型</strong>、存放资源的<strong>主机域名</strong>、资源<strong>文件名</strong>。</p><p>也可认为由 4 部分组成：<strong>协议</strong>、<strong>主机</strong>、<strong>端口</strong>、<strong>路径</strong>。</p><p>URL 的一般格式为：<em>protocol :// hostname [:port] / path / [:parameters] [?query] #fragment</em></p><h4 id="IP-地址和-DNS"><a href="#IP-地址和-DNS" class="headerlink" title="IP 地址和 DNS"></a>IP 地址和 DNS</h4><p><strong>IP 地址</strong>（类似 192.168.1.1 内网网关）是<strong>互联网协议地址</strong>，它给因特网上的每<strong>台计算机和其它设备</strong>都规定了一个唯一的地址。由于有这种唯一的地址，才保证了用户在连网的计算机上操作时，能够高效而且方便地从千千万万台计算机中选出自己所需的对象来</p><p>但是 IP 地址毕竟是一串<strong>毫无规律</strong>的数字，并不方便人类的记忆和书写。因此在 IP 地址的基础上又发展出一种<strong>符号化</strong>的地址方案，来代替数字型的 IP 地址，每一个符号化的地址都与特定的 IP 地址对应。这个与网络上的数字型 IP 地址相对应的字符型地址，就是<strong>域名</strong></p><p>类似 <a href="https://www.google.com/">http://www.google.com</a> 这样的字符串就是“域名”，当访问 www.google.com 时，首先由 DNS（Domain Name System, DNS）域名系统<strong>解析为 IP 地址，随后再访问 IP</strong></p><h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>HTTP 请求是指从<strong>客户端到服务器端</strong>的请求消息，请求报文由请求行 (Request line)、请求头 (Header)，空行、请求正文 4 部分组成</p><h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><p>在接收和解释请求消息后，服务器会<strong>返回一个 HTTP 响应消息</strong>。HTTP 响应报文也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><p>根据 HTTP 标准，HTTP 请求可以使用多种<strong>请求方法</strong>。HTTP 方法描述了对给定资源的期望动作，每一种请求方法都抽象出了一种不同给定语义。</p><p>HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p>在实际开发中 <strong>GET、POST、PUT、DELETE</strong> 四类 HTTP 方法的使用率最高，能够用一套统一的语法规范对资源的 CRUD (增删改查) 逻辑进行抽象</p><p>GET 方法请求一个指定资源的<strong>表示形式</strong>，使用 GET 的请求应该<strong>只被用于获取数据</strong></p><p>POST 方法用于<strong>将实体提交到指定的资源</strong>，通常导致在服务器上的<strong>状态变化</strong>或副作用</p><p>PUT 方法用<strong>请求有效载荷替换</strong>目标资源的所有当前表示</p><p>DELETE 方法<strong>删除指定的资源</strong></p><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一<strong>个包含 HTTP 状态码的信息头</strong>（server header）<strong>用以响应</strong>浏览器的请求</p><p>状态码类型：</p><div class="table-container"><table><thead><tr><th>状态码</th><th>类别</th><th>原因</th></tr></thead><tbody><tr><td>1xx</td><td><strong>信息性</strong>状态码</td><td>接收的请求<strong>正在处理</strong></td></tr><tr><td>2xx</td><td><strong>成功</strong>状态码</td><td>请求正常处理<strong>完毕</strong></td></tr><tr><td>3xx</td><td><strong>重定向</strong>状态码</td><td>需要<strong>进行附加操作</strong>以完成请求</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>状态码</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td><strong>服务端错误</strong>状态码</td><td>服务器处理请求出错</td></tr></tbody></table></div><p>常见的状态码：</p><p><strong>100 Continue</strong></p><p>客户端应继续其请求</p><p><strong>200 OK</strong></p><p>请求成功，一般用于 <strong>GET 与 POST</strong> 请求</p><p><strong>201 Created</strong></p><p>已创建，<strong>成功请求并创建</strong>了新的资源</p><p><strong>401 Unauthorized</strong></p><p>请求要求用户的<strong>身份认证</strong></p><p><strong>403 Forbidden</strong></p><p>服务器理解请求客户端的请求，但是<strong>拒绝执行</strong>此请求</p><p><strong>404 Not Found</strong></p><p>服务器<strong>无法</strong>根据客户端的请求<strong>找到</strong>资源（网页）。</p><p><strong>500 Internal Server Error</strong></p><p>服务器<strong>内部错误</strong>，无法完成请求</p><h4 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a><strong>RESTful</strong> <strong>API</strong></h4><p><strong>REST 全称是 Representational State Transfer</strong>，中文意思是<strong>表述性状态转移</strong>。</p><p>RESTful 架构应该遵循<strong>统一接口原则</strong>，统一接口包含了一组<strong>受限的预定义的操作</strong>，不论什么样的资源，都是<strong>通过使用相同的接口</strong>进行资源的访问。</p><p>接口应该使用<strong>标准的 HTTP 方法</strong>如 GET，PUT 和 POST，并遵循这些方法的语义。</p><p>REST 所谓的表述指的是<strong>对资源的表述</strong>。要让一个资源可以被<strong>识别</strong>，需要有个<strong>唯一标识</strong>，在 Web 中这个唯一标识就是 <strong>URI</strong></p><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><h4 id="Git-版本控制工具"><a href="#Git-版本控制工具" class="headerlink" title="Git 版本控制工具"></a>Git 版本控制工具</h4><p>Git 是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</p><h4 id="GitHub-代码托管仓库"><a href="#GitHub-代码托管仓库" class="headerlink" title="GitHub 代码托管仓库"></a>GitHub 代码托管仓库</h4><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为<strong>只支持 Git</strong> 作为<strong>唯一的版本库格式</strong>进行托管</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>库是一系列预先定义好的数据结构和函数或类的集合，程序员可以通过调用这些代码实现功能。简单来说就是库为我们提供了很多封装好的函数，看起来比较零散，但使用起来更灵活</p><p>使用库可以简化开发流程，提高开发效率。例如，jQuery 提供了简化 DOM 操作的语法，减少了编写繁琐代码的需要。React 通过虚拟 DOM 和声明式 UI ，便于<strong>快速构建用户界面</strong></p><p>如果需要<strong>在网页中使用 JavaScript 库</strong>，可以去网上<strong>下载库文件</strong>，<strong>放在网页的同一目录</strong>下，再到<strong><code>script</code>标签中引入</strong>。或者不下载通过<strong>通过链接在<code>&lt;script&gt;</code>标签中引用该库</strong>即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>或者在代码中通过 <code>require</code> 或者 <code>import</code> 中引入库。在现代的前端开发中，通常推荐使用 <code>import</code> 来进行模块导入，特别是在使用现代 JavaScript 特性的项目中。这主要与现代 JavaScript 的发展趋势和语言特性有关</p><p><code>import</code> 是 ES6 新引入的关键字，支持<strong>按需导入</strong>，而不需要导入整个模块。同时<code>import</code> 的语法也比 <code>require</code> 更直观清晰，更符合现代变成风格</p><p>随着 JavaScript 生态的发展，越来越多的库和工具采用了 ES6 模块系统，使用 <code>import</code> 能够更好地与这些现代化的工具和库进行集成。</p><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架是提供<strong>如何构建应用程序的意见的库</strong>，是<strong>一整套的工具</strong>，所有东西已经准备齐全了，可以按照它的规定就可以很简单的完成一些事情，但我们<strong>不能去改变它，只能按照要求</strong>使用，并且其他人拿到这套工具也是一样的，如 Vue、Angular 等等。</p><p>注意是<strong>一套而不是单个</strong>，比如 React 就是一个库，它本身只是一个前端渲染的库，纯粹地写 UI 组件，没有什么异步处理机制、模块化等，但是当它结合 Redux 和 React-router 的时候，就是一个框架了。</p><p>框架和库的联系紧密，都是为了提高我们的开发效率而存在，库的使用上会<strong>简单</strong>一些，更加<strong>灵活</strong>，但<strong>功能不全</strong>。而框架的功能很<strong>全面</strong>，但需要我们<strong>按规定</strong>去使用。也就是说库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构，控制权在使用者手中。框架则是面向一个领域，提供了<strong>一套解决方案</strong></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>库是一组已经实现的<strong>代码集合</strong>，提供了特定功能的函数和方法，开发者可以根据需要选择性地使用。库不控制应用程序的整体架构，而是为开发者提供了可调用的工具，以便在应用程序中实现特定功能</p><p>框架是一种提供了<strong>一整套解决方案的软件结构</strong>，它规定了整个应用程序的架构，定义了组织代码的方式，并提供了一系列工具和库，以便开发者可以在框架的基础上构建应用。框架通常有一个完整的生命周期，控制着应用程序的流程，开发者需要按照框架的规则来编写代码。</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h4 id="什么是-Node-js"><a href="#什么是-Node-js" class="headerlink" title="什么是 Node.js"></a>什么是 Node.js</h4><p>JavaScript 是一个<strong>脚本语言</strong>，最初用来处理网页中的一些动态功能和一些用户行为。它一般运行于浏览器</p><p>但是这门语言后续不断更新，越来越多的人开始使用 JavaScript 。为了把它迁移到了服务端，但服务端上又不能跑浏览器，那我们就需要一种新的运行环境。就这样，这个基于 Chrome V8 引擎的 JavaScript 运行时 Node.js 诞生了</p><h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>在计算机编程中，模块是指一个<strong>相对独立的程序文件或代码库</strong>，通常包含一组相关的函数、变量、类或其他可重用的代码构件，每个模块在内部执行某个功能。并向外部公开一定的接口以供其他模块使用。在编程语言中，通常有一些标准库或第三方库，这些库都是由多个模块组成的，可以在程序中被引用和使用。模块化主要是为了帮助程序员组织和管理大型代码库，可以将大型的程序有逻辑地拆分成一个个相对较小的部分，实现代码复用，让程序设计更加灵活，使其更易于维护和扩展。这是优点之一。并且还可以避免变量名和函数名命名冲突的问题以及解决不同模块之间的依赖关系。</p><p>比如，我要写一个 Wordle 小游戏，普通代码编写就把所有代码像画布渲染，键盘的输入，逻辑判断等都写到一个 HTML 文件里，如果使用模块化概念，我们可以简单分块，分成主文件，键盘输入，逻辑判断以及读取 json 等多个模块，然后在各个文件里实现相应的逻辑，这样假如你发现 json 的读取有问题，你就可以直接去找读 json 那个文件有没有问题，这样会让代码的后续维护更简单，目的更明确。</p><p><code>import</code> 和 <code>export</code> 是 ES6 引入的模块系统的关键字，用于在 JavaScript 中进行模块化编程。模块化使得代码更结构化、可维护，并允许开发者将代码分割为<strong>小的可重用部分</strong></p><h4 id="export-的使用："><a href="#export-的使用：" class="headerlink" title="export 的使用："></a><code>export</code> 的使用：</h4><p><code>export</code> 用于将变量、函数、类或其他声明<strong>导出为模块的公共接口</strong>，以便其他模块可以使用。有三种常见的 <code>export</code> 的方式</p><h5 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h5><p>可以通过 <code>export</code> 关键字<strong>单独导出</strong>多个成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h5><p>通过 <code>export default</code> 关键字导出一个<strong>默认</strong>成员，每个模块只能有<strong>一个</strong>默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myVariable;</span><br></pre></td></tr></table></figure><h4 id="import-的使用："><a href="#import-的使用：" class="headerlink" title="import 的使用："></a><code>import</code> 的使用：</h4><p><code>import</code> 用于在一个模块中引入其他模块导出的成员，以便在当前模块中使用。有三种常见的 <code>import</code> 的方式：</p><h5 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h5><p>导入其他模块中的命名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myVariable, myFunction &#125; <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h5><p>导入其他模块中的默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> myVariable <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="导入所有"><a href="#导入所有" class="headerlink" title="导入所有"></a>导入所有</h5><p>导入其他模块的所有导出，形成一个<strong>命名空间对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> internalVariable = <span class="string">&quot;internal&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> internalVariable;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myVariable, myFunction &#125; <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myVariable); <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">myFunction</span>();</span><br><span class="line"><span class="keyword">import</span> internalVariable <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(internalVariable); <span class="comment">// &#x27;internal&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">myVariable</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>JavaScript 包是一种封装了代码、资源的组织形式，能够方便共享、安装和管理代码。这些包可以包含 JavaScript 库、框架、工具或应用程序等。而 <strong><code>npm</code> 就是管理这些包的工具</strong>（当然除了 <code>npm</code> 也有其他工具，比如 <code>yarn</code>、<code>yum</code>等），专门用于在服务器端和命令行工具中管理 JavaScript 包</p><p>为什么我们需要包管理工具呢？我们一次性把包都下载到电脑里，像 C 语言的头文件一样，需要用什么拿什么不就好了吗？首先，JavaScript 的包<strong>多达 90 万个</strong>，将所有这些包完全下载到本地会占用大量存储空间。这对于开发者的计算机来说可能是不切实际的，特别是在多个项目中共享相同的依赖项时。其次，软件包和库经<strong>常会更新</strong>，手动下载所有包可能导致更新不及时，使得项目失去了最新的功能和安全性修复。最后，有的项目需要使用某个包特定的版本，使用其他版本会导致项目无法运行或出现其他 bug，而<strong>包管理工具允许开发者指定项目所使用的依赖项的特定版本</strong>，以确保项目的稳定性和一致性。手动下载所有包可能会导致版本冲突和不同环境之间的不一致。因此我们需要使用包管理工具</p><p><code>npm</code> 是<strong>随同 Node.js 安装的包管理工具</strong>，安装好 node 之后就会默认安装好 <code>npm</code> 了</p><p>我们可以在命令行中输入 <code>npm -v</code> 判断是否安装了 <code>npm</code></p><h5 id="npm-的常见命令"><a href="#npm-的常见命令" class="headerlink" title="npm 的常见命令"></a><code>npm</code> 的常见命令</h5><p><code>npm install &lt;Module Name&gt;</code> 使用 <code>npm</code> 命令<strong>本地安装</strong>模块</p><p><code>npm install -g &lt;Module Name&gt;</code> <strong>全局</strong>安装</p><p>两个的区别就是本地安装将安装包<strong>放在当前文件夹的 <code>node_modules</code></strong> （如果没有则会自动生成）文件夹下，<strong>通过 <code>import</code></strong> 来引入本地安装的包；全局安装包则通常放<strong>在 <code>node</code> 的安装目录下</strong>，可以<strong>直接在命令行里</strong>使用</p><p><code>npm uninstall &lt;Name&gt;</code> 卸载模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm@&lt;版本号&gt;//更新 npm</span><br></pre></td></tr></table></figure><p><code>npm publish</code> 将自己的代码发布到 <strong><code>npm</code> 上的全球开源库</strong>中</p><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h5><p><code>package.json</code> 是 Node.js 项目中的一个重要文件，它用于<strong>存储项目的配置信息</strong>。包含了项目的元数据（metadata），如项目名称、版本、作者、依赖库等信息。通过描述项目上下文、所需依赖和开发脚本，使项目具备可重复性和可移植性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;learn_react&quot;</span>, <span class="comment">// 项目的名称</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>, <span class="comment">// 项目的版本号</span></span><br><span class="line">    <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>, <span class="comment">// 用于指示是否将该项目发布到公共的包注册表的标志</span></span><br><span class="line">    <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 项目运行时所依赖的第三方包</span></span><br><span class="line">        <span class="string">&quot;@testing-library/jest-dom&quot;</span>: <span class="string">&quot;^5.14.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@testing-library/react&quot;</span>: <span class="string">&quot;^13.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@testing-library/user-event&quot;</span>: <span class="string">&quot;^13.2.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@types/jest&quot;</span>: <span class="string">&quot;^27.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@types/node&quot;</span>: <span class="string">&quot;^16.7.13&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@types/react&quot;</span>: <span class="string">&quot;^18.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@types/react-dom&quot;</span>: <span class="string">&quot;^18.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;react&quot;</span>: <span class="string">&quot;^18.2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;react-dom&quot;</span>: <span class="string">&quot;^18.2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;react-scripts&quot;</span>: <span class="string">&quot;5.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;^4.4.2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;web-vitals&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 定义一组自定义的命令脚本</span></span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;browserslist&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 用于指定项目所支持的目标浏览器范围的配置文件，通常用于前端开发</span></span><br><span class="line">        <span class="string">&quot;production&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;&gt;0.2%&quot;</span>, <span class="comment">// 支持全球使用率超过0.2%的浏览器</span></span><br><span class="line">            <span class="string">&quot;not dead&quot;</span>, <span class="comment">// 排除已经被官方宣布为不再更新的浏览器</span></span><br><span class="line">            <span class="string">&quot;not op_mini all&quot;</span> <span class="comment">// 用于排除 Opera Mini 浏览器，Opera Mini 具有一些独特的行为或限制，需要在项目中进行特殊处理</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;development&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;last 1 chrome version&quot;</span>, <span class="comment">// 支持每个浏览器的最后一个版本</span></span><br><span class="line">            <span class="string">&quot;last 1 firefox version&quot;</span>,</span><br><span class="line">            <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目有 <code>package.json</code> 文件，则通过命令 <code>npm install</code> <strong>可以根据 <code>&quot;dependencies&quot;</code></strong> 自动在 <code>node_modules</code> 文件夹中安装项目所需的所有包</p><p>注：上述 <code>package.json</code> 的注释是粘贴到 md 后再加的，目的是讲解<strong>键值对的意义</strong>，而 json 文件中是<strong>不允许添加注释的</strong>：</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包是指<strong>将多个模块（ JavaScript、CSS、图片等）打包成为一个文件</strong>，这有助于代码管理、发布和使用。在前端开发中，通常需要使用打包工具将代码打包成<strong>浏览器可识别</strong>的格式，并优化加载速度和性能。</p><p>为什么前端需要打包？以前的前端开发存在三个大问题：没有模块化、第三方包的引入繁琐困难、代码以明文形式展示出来</p><p>我们利用打包工具就可以实现：支持模块化、自动打包第三方包、代码混淆，使得其他人无法阅读</p><p>下面介绍两个常使用的与打包有关的工具.</p><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>Babel 是一个 JavaScript 编译器，它能够将 ECMAScript 2015+ 的新特性转换为向后兼容的 JavaScript 代码，例如将 ES6 的箭头函数转换为普通函数、将模板字符串转换为常规字符串等等，使得我们可以在现代浏览器中使用最新的 JavaScript 特性，从而<strong>解决浏览器兼容性问题</strong></p><p>执行 <code>npm install -g babel-cli</code> 安装 Babel</p><p>在项目根目录创建 <code>.babelrc</code> 文件，这是 Babel 的配置文件，并编写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>npm install babel-preset-es2015</code> 安装转码器，就是从源码转到老版本的代码中间的语法映射表</p><p>在根目录创建 <code>src</code> 文件夹，新建 <code>index.js</code> 并编写如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[a, b, c] = [b, c, a + <span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br></pre></td></tr></table></figure><p>这里用到了 ES6 的新特性<strong>解构赋值</strong>，执行 <code>babel src -d dist</code> Babel 就能够将它转换为旧的 ES2015 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./dist/index.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> _ref = [b, c, a + <span class="number">1</span>];</span><br><span class="line">a = _ref[<span class="number">0</span>];</span><br><span class="line">b = _ref[<span class="number">1</span>];</span><br><span class="line">c = _ref[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br></pre></td></tr></table></figure><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>Webpack 是一个模块打包工具，它可以将<strong>多个模块打包</strong>成<strong>一个或多个 JavaScript 文件</strong>，而这些 JavaScript 文件可以被浏览器正确加载执行。Webpack 可以处理各种类型的资源文件，如 JS、CSS、图片等，并提供了各种插件和 loader 用于对不同类型的资源进行处理和优化，同时还支持热更新功能，方便开发人员进行调试和开发</p><p>Webpack 会<strong>隐藏源码的细节</strong>，把多个 JavaScript 合并成一个 JavaScript，提高浏览器的<strong>访问速度</strong>，使源码<strong>更加安全</strong></p><p>执行 <code>npm install -g webpack webpack-cli</code> 安装 Webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入path模块,nodejs的内置模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">//定义JS打包的规则</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//指定构建的模式</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="comment">//入口函数从哪里开始进行编译打包</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">    <span class="comment">//编译成功以后要把内容输出到那里去</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//定义输出的指定的目录__dirname 当前项目根目录，将生成一个dist文件夹</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">        <span class="comment">//合并的js文件存储在dist/bundle.js文件中</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;res.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>终端执行 <code>webpack</code> 即可在 <strong><code>dist</code> 文件夹中</strong>看到生成的 <code>res.js</code>，这就是合并后的 JavaScript 代码</p><p>通常在前端项目中，我们会<strong>将 Babel 和 Webpack 结合</strong>使用，使用 Babel 将最新版本的语法<strong>转换成向后兼容的代码</strong>，再由 Webpack 将这些代码<strong>打包并优化</strong>，最终生成浏览器可以解析的文件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建备忘</title>
      <link href="/2025/01/18/hexo%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/01/18/hexo%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="hexo博客最常用的套路"><a href="#hexo博客最常用的套路" class="headerlink" title="hexo博客最常用的套路"></a>hexo博客最常用的套路</h2><ol><li><code>hexo g; hexo s</code>本地预览，再更改，直到满意为止</li><li><code>hexo d</code>或者<code>hexo g; hexo d</code>远程部署。</li><li>hexo new “title” # 默认是post，如果博客名称有空格需要用双引号包裹起来</li></ol><h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>Front-matter 是 markdown 文件<strong>最上方</strong>以 —- 分隔的區域，用於指定個別檔案的變數。</p><p>Page Front-matter 用於 頁面 配置<br>Post Front-matter 用於 文章頁 配置<br>如果標注可選的參數，可根據自己需要添加，不用全部都寫在 markdown 裏</p><h4 id="Page-Front-matter-md渲染好像放在开头才有效果"><a href="#Page-Front-matter-md渲染好像放在开头才有效果" class="headerlink" title="Page Front-matter(md渲染好像放在开头才有效果)"></a>Page Front-matter(md渲染好像放在开头才有效果)</h4><p><img src="/2025/01/18/hexo%E4%BD%BF%E7%94%A8/5b3a26a09ff1908363efb29e78f6c2fc.png" alt="5b3a26a09ff1908363efb29e78f6c2fc"></p><p><img src="/2025/01/18/hexo%E4%BD%BF%E7%94%A8/2f0c8e78306edad277656d22ef1c220f.png" alt="2f0c8e78306edad277656d22ef1c220f"></p><h4 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line">abcjs:</span><br><span class="line"><span class="section">noticeOutdate:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p><img src="/2025/01/18/hexo%E4%BD%BF%E7%94%A8/c702dece8b2fa2b5e5d8eab28dc60763.png" alt="c702dece8b2fa2b5e5d8eab28dc60763"></p><h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><p>標籤頁<strong>文件名</strong>不一定是 tags, 例子中的 tags 只是一個示例.記得添加 type: “tags”</p><p>1.前往你的 Hexo 的根目錄</p><p>2.輸入 <strong>hexo new page tags</strong></p><p>3.你會找到 source/tags/index.md 這個文件</p><p>修改這個文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 標籤</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &#x27;tags&#x27;</span><br><span class="line">orderby: random</span><br><span class="line"><span class="section">order: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p><img src="/2025/01/18/hexo%E4%BD%BF%E7%94%A8/e416034ea913cfc279af6527b4174a3d.png" alt="e416034ea913cfc279af6527b4174a3d"></p><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><p><strong>hexo new page categories</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分類</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &#x27;categories&#x27;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h2><p><strong>hexo new page link</strong></p><p>在 Hexo 根目錄中的 source/_data（如果沒有 _data 文件夾，請自行創建），創建一個文件 link.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情鏈接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、簡單且強大的網誌框架</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">網站</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">值得推薦的網站</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Youtube</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.youtube.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">視頻網站</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Weibo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.weibo.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">中國最大社交分享平台</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Twitter</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://twitter.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">社交分享平台</span></span><br></pre></td></tr></table></figure><p>從 4.0.0 開始，支持從遠程加載友情鏈接，遠程拉取只支持 json。</p><p><strong>注意： 選擇遠程加載後，本地生成的方法會無效。</strong></p><p>在 source/link/index.md 這個文件的 front-matter 添加遠程鏈接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink_url: xxxxx</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;class_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;友情鏈接&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;class_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;那些人，那些事&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;link_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hexo.io/zh-tw/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快速、簡單且強大的網誌框架&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;class_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;網站&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;class_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值得推薦的網站&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;link_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Youtube&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.youtube.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;視頻網站&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Weibo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.weibo.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中國最大社交分享平台&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Twitter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://twitter.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;社交分享平台&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="子页面"><a href="#子页面" class="headerlink" title="子页面"></a>子页面</h2><p>子頁面也是普通的頁面，你只需要 hexo n page xxxxx 創建你的頁面就行</p><p>然後使用標簽外掛 gallery，具體用法請查看對應的內容。</p><p><strong>如果你想要使用 /photo/ohmygirl 這樣的鏈接顯示你的圖片內容.你可以把創建好的 ohmygirl 整個文件夾移到 photo 文件夾裏去</strong></p><h2 id="404-頁面"><a href="#404-頁面" class="headerlink" title="404 頁面"></a>404 頁面</h2><p>主題內置了一個簡單的 404 頁面，可在設置中開啟</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;頁面沒有找到&#x27;</span></span><br><span class="line">  <span class="attr">background:</span></span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h2><p>关于图片插入的问题可以看这篇大佬的博客:<a href="https://luoynothing.github.io/2023/08/31/📣-处理hexo博客中图片不显示问题/">📣 处理hexo博客中图片不显示问题 - 归故里</a>(<strong>我推荐用第一阶段的)</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
